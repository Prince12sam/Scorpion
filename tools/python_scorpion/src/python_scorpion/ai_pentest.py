"""
AI-Powered Autonomous Penetration Testing Agent
Uses LLM API (OpenAI/Anthropic/etc.) for intelligent decision-making
Orchestrates existing Scorpion tools based on findings and goals
"""
import asyncio
import json
import os
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import httpx
from enum import Enum

from .scanner import async_port_scan, async_syn_scan, async_udp_scan, async_advanced_scan
from .ssl_analyzer import analyze_ssl
from .takeover import takeover_scan
from .api import api_probe
from .recon import recon
from .tech import detect_tech
from .web_pentest import AdvancedWebTester
from .os_fingerprint import OSFingerprinter
from .payload_generator import PayloadGenerator
from .bruteforce import AuthBruteForcer
from .fuzzer import AdvancedFuzzer
from .dirbuster import dirbust_scan
from .crawler import crawl
from .nuclei_wrapper import NucleiScanner
from .cloud import cloud_audit
from .k8s import k8s_audit
from .container_sec import container_audit


class PrimaryGoal(str, Enum):
    COMPREHENSIVE = "comprehensive_assessment"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_ACCESS = "data_access"
    NETWORK_MAPPING = "network_mapping"
    WEB_EXPLOITATION = "web_exploitation"
    SHELL_ACCESS = "gain_shell_access"
    VULN_DISCOVERY = "vulnerability_discovery"
    INFRASTRUCTURE = "infrastructure_assessment"
    CLOUD_SECURITY = "cloud_security_audit"
    API_SECURITY = "api_security_testing"


class AutonomyLevel(str, Enum):
    SUPERVISED = "supervised"  # Asks for confirmation before each action
    SEMI_AUTONOMOUS = "semi_autonomous"  # Asks before high-risk actions
    FULLY_AUTONOMOUS = "fully_autonomous"  # Executes without confirmation (DANGEROUS)


class StealthLevel(str, Enum):
    LOW = "low"  # Fast, noisy scans
    MODERATE = "moderate"  # Balanced approach
    HIGH = "high"  # Slow, stealthy scans


class RiskTolerance(str, Enum):
    LOW = "low"  # Only passive/safe actions
    MEDIUM = "medium"  # Active scanning, no exploitation
    HIGH = "high"  # Full exploitation (requires authorization)


@dataclass
class AIPentestConfig:
    """Configuration for AI penetration test"""
    target: str
    primary_goal: PrimaryGoal
    secondary_goals: List[str]
    time_limit: int  # minutes
    stealth_level: StealthLevel
    autonomy_level: AutonomyLevel
    risk_tolerance: RiskTolerance
    ai_provider: str  # openai, anthropic, custom
    api_key: str
    api_endpoint: Optional[str] = None
    model: str = "gpt-4"
    learning_mode: bool = False
    max_iterations: int = 10


@dataclass
class Finding:
    """Represents a security finding"""
    timestamp: str
    tool: str
    severity: str
    category: str
    description: str
    details: Dict[str, Any]
    exploitation_potential: str
    recommended_action: str


@dataclass
class AgentAction:
    """Represents an action taken by the AI agent"""
    timestamp: str
    action_type: str
    tool: str
    parameters: Dict[str, Any]
    reasoning: str
    risk_level: str


class AIProvider:
    """Handles communication with AI providers (OpenAI, Anthropic, etc.)"""
    
    def __init__(self, provider: str, api_key: str, model: str, endpoint: Optional[str] = None):
        self.provider = provider.lower()
        self.api_key = api_key
        self.model = model
        self.endpoint = endpoint
        self.client = httpx.AsyncClient(timeout=60.0)
        
    async def query(self, system_prompt: str, user_prompt: str, temperature: float = 0.7) -> str:
        """Query the AI provider"""
        try:
            if self.provider == "openai":
                return await self._query_openai(system_prompt, user_prompt, temperature)
            elif self.provider == "anthropic":
                return await self._query_anthropic(system_prompt, user_prompt, temperature)
            elif self.provider == "github":
                return await self._query_github(system_prompt, user_prompt, temperature)
            elif self.provider == "custom":
                return await self._query_custom(system_prompt, user_prompt, temperature)
            else:
                raise ValueError(f"Unsupported AI provider: {self.provider}")
        except Exception as e:
            error_msg = str(e)
            
            # Provide helpful error messages based on error type
            if "404" in error_msg and self.provider == "openai":
                raise Exception(
                    f"OpenAI API returned 404 - your API key may be invalid or incomplete.\n"
                    f"Current provider: {self.provider}\n"
                    f"API key starts with: {self.api_key[:10]}...\n\n"
                    f"Solutions:\n"
                    f"1. Verify your OpenAI API key at: https://platform.openai.com/api-keys\n"
                    f"2. If using GitHub Models, your key should start with 'ghp_'\n"
                    f"3. Try explicitly setting provider: --ai-provider github\n"
                    f"4. Check your .env file or SCORPION_AI_API_KEY variable"
                )
            elif "401" in error_msg or "403" in error_msg:
                raise Exception(
                    f"Authentication failed with {self.provider}.\n"
                    f"API key starts with: {self.api_key[:10]}...\n\n"
                    f"Solutions:\n"
                    f"1. GitHub Models: Get token from https://github.com/marketplace/models\n"
                    f"2. OpenAI: Get key from https://platform.openai.com/api-keys\n"
                    f"3. Verify key is correct and not expired\n"
                    f"4. Try: export SCORPION_AI_API_KEY='your-correct-key'"
                )
            elif "429" in error_msg:
                raise Exception(
                    f"Rate limit exceeded for {self.provider}.\n"
                    f"Solutions:\n"
                    f"1. Wait 1-2 minutes before retrying\n"
                    f"2. Use --time-limit to reduce scan speed\n"
                    f"3. GitHub Models: 15-60 requests/min limit\n"
                    f"4. OpenAI: Check usage at https://platform.openai.com/usage"
                )
            else:
                raise Exception(f"AI provider ({self.provider}) error: {error_msg}")
    
    async def _query_openai(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query OpenAI API"""
        url = self.endpoint or "https://api.openai.com/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["choices"][0]["message"]["content"]
    
    async def _query_anthropic(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query Anthropic Claude API"""
        url = self.endpoint or "https://api.anthropic.com/v1/messages"
        headers = {
            "x-api-key": self.api_key,
            "anthropic-version": "2023-06-01",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "max_tokens": 2000,
            "temperature": temperature,
            "system": system_prompt,
            "messages": [
                {"role": "user", "content": user_prompt}
            ]
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["content"][0]["text"]
    
    async def _query_github(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query GitHub Models API (OpenAI-compatible)"""
        url = self.endpoint or "https://models.inference.ai.azure.com/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000,
            "top_p": 1.0
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["choices"][0]["message"]["content"]
    
    async def _query_custom(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query custom OpenAI-compatible endpoint"""
        if not self.endpoint:
            raise ValueError("Custom provider requires endpoint URL")
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(self.endpoint, headers=headers, json=data)
        response.raise_for_status()
        
        # Handle Ollama streaming response (multiple JSON objects)
        content = response.text
        if '\n' in content and content.count('{') > 1:
            # Ollama streaming format - parse last complete JSON
            lines = [line.strip() for line in content.strip().split('\n') if line.strip()]
            for line in reversed(lines):
                try:
                    result = json.loads(line)
                    if "message" in result and "content" in result["message"]:
                        return result["message"]["content"]
                    elif "response" in result:
                        return result["response"]
                except json.JSONDecodeError:
                    continue
        
        # Standard JSON response
        result = response.json()
        
        # Handle different response formats
        if "choices" in result:
            return result["choices"][0]["message"]["content"]
        elif "message" in result and "content" in result["message"]:
            return result["message"]["content"]
        elif "response" in result:
            return result["response"]
        elif "content" in result:
            return result["content"][0]["text"]
        else:
            raise ValueError("Unexpected API response format")
    
    async def close(self):
        """Close the HTTP client"""
        await self.client.aclose()


class AIPentestAgent:
    """Autonomous AI-powered penetration testing agent"""
    
    def __init__(self, config: AIPentestConfig):
        self.config = config
        self.findings: List[Finding] = []
        self.actions: List[AgentAction] = []
        self.ai_provider = AIProvider(
            config.ai_provider,
            config.api_key,
            config.model,
            config.api_endpoint
        )
        self.start_time = datetime.now()
        self.iteration = 0
        self.knowledge_base: Dict[str, Any] = {}
        
    def _get_system_prompt(self) -> str:
        """Get the system prompt for the AI"""
        return f"""You are an expert penetration testing AI assistant integrated into Scorpion CLI.

Your role: Analyze security findings and determine the next best action to achieve the testing goal.
You are capable of full-spectrum security testing from reconnaissance to exploitation.

Available tools and their purposes:

RECONNAISSANCE:
- recon: DNS enumeration, WHOIS, subdomain discovery
- tech_detect: Identify technologies, frameworks, versions
- os_fingerprint: Identify operating system and version
- crawler: Discover hidden endpoints, secrets, API paths
- dirbuster: Directory and file enumeration

SCANNING:
- port_scan: Discover open TCP ports and services
- udp_scan: UDP service discovery
- syn_scan: Stealthy SYN scan (requires admin/root)
- advanced_scan: Service version detection and OS fingerprinting
- ssl_analyze: SSL/TLS configuration and vulnerabilities

VULNERABILITY ASSESSMENT:
- web_pentest: Test for web vulnerabilities (SQLi, XSS, SSRF, RCE, LFI, etc.)
- api_test: API security testing and authentication bypass
- fuzzer: Parameter fuzzing to discover hidden vulnerabilities
- nuclei: Run Nuclei vulnerability scanner (if available)
- takeover_scan: Subdomain takeover vulnerability detection
- cloud_audit: Test cloud storage misconfigurations (S3, Azure, GCS)
- k8s_audit: Kubernetes security audit
- container_audit: Container registry security assessment

EXPLOITATION (HIGH RISK):
- bruteforce: Credential brute-forcing (Basic Auth, forms, APIs)
- payload_generate: Generate OS-specific reverse/bind shells, web shells
  * CRITICAL: Analyze OS fingerprint findings BEFORE generating payloads
  * Windows detected (ports 3389/445/135) → shell="powershell"
  * Linux/Unix detected (port 22/Apache/Nginx) → shell="bash"
  * Unknown OS → shell="python" (cross-platform)
  * Always include detected_os in reasoning
- exploit_vuln: Exploit discovered vulnerabilities to gain shell access

DIRECT COMMAND EXECUTION:
- execute_command: Run system commands directly on attacker machine
  * Windows: PowerShell commands (Get-Process, Invoke-WebRequest, etc.)
  * Linux/macOS: Bash commands (curl, wget, nc listener setup, etc.)
  * Examples:
    - Setup listener: execute_command with cmd="nc -lvnp 4444", platform="linux"
    - Port check: execute_command with cmd="Test-NetConnection -Port 443", platform="windows"
    - Download tool: execute_command with cmd="wget https://example.com/tool.sh", platform="linux"
  * Use for: Setting up listeners, preparing environment, running external tools
  * ALWAYS specify platform: "windows", "linux", or "macos"

Testing parameters:
- Primary Goal: {self.config.primary_goal.value}
- Secondary Goals: {', '.join(self.config.secondary_goals)}
- Stealth Level: {self.config.stealth_level.value}
- Risk Tolerance: {self.config.risk_tolerance.value}
- Time Limit: {self.config.time_limit} minutes

PENETRATION TESTING KILL CHAIN (Execute ALL phases systematically):

Phase 1 - RECONNAISSANCE (iterations 1-3):
   OBJECTIVES: Information gathering, attack surface mapping
   → recon: DNS enumeration, WHOIS, subdomain discovery
   → tech_detect: Technology stack, frameworks, versions
   → os_fingerprint: Operating system identification
   OUTPUT: Domain info, subdomains, technologies, OS type

Phase 2 - SCANNING & ENUMERATION (iterations 4-7):
   OBJECTIVES: Service discovery, endpoint enumeration
   → port_scan OR syn_scan: Open ports and services
   → udp_scan: UDP services (DNS, SNMP, etc.)
   → advanced_scan: Service version detection, banners
   → crawler: Web endpoints, API paths, hidden resources
   → dirbuster: Hidden directories, backup files, admin panels
   → ssl_analyze: SSL/TLS configuration and certificates
   OUTPUT: Open ports, services, web endpoints, directories

Phase 3 - VULNERABILITY ANALYSIS (iterations 8-12):
   OBJECTIVES: Identify security weaknesses, test attack vectors
   → web_pentest: OWASP Top 10 comprehensive testing:
      • A01 - Broken Access Control (IDOR, privilege escalation)
      • A02 - Cryptographic Failures (weak SSL/TLS, insecure storage)
      • A03 - Injection (SQLi: error-based, boolean, time-based, UNION)
      • A04 - Insecure Design (business logic flaws)
      • A05 - Security Misconfiguration (CORS, security headers)
      • A06 - Vulnerable Components (outdated software, CVEs)
      • A07 - Authentication Failures (weak credentials, JWT flaws)
      • A08 - Data Integrity Failures (insecure deserialization)
      • A09 - Logging Failures (insufficient monitoring)
      • A10 - SSRF (Server-Side Request Forgery)
      PLUS: XSS (reflected, stored, DOM), Command Injection, XXE, SSTI
   → api_test: Comprehensive API security:
      • REST API testing (Swagger/OpenAPI discovery)
      • GraphQL security (introspection, injection)
      • JWT vulnerabilities (weak signing, None algorithm)
      • IDOR in API endpoints
      • Rate limiting bypass
      • Authentication & authorization flaws
   → fuzzer: Parameter fuzzing for hidden vulnerabilities
   → takeover_scan: Subdomain takeover vulnerabilities
   → cloud_audit: AWS/Azure/GCP misconfiguration (S3 buckets, IAM)
   → k8s_audit: Kubernetes API exposure, RBAC issues
   → container_audit: Container registry security
   → nuclei: CVE scanning with 5000+ templates (if available)
   OUTPUT: Detailed vulnerabilities with PoC, severity, exploitability

Phase 4 - EXPLOITATION (iterations 13-16, REQUIRES HIGH RISK):
   OBJECTIVES: Gain initial access, validate vulnerabilities
   → exploit_vuln: Exploit discovered RCE, SQLi, file upload vulnerabilities
   → bruteforce: Credential attacks on discovered services
   → payload_generate: Generate reverse/bind shells, webshells
   OUTPUT: Shell access, authentication bypass, data extraction

Phase 5 - POST-EXPLOITATION (iterations 17+, REQUIRES HIGH RISK):
   OBJECTIVES: Privilege escalation, lateral movement, persistence
   → privilege_escalation: Identify elevation vectors
   → data_access: Locate sensitive data, databases, credentials
   → network_mapping: Internal network reconnaissance
   OUTPUT: Elevated access, sensitive data discovery, pivot opportunities

Phase 6 - REPORTING & DOCUMENTATION (final iteration):
   OBJECTIVES: Document findings, provide remediation guidance
   → Compile all findings with severity ratings
   → Generate exploitation proofs-of-concept
   → Provide remediation recommendations
   OUTPUT: Comprehensive report with technical details

TACTICAL DECISION LOGIC (AI must follow this):
- Iteration 1-3: ONLY reconnaissance tools (recon, tech_detect, os_fingerprint)
- Iteration 4-7: ONLY scanning tools (port_scan, crawler, dirbuster, ssl_analyze, advanced_scan)
- Iteration 8-12: ONLY vulnerability assessment (web_pentest, api_test, fuzzer, takeover_scan, cloud_audit)
- Iteration 13-16: ONLY exploitation (IF risk_tolerance=high: exploit_vuln, bruteforce, payload_generate)
- Iteration 17+: Post-exploitation (privilege_escalation, data_access, network_mapping)
- NEVER repeat the same tool twice unless new parameters/targets discovered
- ALWAYS analyze previous findings before choosing next tool
- Chain tools logically: recon → port_scan → crawler → web_pentest → exploit_vuln → payload_generate
6. POST-EXPLOITATION: Maintain access and pivot (if goal is SHELL_ACCESS)

INTELLIGENT DECISION-MAKING:
- Chain tools logically: port_scan → service detection → vulnerability testing → exploitation
- Prioritize by severity and exploitability (critical > high > medium > low)
- Focus on quick wins: default credentials, known CVEs, misconfigurations
- For SHELL_ACCESS goal: AGGRESSIVELY pursue RCE, command injection, file upload, credential attacks
- For WEB_EXPLOITATION: exhaustively test SQLi, XSS, SSRF, auth bypass, path traversal
- For VULN_DISCOVERY: run comprehensive scans (nuclei, web_pentest, fuzzer, bruteforce)
- For INFRASTRUCTURE: deep port scanning (1-10000), service enumeration, cloud/k8s audits
- Respect stealth_level: high=slow/careful/evasive, moderate=balanced, low=fast/aggressive
- Exploitation allowed when risk_tolerance >= MEDIUM for passive/active scanning
- Full exploitation (shell access, bruteforce) requires risk_tolerance=HIGH

SHELL GAINING STRATEGY (for gain_shell_access goal):
1. RECONNAISSANCE PHASE:
   - Port scan ALL common ports (1-10000) to find attack surface
   - OS fingerprinting to tailor exploits
   - Technology detection to identify software versions
   - Web crawling to find hidden endpoints and parameters

2. VULNERABILITY DISCOVERY:
   - Web pentest for RCE, command injection, file upload
   - Test default credentials (admin:admin, root:root, etc.)
   - Directory busting to find admin panels, config files
   - Fuzzing for injection points (SQLi, command injection, SSRF)
   - Nuclei scan for known CVEs
   - Check for exposed services (SSH, RDP, databases)

3. EXPLOITATION:
   - Bruteforce weak services (SSH, FTP, MySQL, PostgreSQL)
   - Exploit command injection with reverse shell payloads
   - Upload web shells through unrestricted file upload
   - SQL injection for command execution
   - Leverage default credentials to gain access

4. PAYLOAD GENERATION:
   - Generate OS-appropriate reverse shell (bash, powershell, python)
   - Provide listener setup instructions
   - Multiple payload variants (netcat, python, php, jsp)

5. POST-EXPLOITATION:
   - Enumerate user accounts and privileges
   - Search for sensitive files and credentials
   - Map internal network
   - Establish persistence mechanisms

Response format (JSON only):
{{
    "reasoning": "Explain your strategic decision-making and what you learned from previous findings",
    "next_action": "tool_name",
    "parameters": {{"key": "value"}},
    "risk_level": "low|medium|high|critical",
    "expected_outcome": "What you expect to find or achieve",
    "exploitation_chain": "If exploiting, explain the full attack chain",
    "success_indicators": "How to verify success",
    "stop_testing": false,
    "goal_progress": "Percentage estimate of goal completion (0-100)"
}}

Be strategic, thorough, and ethical. Always consider authorization and legal boundaries."""

    def _format_findings_for_ai(self) -> str:
        """Format current findings for AI context"""
        if not self.findings:
            return "No findings yet. Start with reconnaissance."
        
        summary = f"Current findings ({len(self.findings)} total):\n\n"
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if items:
                summary += f"{severity.upper()} ({len(items)}):\n"
                for finding in items[:3]:  # Show top 3 per severity
                    summary += f"- [{finding.tool}] {finding.description}\n"
                if len(items) > 3:
                    summary += f"  ... and {len(items) - 3} more\n"
                summary += "\n"
        
        return summary
    
    def _format_actions_for_ai(self) -> str:
        """Format previous actions for AI context"""
        if not self.actions:
            return "No actions taken yet."
        
        summary = f"Previous actions ({len(self.actions)}):\n"
        for action in self.actions[-5:]:  # Show last 5 actions
            summary += f"- {action.action_type} using {action.tool}: {action.reasoning}\n"
        
        return summary
    
    async def _get_next_action(self) -> Dict[str, Any]:
        """Ask AI to determine next action"""
        system_prompt = self._get_system_prompt()
        
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        remaining_time = self.config.time_limit - elapsed
        
        user_prompt = f"""Current state of penetration test:

Target: {self.config.target}
Elapsed time: {elapsed:.1f} minutes
Remaining time: {remaining_time:.1f} minutes
Iteration: {self.iteration + 1}/{self.config.max_iterations}

{self._format_findings_for_ai()}

{self._format_actions_for_ai()}

Based on the current findings and the primary goal ({self.config.primary_goal.value}), what should be the next action?

Respond with a JSON object only (no additional text)."""

        response = await self.ai_provider.query(system_prompt, user_prompt, temperature=0.7)
        
        # Extract JSON from response (handle markdown code blocks and empty responses)
        response = response.strip()
        if not response:
            # Empty response - default to reconnaissance
            return {
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "reasoning": "Starting with basic reconnaissance"
            }
        
        if response.startswith("```"):
            lines = response.split("\n")
            response = "\n".join(lines[1:-1])
        
        try:
            return json.loads(response)
        except json.JSONDecodeError:
            # If JSON parsing fails, extract JSON-like content
            import re
            json_match = re.search(r'\{[\s\S]*\}', response)
            if json_match:
                return json.loads(json_match.group())
            # Fallback to recon
            return {
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "reasoning": "AI response parsing failed, defaulting to reconnaissance"
            }
    
    async def _execute_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the action determined by AI"""
        tool = action["next_action"]
        params = action.get("parameters", {})
        
        # Record the action
        agent_action = AgentAction(
            timestamp=datetime.now().isoformat(),
            action_type="execute",
            tool=tool,
            parameters=params,
            reasoning=action["reasoning"],
            risk_level=action.get("risk_level", "medium")
        )
        self.actions.append(agent_action)
        
        try:
            if tool == "port_scan":
                result = await self._run_port_scan(params)
            elif tool == "syn_scan":
                result = await self._run_syn_scan(params)
            elif tool == "udp_scan":
                result = await self._run_udp_scan(params)
            elif tool == "advanced_scan":
                result = await self._run_advanced_scan(params)
            elif tool == "dirbuster":
                result = await self._run_dirbuster(params)
            elif tool == "crawler":
                result = await self._run_crawler(params)
            elif tool == "fuzzer":
                result = await self._run_fuzzer(params)
            elif tool == "bruteforce":
                result = await self._run_bruteforce(params)
            elif tool == "nuclei":
                result = await self._run_nuclei(params)
            elif tool == "cloud_audit":
                result = await self._run_cloud_audit(params)
            elif tool == "k8s_audit":
                result = await self._run_k8s_audit(params)
            elif tool == "container_audit":
                result = await self._run_container_audit(params)
            elif tool == "exploit_vuln":
                result = await self._run_exploit(params)
            elif tool == "ssl_analyze":
                result = await self._run_ssl_analyze(params)
            elif tool == "os_fingerprint":
                result = await self._run_os_fingerprint(params)
            elif tool == "web_pentest":
                result = await self._run_web_pentest(params)
            elif tool == "api_test":
                result = await self._run_api_test(params)
            elif tool == "takeover_scan":
                result = await self._run_takeover_scan(params)
            elif tool == "tech_detect":
                result = await self._run_tech_detect(params)
            elif tool == "recon":
                result = await self._run_recon(params)
            elif tool == "payload_generate":
                result = await self._run_payload_generate(params)
            elif tool == "execute_command":
                result = await self._run_execute_command(params)
            else:
                result = {"error": f"Unknown tool: {tool}"}
            
            return result
        except Exception as e:
            return {"error": str(e)}
    
    async def _run_port_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute port scan"""
        ports = params.get("ports", list(range(1, 1001)))
        concurrency = params.get("concurrency", 100 if self.config.stealth_level == StealthLevel.LOW else 20)
        
        result_list = await async_port_scan(
            self.config.target,
            ports=ports,
            concurrency=concurrency
        )
        
        # Convert to findings
        open_ports = [r for r in result_list if r.get("state") == "open"]
        if open_ports:
            for port_info in open_ports:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="port_scan",
                    severity="info",
                    category="reconnaissance",
                    description=f"Open port {port_info['port']} - {port_info.get('service', 'unknown')}",
                    details=port_info,
                    exploitation_potential="low",
                    recommended_action="Further enumerate service"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": open_ports}
    
    async def _run_syn_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SYN scan"""
        ports = params.get("ports", list(range(1, 1001)))
        
        try:
            result_list = await async_syn_scan(
                self.config.target,
                ports=ports
            )
            
            open_ports = [r for r in result_list if r.get("state") == "open"]
            if open_ports:
                for port_info in open_ports:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="syn_scan",
                        severity="info",
                        category="reconnaissance",
                        description=f"Open port {port_info.get('port')} (SYN scan)",
                        details=port_info,
                        exploitation_potential="low",
                        recommended_action="Version detection"
                    )
                    self.findings.append(finding)
            
            return {"open_ports": len(open_ports), "details": open_ports}
        except Exception as e:
            return {"error": f"SYN scan requires admin/root privileges: {e}"}
    
    async def _run_ssl_analyze(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze SSL/TLS"""
        port = params.get("port", 443)
        
        result = await analyze_ssl(self.config.target, port=port)
        
        # Check for vulnerabilities
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                severity = "high" if "critical" in vuln.lower() else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="ssl_analyze",
                    severity=severity,
                    category="ssl_tls",
                    description=vuln,
                    details=result,
                    exploitation_potential="medium",
                    recommended_action="Update SSL/TLS configuration"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_os_fingerprint(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run OS fingerprinting"""
        fingerprinter = OSFingerprinter()
        # Use comprehensive fingerprint with common ports
        open_ports = params.get("ports", [80, 443, 22, 21, 25])
        result = await fingerprinter.comprehensive_fingerprint(self.config.target, open_ports)
        
        if result.get("os_match"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="os_fingerprint",
                severity="info",
                category="reconnaissance",
                description=f"OS detected: {result['os_match']} (confidence: {result.get('confidence', 0)}%)",
                details=result,
                exploitation_potential="low",
                recommended_action="Tailor exploits to OS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_web_pentest(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web application penetration test"""
        target_url = params.get("url", f"https://{self.config.target}")
        
        tester = AdvancedWebTester(
            target=target_url,
            concurrency=10 if self.config.stealth_level == StealthLevel.HIGH else 50,
            timeout=15.0
        )
        
        vulnerabilities = await tester.run_full_scan()
        
        for vuln in vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="web_pentest",
                severity=vuln.severity.lower(),
                category="web_application",
                description=f"{vuln.vuln_type}: {vuln.description}",
                details=asdict(vuln),
                exploitation_potential=vuln.severity.lower(),
                recommended_action=vuln.remediation
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": [asdict(v) for v in vulnerabilities]}
    
    async def _run_api_test(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Test API security"""
        result = await api_probe(self.config.target)
        
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="api_test",
                    severity=vuln.get("severity", "medium"),
                    category="api_security",
                    description=vuln.get("description", "API vulnerability"),
                    details=vuln,
                    exploitation_potential="medium",
                    recommended_action="Review API security controls"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_takeover_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Check for subdomain takeover"""
        result = await takeover_scan(self.config.target)
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="takeover_scan",
                severity="high",
                category="dns_misconfiguration",
                description="Subdomain takeover vulnerability detected",
                details=result,
                exploitation_potential="high",
                recommended_action="Remove dangling DNS records"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_tech_detect(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Detect technologies"""
        result = await detect_tech(self.config.target)
        
        if result.get("technologies"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="tech_detect",
                severity="info",
                category="reconnaissance",
                description=f"Technologies: {', '.join(result['technologies'][:5])}",
                details=result,
                exploitation_potential="low",
                recommended_action="Research known vulnerabilities for detected technologies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_recon(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run reconnaissance"""
        result = await recon(self.config.target)
        
        if result.get("subdomains"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="recon",
                severity="info",
                category="reconnaissance",
                description=f"Found {len(result['subdomains'])} subdomains",
                details=result,
                exploitation_potential="low",
                recommended_action="Scan discovered subdomains"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_execute_command(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute system command on attacker machine (cross-platform)"""
        import subprocess
        import platform as plat
        
        cmd = params.get("cmd")
        target_platform = params.get("platform", plat.system().lower())
        timeout = params.get("timeout", 30)
        background = params.get("background", False)
        
        if not cmd:
            return {"error": "No command specified"}
        
        # Detect current platform
        current_platform = plat.system().lower()
        
        # Platform validation
        if target_platform == "windows" and current_platform != "windows":
            return {"error": f"Cannot execute Windows command on {current_platform}"}
        elif target_platform in ["linux", "macos", "darwin"] and current_platform == "windows":
            return {"error": f"Cannot execute Unix command on {current_platform}"}
        
        # Prepare command based on platform
        if current_platform == "windows":
            # Execute via PowerShell
            full_cmd = ["powershell", "-NoProfile", "-Command", cmd]
        else:
            # Execute via bash
            full_cmd = ["bash", "-c", cmd]
        
        try:
            if background:
                # Start background process
                process = subprocess.Popen(
                    full_cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                result_data = {
                    "status": "started",
                    "pid": process.pid,
                    "command": cmd,
                    "platform": current_platform,
                    "message": f"Background process started (PID: {process.pid})"
                }
            else:
                # Execute and wait for completion
                result = subprocess.run(
                    full_cmd,
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
                
                result_data = {
                    "status": "completed",
                    "exit_code": result.returncode,
                    "stdout": result.stdout.strip(),
                    "stderr": result.stderr.strip(),
                    "command": cmd,
                    "platform": current_platform
                }
            
            # Log as finding
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="execute_command",
                severity="info",
                category="command_execution",
                description=f"Executed command on {current_platform}: {cmd[:100]}",
                details=result_data,
                exploitation_potential="low",
                recommended_action="Review command output"
            )
            self.findings.append(finding)
            
            return result_data
            
        except subprocess.TimeoutExpired:
            return {
                "error": f"Command timed out after {timeout} seconds",
                "command": cmd,
                "platform": current_platform
            }
        except Exception as e:
            return {
                "error": f"Command execution failed: {str(e)}",
                "command": cmd,
                "platform": current_platform
            }
    
    async def _run_payload_generate(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Generate exploitation payload tailored to detected OS"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Payload generation requires HIGH risk tolerance"}
        
        generator = PayloadGenerator()
        
        lhost = params.get("lhost", "attacker-ip")
        lport = params.get("lport", 4444)
        shell_type = params.get("shell", None)
        
        # Auto-detect OS from previous findings if shell type not specified
        if not shell_type:
            detected_os = self._detect_target_os()
            
            # Map OS to appropriate shell type
            if "windows" in detected_os.lower():
                shell_type = "powershell"
            elif "linux" in detected_os.lower() or "unix" in detected_os.lower():
                shell_type = "bash"
            else:
                # Default based on common ports detected
                open_ports = self._get_detected_ports()
                if 3389 in open_ports or 445 in open_ports or 135 in open_ports:
                    shell_type = "powershell"  # Windows indicators
                elif 22 in open_ports:
                    shell_type = "bash"  # Linux/Unix indicators
                else:
                    shell_type = "python"  # Cross-platform fallback
        
        payload = generator.generate_reverse_shell(lhost, lport, shell_type)
        
        finding = Finding(
            timestamp=datetime.now().isoformat(),
            tool="payload_generate",
            severity="critical",
            category="exploitation",
            description=f"Generated {shell_type} reverse shell for {payload.platform} (OS: {self._detect_target_os()})",
            details={
                "payload": payload.code,
                "lhost": lhost,
                "lport": lport,
                "platform": payload.platform,
                "shell_type": shell_type,
                "detected_os": self._detect_target_os()
            },
            exploitation_potential="critical",
            recommended_action="Use only with explicit authorization"
        )
        self.findings.append(finding)
        
        return {
            "payload": payload.code,
            "usage": payload.usage,
            "platform": payload.platform,
            "shell_type": shell_type,
            "detected_os": self._detect_target_os()
        }
    
    async def _run_udp_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run UDP port scan"""
        ports = params.get("ports", [53, 67, 68, 69, 123, 135, 137, 138, 161, 500])
        result = await async_udp_scan(self.config.target, ports, concurrency=50, timeout=2.0)
        
        open_ports = [r for r in result if r.get("state") == "open"]
        if open_ports:
            for port_info in open_ports:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="udp_scan",
                    severity="medium",
                    category="network",
                    description=f"Open UDP port {port_info['port']}: {port_info.get('service', 'unknown')}",
                    details=port_info,
                    exploitation_potential="medium",
                    recommended_action="Enumerate UDP services for vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result}
    
    async def _run_advanced_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run advanced scan with service detection"""
        ports = params.get("ports", list(range(1, 1001)))
        scan_type = params.get("scan_type", "syn")  # syn, fin, xmas, null, ack
        result_list = await async_advanced_scan(
            self.config.target,
            ports,
            scan_type=scan_type,
            concurrency=100,
            timeout=2.0
        )
        
        # Process scan results
        open_ports = [r for r in result_list if r.get("state") in ["open", "filtered"]]
        if open_ports:
            for svc in open_ports:
                severity = "high" if any(k in str(svc).lower() for k in ["exploit", "vulnerable"]) else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="advanced_scan",
                    severity=severity,
                    category="service_detection",
                    description=f"Service detected: {svc.get('service', 'unknown')} on port {svc.get('port')}",
                    details=svc,
                    exploitation_potential=severity,
                    recommended_action="Test service for known vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result_list}
    
    async def _run_dirbuster(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run directory busting"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await dirbust_scan(target_url, concurrency=50, https=True)
        
        if result.get("found"):
            for item in result["found"][:20]:  # Top 20 findings
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="dirbuster",
                    severity="info",
                    category="web_enumeration",
                    description=f"Discovered: {item['path']} (Status: {item['status']})",
                    details=item,
                    exploitation_potential="low",
                    recommended_action="Analyze discovered endpoints for sensitive data"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_crawler(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web crawler"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await crawl(target_url, max_pages=50)
        
        if result.get("secrets"):
            for secret in result["secrets"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="crawler",
                    severity="high",
                    category="information_disclosure",
                    description=f"Secret found: {secret.get('type')} in {secret.get('location')}",
                    details=secret,
                    exploitation_potential="high",
                    recommended_action="Secure exposed credentials immediately"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_fuzzer(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web fuzzer"""
        if self.config.risk_tolerance == RiskTolerance.LOW:
            return {"error": "Fuzzing requires MEDIUM or HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        wordlist = params.get("wordlist", ["'", '"', "<", ">", "../", "..\\", "{{7*7}}", "${7*7}"])
        fuzzer = AdvancedFuzzer(target_url, wordlist=wordlist, timeout=10.0)
        
        # Fuzz a common parameter
        param_name = params.get("param", "id")
        vulnerabilities = await fuzzer.fuzz_parameters(param_name)
        
        for vuln in vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="fuzzer",
                severity="high",
                category="web_vulnerability",
                description=f"Fuzzing vulnerability in {vuln.url}",
                details={
                    "url": vuln.url,
                    "status": vuln.status_code,
                    "length": vuln.content_length,
                    "payload": vuln.payload
                },
                exploitation_potential="high",
                recommended_action="Validate and sanitize all user inputs"
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": vulnerabilities}
    
    async def _run_bruteforce(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run authentication bruteforce"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Bruteforce requires HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        auth_type = params.get("auth_type", "basic")  # basic, form, json
        username = params.get("username", "admin")
        
        # Use common credentials only
        passwords = ["admin", "password", "123456", "root", "admin123"]
        
        bruteforcer = AuthBruteForcer(target_url, concurrency=5)
        
        # Test based on auth type
        try:
            if auth_type == "basic":
                results = await bruteforcer.brute_force_basic_auth([username], passwords)
            elif auth_type == "form":
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_form([username], passwords, username_field=username_field, password_field=password_field)
            else:  # json
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_json_api([username], passwords, username_field=username_field, password_field=password_field)
            
            # Check for successful authentication
            successful = [r for r in results if r.success]
            if successful:
                for success_result in successful:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="bruteforce",
                        severity="critical",
                        category="authentication",
                        description=f"Weak credentials: {success_result.username}:{success_result.password}",
                        details={"username": success_result.username, "password": success_result.password},
                        exploitation_potential="critical",
                        recommended_action="Enforce strong password policy and account lockout"
                    )
                    self.findings.append(finding)
            
            return {"total_attempts": len(results), "successful": len(successful)}
        except Exception as e:
            return {"error": str(e)}
        
        if results.get("success"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="bruteforce",
                severity="critical",
                category="authentication",
                description=f"Weak credentials: {username}:{results['password']}",
                details=results,
                exploitation_potential="critical",
                recommended_action="Enforce strong password policy and account lockout"
            )
            self.findings.append(finding)
        
        return results
    
    async def _run_nuclei(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run Nuclei vulnerability scanner"""
        try:
            scanner = NucleiScanner()
            # Nuclei scan is sync, run in thread
            findings = await asyncio.to_thread(
                scanner.scan,
                self.config.target,
                tags=params.get("tags", ["cve", "vulnerability"]),
                severity=["critical", "high"]
            )
            result = {"findings": findings}
            
            if result.get("findings"):
                for vuln in result["findings"]:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="nuclei",
                        severity=vuln.get("severity", "medium"),
                        category="vulnerability",
                        description=f"Nuclei: {vuln.get('name')}",
                        details=vuln,
                        exploitation_potential=vuln.get("severity", "medium"),
                        recommended_action="Apply security patches"
                    )
                    self.findings.append(finding)
            
            return result
        except Exception as e:
            return {"error": f"Nuclei not available: {str(e)}"}
    
    async def _run_cloud_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit cloud storage"""
        bucket_name = params.get("bucket", self.config.target.replace(".", "-"))
        result = await cloud_audit(bucket_name, providers=["aws", "azure", "gcp"])
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="cloud_audit",
                severity="critical",
                category="cloud_misconfiguration",
                description=f"Public cloud storage: {result.get('provider')}",
                details=result,
                exploitation_potential="critical",
                recommended_action="Restrict bucket access with proper IAM policies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_k8s_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit Kubernetes API"""
        api_base = params.get("api_base", f"https://{self.config.target}:6443")
        result = await k8s_audit(api_base, verify_cert=False)
        
        if result.get("exposed_endpoints"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="k8s_audit",
                severity="critical",
                category="kubernetes",
                description="Unauthenticated Kubernetes API access",
                details=result,
                exploitation_potential="critical",
                recommended_action="Enable RBAC and authentication"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_container_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit container registry"""
        registry = params.get("registry", f"{self.config.target}:5000")
        result = await container_audit(registry)
        
        if result.get("anonymous_access"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="container_audit",
                severity="high",
                category="container_security",
                description="Anonymous container registry access",
                details=result,
                exploitation_potential="high",
                recommended_action="Enable authentication and TLS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_exploit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt exploitation based on discovered vulnerabilities"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Exploitation requires HIGH risk tolerance and explicit authorization"}
        
        # Find exploitable vulnerabilities
        exploitable = [f for f in self.findings if f.exploitation_potential in ["critical", "high"]]
        
        if not exploitable:
            return {"message": "No exploitable vulnerabilities found yet"}
        
        # Prioritize RCE, command injection, file upload
        rce_vulns = [f for f in exploitable if any(
            keyword in f.description.lower() 
            for keyword in ["rce", "command injection", "file upload", "sql injection"]
        )]
        
        if rce_vulns:
            target_vuln = rce_vulns[0]
            
            # Generate appropriate payload
            generator = PayloadGenerator()
            lhost = params.get("lhost", "ATTACKER-IP-REQUIRED")
            lport = params.get("lport", 4444)
            
            # Determine OS from fingerprinting
            os_findings = [f for f in self.findings if f.tool == "os_fingerprint"]
            os_type = "linux"
            if os_findings:
                os_match = os_findings[0].details.get("os_match", "").lower()
                if "windows" in os_match:
                    os_type = "windows"
            
            shell_type = "powershell" if os_type == "windows" else "bash"
            payload = generator.generate_reverse_shell(lhost, lport, shell_type)
            
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="exploit_vuln",
                severity="critical",
                category="exploitation",
                description=f"Exploitation payload for {target_vuln.description}",
                details={
                    "target_vulnerability": target_vuln.description,
                    "payload": payload.code,
                    "usage": payload.usage,
                    "lhost": lhost,
                    "lport": lport,
                    "shell_type": shell_type,
                    "listener_command": f"nc -lvnp {lport}" if os_type == "linux" else f"ncat.exe -lvnp {lport}"
                },
                exploitation_potential="critical",
                recommended_action="Set up listener before executing payload"
            )
            self.findings.append(finding)
            
            return {
                "exploitation_ready": True,
                "target_vulnerability": target_vuln.description,
                "payload": payload.code,
                "shell_type": shell_type,
                "listener_setup": f"nc -lvnp {lport}" if os_type == "linux" else f"ncat.exe -lvnp {lport}",
                "warning": "⚠️ ONLY USE WITH EXPLICIT WRITTEN AUTHORIZATION"
            }
        
        return {"message": "Analyzing exploitation paths..."}
    
    def _detect_target_os(self) -> str:
        """Detect target OS from previous findings"""
        # Check OS fingerprint findings
        os_findings = [f for f in self.findings if f.tool == "os_fingerprint"]
        if os_findings:
            os_match = os_findings[0].details.get("os_match", "unknown")
            return os_match
        
        # Check port scan findings for OS indicators
        open_ports = self._get_detected_ports()
        
        # Windows indicators
        if any(port in open_ports for port in [3389, 445, 135, 139, 5985, 5986]):
            return "Windows"
        
        # Linux/Unix indicators
        if 22 in open_ports:
            return "Linux/Unix"
        
        # Web server (multi-platform)
        if 80 in open_ports or 443 in open_ports:
            # Check for technology stack
            tech_findings = [f for f in self.findings if f.tool == "tech_detect"]
            if tech_findings:
                tech = tech_findings[0].details.get("server", "").lower()
                if "iis" in tech or "microsoft" in tech:
                    return "Windows"
                elif "apache" in tech or "nginx" in tech:
                    return "Linux/Unix"
        
        return "Unknown"
    
    def _get_detected_ports(self) -> List[int]:
        """Extract detected open ports from findings"""
        open_ports = []
        
        # Check port scan findings
        port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan", "advanced_scan"]]
        for finding in port_findings:
            if "port" in finding.details:
                open_ports.append(finding.details["port"])
            elif "open_ports" in finding.details:
                # Handle list of ports
                ports = finding.details.get("open_ports", [])
                if isinstance(ports, list):
                    open_ports.extend([p.get("port") if isinstance(p, dict) else p for p in ports])
        
        return list(set(open_ports))
    
    def _check_authorization(self, action: Dict[str, Any]) -> bool:
        """Check if action requires authorization"""
        high_risk_tools = ["payload_generate", "bruteforce", "exploit_vuln", "web_pentest", "fuzzer"]
        tool = action["next_action"]
        risk_level = action.get("risk_level", "medium")
        
        if tool in high_risk_tools or risk_level == "high":
            if self.config.autonomy_level == AutonomyLevel.FULLY_AUTONOMOUS:
                return True
            elif self.config.autonomy_level == AutonomyLevel.SEMI_AUTONOMOUS:
                # Would prompt user in real implementation
                return True
            else:  # SUPERVISED
                # Would always prompt in real implementation
                return True
        
        return True
    
    def _should_stop(self, ai_decision: Dict[str, Any]) -> bool:
        """Determine if testing should stop"""
        # Time limit check
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        if elapsed >= self.config.time_limit:
            return True
        
        # Max iterations check
        if self.iteration >= self.config.max_iterations:
            return True
        
        # AI decision
        if ai_decision.get("stop_testing", False):
            return True
        
        # Goal achievement check (simplified)
        if self.config.primary_goal == PrimaryGoal.COMPREHENSIVE:
            tools_used = set(action.tool for action in self.actions)
            required_tools = {"recon", "port_scan", "web_pentest", "ssl_analyze"}
            if required_tools.issubset(tools_used):
                return True
        
        return False
    
    async def execute(self) -> Dict[str, Any]:
        """Execute the AI-powered penetration test"""
        print(f"\n🤖 AI Penetration Test Agent Starting...")
        print(f"Target: {self.config.target}")
        print(f"Goal: {self.config.primary_goal.value}")
        print(f"AI Provider: {self.config.ai_provider} ({self.config.model})")
        print(f"Time Limit: {self.config.time_limit} minutes")
        print(f"Autonomy: {self.config.autonomy_level.value}")
        print(f"Risk Tolerance: {self.config.risk_tolerance.value}\n")
        
        try:
            while self.iteration < self.config.max_iterations:
                self.iteration += 1
                print(f"🔍 Iteration {self.iteration}/{self.config.max_iterations}")
                
                # Get AI decision
                print("  🧠 Consulting AI for next action...")
                ai_decision = await self._get_next_action()
                
                print(f"  💭 AI Reasoning: {ai_decision['reasoning']}")
                print(f"  🎯 Next Action: {ai_decision['next_action']}")
                print(f"  ⚠️  Risk Level: {ai_decision.get('risk_level', 'medium')}")
                
                # Check if we should stop
                if self._should_stop(ai_decision):
                    print("\n✅ Testing complete (stopping condition met)")
                    break
                
                # Check authorization for high-risk actions
                if not self._check_authorization(ai_decision):
                    print("  ⛔ Action denied (requires authorization)")
                    continue
                
                # Execute the action
                print(f"  ⚡ Executing: {ai_decision['next_action']}...")
                result = await self._execute_action(ai_decision)
                
                if "error" in result:
                    print(f"  ❌ Error: {result['error']}")
                else:
                    print(f"  ✅ Completed successfully")
                
                # Brief pause between iterations
                await asyncio.sleep(2)
                print()
            
            # Display detailed findings before saving
            print("\n" + "="*70)
            print("📊 DETAILED FINDINGS REVIEW")
            print("="*70)
            self._display_detailed_findings()
            
            # Generate final report
            report = self._generate_report()
            
            return report
            
        finally:
            await self.ai_provider.close()
    
    def _generate_report(self) -> Dict[str, Any]:
        """Generate final report"""
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        
        # Group findings by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        report = {
            "summary": {
                "target": self.config.target,
                "primary_goal": self.config.primary_goal.value,
                "start_time": self.start_time.isoformat(),
                "end_time": datetime.now().isoformat(),
                "duration_minutes": round(elapsed, 2),
                "iterations": self.iteration,
                "total_findings": len(self.findings),
                "total_actions": len(self.actions),
                "ai_provider": self.config.ai_provider,
                "ai_model": self.config.model
            },
            "findings_by_severity": {
                "critical": len(by_severity["critical"]),
                "high": len(by_severity["high"]),
                "medium": len(by_severity["medium"]),
                "low": len(by_severity["low"]),
                "info": len(by_severity["info"])
            },
            "detailed_findings": [asdict(f) for f in self.findings],
            "actions_taken": [asdict(a) for a in self.actions],
            "recommendations": self._generate_recommendations()
        }
        
        return report
    
    def _display_detailed_findings(self):
        """Display all findings in detail before saving"""
        if not self.findings:
            print("\n✅ No vulnerabilities or issues discovered.")
            return
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        print(f"\n🔍 Total Findings: {len(self.findings)}\n")
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if not items:
                continue
            
            # Color code by severity
            severity_colors = {
                "critical": "🔴 CRITICAL",
                "high": "🟠 HIGH",
                "medium": "🟡 MEDIUM",
                "low": "🔵 LOW",
                "info": "⚪ INFO"
            }
            
            print(f"\n{severity_colors[severity]} ({len(items)} findings):")
            print("-" * 70)
            
            for i, finding in enumerate(items, 1):
                print(f"\n{i}. [{finding.tool.upper()}] {finding.category}")
                print(f"   Description: {finding.description}")
                if finding.details:
                    print(f"   Details: {finding.details}")
                if finding.exploitation_potential:
                    print(f"   💥 Exploitation: {finding.exploitation_potential}")
                if finding.recommended_action:
                    print(f"   ✅ Remediation: {finding.recommended_action}")
        
        print("\n" + "="*70)
    
    def _generate_recommendations(self) -> List[str]:
        """Generate high-level recommendations"""
        recommendations = []
        
        # Count by severity
        critical = sum(1 for f in self.findings if f.severity == "critical")
        high = sum(1 for f in self.findings if f.severity == "high")
        
        if critical > 0:
            recommendations.append(f"🚨 URGENT: Address {critical} critical vulnerabilities immediately")
        
        if high > 0:
            recommendations.append(f"⚠️  HIGH PRIORITY: Fix {high} high-severity issues")
        
        # Category-specific recommendations
        categories = set(f.category for f in self.findings)
        
        if "web_application" in categories:
            recommendations.append("🌐 Review web application security controls (input validation, authentication)")
        
        if "ssl_tls" in categories:
            recommendations.append("🔒 Update SSL/TLS configuration (remove weak ciphers, enable modern protocols)")
        
        if "dns_misconfiguration" in categories:
            recommendations.append("📡 Review DNS configuration for misconfigurations and takeover risks")
        
        if not recommendations:
            recommendations.append("✅ No critical issues found. Continue regular security assessments.")
        
        return recommendations
