"""
AI-Powered Autonomous Penetration Testing Agent
Uses LLM API (OpenAI/Anthropic/etc.) for intelligent decision-making
Orchestrates existing Scorpion tools based on findings and goals
"""
import asyncio
import json
import os
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import httpx
from enum import Enum

from .scanner import async_port_scan, async_syn_scan, async_udp_scan, async_advanced_scan
from .ssl_analyzer import analyze_ssl
from .takeover import takeover_scan
from .api import api_probe
from .recon import recon
from .tech import detect_tech
from .web_pentest import AdvancedWebTester
from .os_fingerprint import OSFingerprinter
from .payload_generator import PayloadGenerator
from .bruteforce import AuthBruteForcer
from .fuzzer import AdvancedFuzzer
from .dirbuster import dirbust_scan
from .crawler import crawl
from .nuclei_wrapper import NucleiScanner
from .cloud import cloud_audit
from .k8s import k8s_audit
from .container_sec import container_audit


class PrimaryGoal(str, Enum):
    COMPREHENSIVE = "comprehensive_assessment"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_ACCESS = "data_access"
    NETWORK_MAPPING = "network_mapping"
    WEB_EXPLOITATION = "web_exploitation"
    SHELL_ACCESS = "gain_shell_access"
    VULN_DISCOVERY = "vulnerability_discovery"
    INFRASTRUCTURE = "infrastructure_assessment"
    CLOUD_SECURITY = "cloud_security_audit"
    API_SECURITY = "api_security_testing"


class AutonomyLevel(str, Enum):
    SUPERVISED = "supervised"  # Asks for confirmation before each action
    SEMI_AUTONOMOUS = "semi_autonomous"  # Asks before high-risk actions
    FULLY_AUTONOMOUS = "fully_autonomous"  # Executes without confirmation (DANGEROUS)


class StealthLevel(str, Enum):
    LOW = "low"  # Fast, noisy scans
    MODERATE = "moderate"  # Balanced approach
    HIGH = "high"  # Slow, stealthy scans


class RiskTolerance(str, Enum):
    LOW = "low"  # Only passive/safe actions
    MEDIUM = "medium"  # Active scanning, no exploitation
    HIGH = "high"  # Full exploitation (requires authorization)


@dataclass
class AIPentestConfig:
    """Configuration for AI penetration test"""
    target: str
    primary_goal: PrimaryGoal
    secondary_goals: List[str]
    time_limit: int  # minutes
    stealth_level: StealthLevel
    autonomy_level: AutonomyLevel
    risk_tolerance: RiskTolerance
    ai_provider: str  # openai, anthropic, custom
    api_key: str
    api_endpoint: Optional[str] = None
    model: str = "gpt-4"
    learning_mode: bool = False
    max_iterations: int = 10


@dataclass
class Finding:
    """Represents a security finding"""
    timestamp: str
    tool: str
    severity: str
    category: str
    description: str
    details: Dict[str, Any]
    exploitation_potential: str
    recommended_action: str


@dataclass
class AgentAction:
    """Represents an action taken by the AI agent"""
    timestamp: str
    action_type: str
    tool: str
    parameters: Dict[str, Any]
    reasoning: str
    risk_level: str


class AIProvider:
    """Handles communication with AI providers (OpenAI, Anthropic, etc.)"""
    
    def __init__(self, provider: str, api_key: str, model: str, endpoint: Optional[str] = None):
        self.provider = provider.lower()
        self.api_key = api_key
        self.model = model
        self.endpoint = endpoint
        self.client = httpx.AsyncClient(timeout=60.0)
        
    async def query(self, system_prompt: str, user_prompt: str, temperature: float = 0.7) -> str:
        """Query the AI provider"""
        try:
            if self.provider == "openai":
                return await self._query_openai(system_prompt, user_prompt, temperature)
            elif self.provider == "anthropic":
                return await self._query_anthropic(system_prompt, user_prompt, temperature)
            elif self.provider == "custom":
                return await self._query_custom(system_prompt, user_prompt, temperature)
            else:
                raise ValueError(f"Unsupported AI provider: {self.provider}")
        except Exception as e:
            raise Exception(f"AI provider error: {e}")
    
    async def _query_openai(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query OpenAI API"""
        url = self.endpoint or "https://api.openai.com/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["choices"][0]["message"]["content"]
    
    async def _query_anthropic(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query Anthropic Claude API"""
        url = self.endpoint or "https://api.anthropic.com/v1/messages"
        headers = {
            "x-api-key": self.api_key,
            "anthropic-version": "2023-06-01",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "max_tokens": 2000,
            "temperature": temperature,
            "system": system_prompt,
            "messages": [
                {"role": "user", "content": user_prompt}
            ]
        }
        
        response = await self.client.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        return result["content"][0]["text"]
    
    async def _query_custom(self, system_prompt: str, user_prompt: str, temperature: float) -> str:
        """Query custom OpenAI-compatible endpoint"""
        if not self.endpoint:
            raise ValueError("Custom provider requires endpoint URL")
        
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        data = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }
        
        response = await self.client.post(self.endpoint, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        
        # Handle different response formats
        if "choices" in result:
            return result["choices"][0]["message"]["content"]
        elif "content" in result:
            return result["content"][0]["text"]
        else:
            raise ValueError("Unexpected API response format")
    
    async def close(self):
        """Close the HTTP client"""
        await self.client.aclose()


class AIPentestAgent:
    """Autonomous AI-powered penetration testing agent"""
    
    def __init__(self, config: AIPentestConfig):
        self.config = config
        self.findings: List[Finding] = []
        self.actions: List[AgentAction] = []
        self.ai_provider = AIProvider(
            config.ai_provider,
            config.api_key,
            config.model,
            config.api_endpoint
        )
        self.start_time = datetime.now()
        self.iteration = 0
        self.knowledge_base: Dict[str, Any] = {}
        
    def _get_system_prompt(self) -> str:
        """Get the system prompt for the AI"""
        return f"""You are an expert penetration testing AI assistant integrated into Scorpion CLI.

Your role: Analyze security findings and determine the next best action to achieve the testing goal.
You are capable of full-spectrum security testing from reconnaissance to exploitation.

Available tools and their purposes:

RECONNAISSANCE:
- recon: DNS enumeration, WHOIS, subdomain discovery
- tech_detect: Identify technologies, frameworks, versions
- os_fingerprint: Identify operating system and version
- crawler: Discover hidden endpoints, secrets, API paths
- dirbuster: Directory and file enumeration

SCANNING:
- port_scan: Discover open TCP ports and services
- udp_scan: UDP service discovery
- syn_scan: Stealthy SYN scan (requires admin/root)
- advanced_scan: Service version detection and OS fingerprinting
- ssl_analyze: SSL/TLS configuration and vulnerabilities

VULNERABILITY ASSESSMENT:
- web_pentest: Test for web vulnerabilities (SQLi, XSS, SSRF, RCE, LFI, etc.)
- api_test: API security testing and authentication bypass
- fuzzer: Parameter fuzzing to discover hidden vulnerabilities
- nuclei: Run Nuclei vulnerability scanner (if available)
- takeover_scan: Subdomain takeover vulnerability detection
- cloud_audit: Test cloud storage misconfigurations (S3, Azure, GCS)
- k8s_audit: Kubernetes security audit
- container_audit: Container registry security assessment

EXPLOITATION (HIGH RISK):
- bruteforce: Credential brute-forcing (Basic Auth, forms, APIs)
- payload_generate: Generate reverse/bind shells, web shells
- exploit_vuln: Exploit discovered vulnerabilities to gain shell access

Testing parameters:
- Primary Goal: {self.config.primary_goal.value}
- Secondary Goals: {', '.join(self.config.secondary_goals)}
- Stealth Level: {self.config.stealth_level.value}
- Risk Tolerance: {self.config.risk_tolerance.value}
- Time Limit: {self.config.time_limit} minutes

ATTACK METHODOLOGY:
1. RECONNAISSANCE: Start with passive recon (recon, tech_detect, os_fingerprint)
2. SCANNING: Perform comprehensive port/service discovery (port_scan, syn_scan, udp_scan)
3. ENUMERATION: Discover attack surface (crawler, dirbuster, service enumeration)
4. VULNERABILITY DISCOVERY: Test for weaknesses (web_pentest, fuzzer, api_test, nuclei)
5. EXPLOITATION: Gain initial access (exploit_vuln, bruteforce, payload_generate)
6. POST-EXPLOITATION: Maintain access and pivot (if goal is SHELL_ACCESS)

INTELLIGENT DECISION-MAKING:
- Chain tools logically: port_scan ‚Üí service detection ‚Üí vulnerability testing ‚Üí exploitation
- Prioritize by severity and exploitability (critical > high > medium > low)
- Focus on quick wins: default credentials, known CVEs, misconfigurations
- For SHELL_ACCESS goal: prioritize RCE, command injection, unrestricted file upload
- For WEB_EXPLOITATION: focus on SQLi, XSS, SSRF, authentication bypass
- For INFRASTRUCTURE: comprehensive port scanning, service enumeration, cloud audits
- Respect stealth_level: high=slow/careful/evasive, moderate=balanced, low=fast/aggressive
- Only exploit if risk_tolerance is HIGH and explicit authorization exists

SHELL GAINING STRATEGY:
- Look for command injection, RCE, unrestricted file upload
- Test for weak/default credentials on SSH, RDP, databases
- Exploit known CVEs in identified services
- Generate appropriate payload based on target OS and available services
- Set up listener before payload execution

Response format (JSON only):
{{
    "reasoning": "Explain your strategic decision-making and what you learned from previous findings",
    "next_action": "tool_name",
    "parameters": {{"key": "value"}},
    "risk_level": "low|medium|high|critical",
    "expected_outcome": "What you expect to find or achieve",
    "exploitation_chain": "If exploiting, explain the full attack chain",
    "success_indicators": "How to verify success",
    "stop_testing": false,
    "goal_progress": "Percentage estimate of goal completion (0-100)"
}}

Be strategic, thorough, and ethical. Always consider authorization and legal boundaries."""

    def _format_findings_for_ai(self) -> str:
        """Format current findings for AI context"""
        if not self.findings:
            return "No findings yet. Start with reconnaissance."
        
        summary = f"Current findings ({len(self.findings)} total):\n\n"
        
        # Group by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        for severity in ["critical", "high", "medium", "low", "info"]:
            items = by_severity[severity]
            if items:
                summary += f"{severity.upper()} ({len(items)}):\n"
                for finding in items[:3]:  # Show top 3 per severity
                    summary += f"- [{finding.tool}] {finding.description}\n"
                if len(items) > 3:
                    summary += f"  ... and {len(items) - 3} more\n"
                summary += "\n"
        
        return summary
    
    def _format_actions_for_ai(self) -> str:
        """Format previous actions for AI context"""
        if not self.actions:
            return "No actions taken yet."
        
        summary = f"Previous actions ({len(self.actions)}):\n"
        for action in self.actions[-5:]:  # Show last 5 actions
            summary += f"- {action.action_type} using {action.tool}: {action.reasoning}\n"
        
        return summary
    
    async def _get_next_action(self) -> Dict[str, Any]:
        """Ask AI to determine next action"""
        system_prompt = self._get_system_prompt()
        
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        remaining_time = self.config.time_limit - elapsed
        
        user_prompt = f"""Current state of penetration test:

Target: {self.config.target}
Elapsed time: {elapsed:.1f} minutes
Remaining time: {remaining_time:.1f} minutes
Iteration: {self.iteration + 1}/{self.config.max_iterations}

{self._format_findings_for_ai()}

{self._format_actions_for_ai()}

Based on the current findings and the primary goal ({self.config.primary_goal.value}), what should be the next action?

Respond with a JSON object only (no additional text)."""

        response = await self.ai_provider.query(system_prompt, user_prompt, temperature=0.7)
        
        # Extract JSON from response (handle markdown code blocks)
        response = response.strip()
        if response.startswith("```"):
            lines = response.split("\n")
            response = "\n".join(lines[1:-1])
        
        return json.loads(response)
    
    async def _execute_action(self, action: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the action determined by AI"""
        tool = action["next_action"]
        params = action.get("parameters", {})
        
        # Record the action
        agent_action = AgentAction(
            timestamp=datetime.now().isoformat(),
            action_type="execute",
            tool=tool,
            parameters=params,
            reasoning=action["reasoning"],
            risk_level=action.get("risk_level", "medium")
        )
        self.actions.append(agent_action)
        
        try:
            if tool == "port_scan":
                result = await self._run_port_scan(params)
            elif tool == "syn_scan":
                result = await self._run_syn_scan(params)
            elif tool == "udp_scan":
                result = await self._run_udp_scan(params)
            elif tool == "advanced_scan":
                result = await self._run_advanced_scan(params)
            elif tool == "dirbuster":
                result = await self._run_dirbuster(params)
            elif tool == "crawler":
                result = await self._run_crawler(params)
            elif tool == "fuzzer":
                result = await self._run_fuzzer(params)
            elif tool == "bruteforce":
                result = await self._run_bruteforce(params)
            elif tool == "nuclei":
                result = await self._run_nuclei(params)
            elif tool == "cloud_audit":
                result = await self._run_cloud_audit(params)
            elif tool == "k8s_audit":
                result = await self._run_k8s_audit(params)
            elif tool == "container_audit":
                result = await self._run_container_audit(params)
            elif tool == "exploit_vuln":
                result = await self._run_exploit(params)
            elif tool == "ssl_analyze":
                result = await self._run_ssl_analyze(params)
            elif tool == "os_fingerprint":
                result = await self._run_os_fingerprint(params)
            elif tool == "web_pentest":
                result = await self._run_web_pentest(params)
            elif tool == "api_test":
                result = await self._run_api_test(params)
            elif tool == "takeover_scan":
                result = await self._run_takeover_scan(params)
            elif tool == "tech_detect":
                result = await self._run_tech_detect(params)
            elif tool == "recon":
                result = await self._run_recon(params)
            elif tool == "payload_generate":
                result = await self._run_payload_generate(params)
            else:
                result = {"error": f"Unknown tool: {tool}"}
            
            return result
        except Exception as e:
            return {"error": str(e)}
    
    async def _run_port_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute port scan"""
        ports = params.get("ports", list(range(1, 1001)))
        concurrency = params.get("concurrency", 100 if self.config.stealth_level == StealthLevel.LOW else 20)
        
        result_list = await async_port_scan(
            self.config.target,
            ports=ports,
            concurrency=concurrency
        )
        
        # Convert to findings
        open_ports = [r for r in result_list if r.get("state") == "open"]
        if open_ports:
            for port_info in open_ports:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="port_scan",
                    severity="info",
                    category="reconnaissance",
                    description=f"Open port {port_info['port']} - {port_info.get('service', 'unknown')}",
                    details=port_info,
                    exploitation_potential="low",
                    recommended_action="Further enumerate service"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": open_ports}
    
    async def _run_syn_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute SYN scan"""
        ports = params.get("ports", list(range(1, 1001)))
        
        try:
            result_list = await async_syn_scan(
                self.config.target,
                ports=ports
            )
            
            open_ports = [r for r in result_list if r.get("state") == "open"]
            if open_ports:
                for port_info in open_ports:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="syn_scan",
                        severity="info",
                        category="reconnaissance",
                        description=f"Open port {port_info.get('port')} (SYN scan)",
                        details=port_info,
                        exploitation_potential="low",
                        recommended_action="Version detection"
                    )
                    self.findings.append(finding)
            
            return {"open_ports": len(open_ports), "details": open_ports}
        except Exception as e:
            return {"error": f"SYN scan requires admin/root privileges: {e}"}
    
    async def _run_ssl_analyze(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze SSL/TLS"""
        port = params.get("port", 443)
        
        result = await analyze_ssl(self.config.target, port=port)
        
        # Check for vulnerabilities
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                severity = "high" if "critical" in vuln.lower() else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="ssl_analyze",
                    severity=severity,
                    category="ssl_tls",
                    description=vuln,
                    details=result,
                    exploitation_potential="medium",
                    recommended_action="Update SSL/TLS configuration"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_os_fingerprint(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run OS fingerprinting"""
        fingerprinter = OSFingerprinter()
        # Use comprehensive fingerprint with common ports
        open_ports = params.get("ports", [80, 443, 22, 21, 25])
        result = await fingerprinter.comprehensive_fingerprint(self.config.target, open_ports)
        
        if result.get("os_match"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="os_fingerprint",
                severity="info",
                category="reconnaissance",
                description=f"OS detected: {result['os_match']} (confidence: {result.get('confidence', 0)}%)",
                details=result,
                exploitation_potential="low",
                recommended_action="Tailor exploits to OS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_web_pentest(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web application penetration test"""
        target_url = params.get("url", f"https://{self.config.target}")
        
        tester = AdvancedWebTester(
            target=target_url,
            concurrency=10 if self.config.stealth_level == StealthLevel.HIGH else 50,
            timeout=15.0
        )
        
        vulnerabilities = await tester.run_full_scan()
        
        for vuln in vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="web_pentest",
                severity=vuln.severity.lower(),
                category="web_application",
                description=f"{vuln.vuln_type}: {vuln.description}",
                details=asdict(vuln),
                exploitation_potential=vuln.severity.lower(),
                recommended_action=vuln.remediation
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": [asdict(v) for v in vulnerabilities]}
    
    async def _run_api_test(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Test API security"""
        result = await api_probe(self.config.target)
        
        if result.get("vulnerabilities"):
            for vuln in result["vulnerabilities"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="api_test",
                    severity=vuln.get("severity", "medium"),
                    category="api_security",
                    description=vuln.get("description", "API vulnerability"),
                    details=vuln,
                    exploitation_potential="medium",
                    recommended_action="Review API security controls"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_takeover_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Check for subdomain takeover"""
        result = await takeover_scan(self.config.target)
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="takeover_scan",
                severity="high",
                category="dns_misconfiguration",
                description="Subdomain takeover vulnerability detected",
                details=result,
                exploitation_potential="high",
                recommended_action="Remove dangling DNS records"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_tech_detect(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Detect technologies"""
        result = await detect_tech(self.config.target)
        
        if result.get("technologies"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="tech_detect",
                severity="info",
                category="reconnaissance",
                description=f"Technologies: {', '.join(result['technologies'][:5])}",
                details=result,
                exploitation_potential="low",
                recommended_action="Research known vulnerabilities for detected technologies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_recon(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run reconnaissance"""
        result = await recon(self.config.target)
        
        if result.get("subdomains"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="recon",
                severity="info",
                category="reconnaissance",
                description=f"Found {len(result['subdomains'])} subdomains",
                details=result,
                exploitation_potential="low",
                recommended_action="Scan discovered subdomains"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_payload_generate(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Generate exploitation payload"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Payload generation requires HIGH risk tolerance"}
        
        generator = PayloadGenerator()
        
        lhost = params.get("lhost", "attacker-ip")
        lport = params.get("lport", 4444)
        shell_type = params.get("shell", "bash")
        
        payload = generator.generate_reverse_shell(lhost, lport, shell_type)
        
        finding = Finding(
            timestamp=datetime.now().isoformat(),
            tool="payload_generate",
            severity="critical",
            category="exploitation",
            description=f"Generated {shell_type} reverse shell payload",
            details={"payload": payload.code, "lhost": lhost, "lport": lport},
            exploitation_potential="critical",
            recommended_action="Use only with explicit authorization"
        )
        self.findings.append(finding)
        
        return {"payload": payload.code, "usage": payload.usage}
    
    async def _run_udp_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run UDP port scan"""
        ports = params.get("ports", [53, 67, 68, 69, 123, 135, 137, 138, 161, 500])
        result = await async_udp_scan(self.config.target, ports, concurrency=50, timeout=2.0)
        
        open_ports = [r for r in result if r.get("state") == "open"]
        if open_ports:
            for port_info in open_ports:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="udp_scan",
                    severity="medium",
                    category="network",
                    description=f"Open UDP port {port_info['port']}: {port_info.get('service', 'unknown')}",
                    details=port_info,
                    exploitation_potential="medium",
                    recommended_action="Enumerate UDP services for vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result}
    
    async def _run_advanced_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run advanced scan with service detection"""
        ports = params.get("ports", list(range(1, 1001)))
        scan_type = params.get("scan_type", "syn")  # syn, fin, xmas, null, ack
        result_list = await async_advanced_scan(
            self.config.target,
            ports,
            scan_type=scan_type,
            concurrency=100,
            timeout=2.0
        )
        
        # Process scan results
        open_ports = [r for r in result_list if r.get("state") in ["open", "filtered"]]
        if open_ports:
            for svc in open_ports:
                severity = "high" if any(k in str(svc).lower() for k in ["exploit", "vulnerable"]) else "medium"
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="advanced_scan",
                    severity=severity,
                    category="service_detection",
                    description=f"Service detected: {svc.get('service', 'unknown')} on port {svc.get('port')}",
                    details=svc,
                    exploitation_potential=severity,
                    recommended_action="Test service for known vulnerabilities"
                )
                self.findings.append(finding)
        
        return {"open_ports": len(open_ports), "details": result_list}
    
    async def _run_dirbuster(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run directory busting"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await dirbust_scan(target_url, concurrency=50, https=True)
        
        if result.get("found"):
            for item in result["found"][:20]:  # Top 20 findings
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="dirbuster",
                    severity="info",
                    category="web_enumeration",
                    description=f"Discovered: {item['path']} (Status: {item['status']})",
                    details=item,
                    exploitation_potential="low",
                    recommended_action="Analyze discovered endpoints for sensitive data"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_crawler(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web crawler"""
        target_url = params.get("url", f"https://{self.config.target}")
        result = await crawl(target_url, max_pages=50)
        
        if result.get("secrets"):
            for secret in result["secrets"]:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="crawler",
                    severity="high",
                    category="information_disclosure",
                    description=f"Secret found: {secret.get('type')} in {secret.get('location')}",
                    details=secret,
                    exploitation_potential="high",
                    recommended_action="Secure exposed credentials immediately"
                )
                self.findings.append(finding)
        
        return result
    
    async def _run_fuzzer(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run web fuzzer"""
        if self.config.risk_tolerance == RiskTolerance.LOW:
            return {"error": "Fuzzing requires MEDIUM or HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        wordlist = params.get("wordlist", ["'", '"', "<", ">", "../", "..\\", "{{7*7}}", "${7*7}"])
        fuzzer = AdvancedFuzzer(target_url, wordlist=wordlist, timeout=10.0)
        
        # Fuzz a common parameter
        param_name = params.get("param", "id")
        vulnerabilities = await fuzzer.fuzz_parameters(param_name)
        
        for vuln in vulnerabilities:
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="fuzzer",
                severity="high",
                category="web_vulnerability",
                description=f"Fuzzing vulnerability in {vuln.url}",
                details={
                    "url": vuln.url,
                    "status": vuln.status_code,
                    "length": vuln.content_length,
                    "payload": vuln.payload
                },
                exploitation_potential="high",
                recommended_action="Validate and sanitize all user inputs"
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": vulnerabilities}
    
    async def _run_bruteforce(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run authentication bruteforce"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Bruteforce requires HIGH risk tolerance"}
        
        target_url = params.get("url", f"https://{self.config.target}")
        auth_type = params.get("auth_type", "basic")  # basic, form, json
        username = params.get("username", "admin")
        
        # Use common credentials only
        passwords = ["admin", "password", "123456", "root", "admin123"]
        
        bruteforcer = AuthBruteForcer(target_url, concurrency=5)
        
        # Test based on auth type
        try:
            if auth_type == "basic":
                results = await bruteforcer.brute_force_basic_auth([username], passwords)
            elif auth_type == "form":
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_form([username], passwords, username_field=username_field, password_field=password_field)
            else:  # json
                username_field = params.get("username_field", "username")
                password_field = params.get("password_field", "password")
                results = await bruteforcer.brute_force_json_api([username], passwords, username_field=username_field, password_field=password_field)
            
            # Check for successful authentication
            successful = [r for r in results if r.success]
            if successful:
                for success_result in successful:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="bruteforce",
                        severity="critical",
                        category="authentication",
                        description=f"Weak credentials: {success_result.username}:{success_result.password}",
                        details={"username": success_result.username, "password": success_result.password},
                        exploitation_potential="critical",
                        recommended_action="Enforce strong password policy and account lockout"
                    )
                    self.findings.append(finding)
            
            return {"total_attempts": len(results), "successful": len(successful)}
        except Exception as e:
            return {"error": str(e)}
        
        if results.get("success"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="bruteforce",
                severity="critical",
                category="authentication",
                description=f"Weak credentials: {username}:{results['password']}",
                details=results,
                exploitation_potential="critical",
                recommended_action="Enforce strong password policy and account lockout"
            )
            self.findings.append(finding)
        
        return results
    
    async def _run_nuclei(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Run Nuclei vulnerability scanner"""
        try:
            scanner = NucleiScanner()
            # Nuclei scan is sync, run in thread
            findings = await asyncio.to_thread(
                scanner.scan,
                self.config.target,
                tags=params.get("tags", ["cve", "vulnerability"]),
                severity=["critical", "high"]
            )
            result = {"findings": findings}
            
            if result.get("findings"):
                for vuln in result["findings"]:
                    finding = Finding(
                        timestamp=datetime.now().isoformat(),
                        tool="nuclei",
                        severity=vuln.get("severity", "medium"),
                        category="vulnerability",
                        description=f"Nuclei: {vuln.get('name')}",
                        details=vuln,
                        exploitation_potential=vuln.get("severity", "medium"),
                        recommended_action="Apply security patches"
                    )
                    self.findings.append(finding)
            
            return result
        except Exception as e:
            return {"error": f"Nuclei not available: {str(e)}"}
    
    async def _run_cloud_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit cloud storage"""
        bucket_name = params.get("bucket", self.config.target.replace(".", "-"))
        result = await cloud_audit(bucket_name, providers=["aws", "azure", "gcp"])
        
        if result.get("vulnerable"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="cloud_audit",
                severity="critical",
                category="cloud_misconfiguration",
                description=f"Public cloud storage: {result.get('provider')}",
                details=result,
                exploitation_potential="critical",
                recommended_action="Restrict bucket access with proper IAM policies"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_k8s_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit Kubernetes API"""
        api_base = params.get("api_base", f"https://{self.config.target}:6443")
        result = await k8s_audit(api_base, verify_cert=False)
        
        if result.get("exposed_endpoints"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="k8s_audit",
                severity="critical",
                category="kubernetes",
                description="Unauthenticated Kubernetes API access",
                details=result,
                exploitation_potential="critical",
                recommended_action="Enable RBAC and authentication"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_container_audit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Audit container registry"""
        registry = params.get("registry", f"{self.config.target}:5000")
        result = await container_audit(registry)
        
        if result.get("anonymous_access"):
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="container_audit",
                severity="high",
                category="container_security",
                description="Anonymous container registry access",
                details=result,
                exploitation_potential="high",
                recommended_action="Enable authentication and TLS"
            )
            self.findings.append(finding)
        
        return result
    
    async def _run_exploit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt exploitation based on discovered vulnerabilities"""
        if self.config.risk_tolerance != RiskTolerance.HIGH:
            return {"error": "Exploitation requires HIGH risk tolerance and explicit authorization"}
        
        # Find exploitable vulnerabilities
        exploitable = [f for f in self.findings if f.exploitation_potential in ["critical", "high"]]
        
        if not exploitable:
            return {"message": "No exploitable vulnerabilities found yet"}
        
        # Prioritize RCE, command injection, file upload
        rce_vulns = [f for f in exploitable if any(
            keyword in f.description.lower() 
            for keyword in ["rce", "command injection", "file upload", "sql injection"]
        )]
        
        if rce_vulns:
            target_vuln = rce_vulns[0]
            
            # Generate appropriate payload
            generator = PayloadGenerator()
            lhost = params.get("lhost", "ATTACKER-IP-REQUIRED")
            lport = params.get("lport", 4444)
            
            # Determine OS from fingerprinting
            os_findings = [f for f in self.findings if f.tool == "os_fingerprint"]
            os_type = "linux"
            if os_findings:
                os_match = os_findings[0].details.get("os_match", "").lower()
                if "windows" in os_match:
                    os_type = "windows"
            
            shell_type = "powershell" if os_type == "windows" else "bash"
            payload = generator.generate_reverse_shell(lhost, lport, shell_type)
            
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="exploit_vuln",
                severity="critical",
                category="exploitation",
                description=f"Exploitation payload for {target_vuln.description}",
                details={
                    "target_vulnerability": target_vuln.description,
                    "payload": payload.code,
                    "usage": payload.usage,
                    "lhost": lhost,
                    "lport": lport,
                    "shell_type": shell_type,
                    "listener_command": f"nc -lvnp {lport}" if os_type == "linux" else f"ncat.exe -lvnp {lport}"
                },
                exploitation_potential="critical",
                recommended_action="Set up listener before executing payload"
            )
            self.findings.append(finding)
            
            return {
                "exploitation_ready": True,
                "target_vulnerability": target_vuln.description,
                "payload": payload.code,
                "shell_type": shell_type,
                "listener_setup": f"nc -lvnp {lport}" if os_type == "linux" else f"ncat.exe -lvnp {lport}",
                "warning": "‚ö†Ô∏è ONLY USE WITH EXPLICIT WRITTEN AUTHORIZATION"
            }
        
        return {"message": "Analyzing exploitation paths..."}
    
    def _check_authorization(self, action: Dict[str, Any]) -> bool:
        """Check if action requires authorization"""
        high_risk_tools = ["payload_generate", "bruteforce", "exploit_vuln", "web_pentest", "fuzzer"]
        tool = action["next_action"]
        risk_level = action.get("risk_level", "medium")
        
        if tool in high_risk_tools or risk_level == "high":
            if self.config.autonomy_level == AutonomyLevel.FULLY_AUTONOMOUS:
                return True
            elif self.config.autonomy_level == AutonomyLevel.SEMI_AUTONOMOUS:
                # Would prompt user in real implementation
                return True
            else:  # SUPERVISED
                # Would always prompt in real implementation
                return True
        
        return True
    
    def _should_stop(self, ai_decision: Dict[str, Any]) -> bool:
        """Determine if testing should stop"""
        # Time limit check
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        if elapsed >= self.config.time_limit:
            return True
        
        # Max iterations check
        if self.iteration >= self.config.max_iterations:
            return True
        
        # AI decision
        if ai_decision.get("stop_testing", False):
            return True
        
        # Goal achievement check (simplified)
        if self.config.primary_goal == PrimaryGoal.COMPREHENSIVE:
            tools_used = set(action.tool for action in self.actions)
            required_tools = {"recon", "port_scan", "web_pentest", "ssl_analyze"}
            if required_tools.issubset(tools_used):
                return True
        
        return False
    
    async def execute(self) -> Dict[str, Any]:
        """Execute the AI-powered penetration test"""
        print(f"\nü§ñ AI Penetration Test Agent Starting...")
        print(f"Target: {self.config.target}")
        print(f"Goal: {self.config.primary_goal.value}")
        print(f"AI Provider: {self.config.ai_provider} ({self.config.model})")
        print(f"Time Limit: {self.config.time_limit} minutes")
        print(f"Autonomy: {self.config.autonomy_level.value}")
        print(f"Risk Tolerance: {self.config.risk_tolerance.value}\n")
        
        try:
            while self.iteration < self.config.max_iterations:
                self.iteration += 1
                print(f"üîç Iteration {self.iteration}/{self.config.max_iterations}")
                
                # Get AI decision
                print("  üß† Consulting AI for next action...")
                ai_decision = await self._get_next_action()
                
                print(f"  üí≠ AI Reasoning: {ai_decision['reasoning']}")
                print(f"  üéØ Next Action: {ai_decision['next_action']}")
                print(f"  ‚ö†Ô∏è  Risk Level: {ai_decision.get('risk_level', 'medium')}")
                
                # Check if we should stop
                if self._should_stop(ai_decision):
                    print("\n‚úÖ Testing complete (stopping condition met)")
                    break
                
                # Check authorization for high-risk actions
                if not self._check_authorization(ai_decision):
                    print("  ‚õî Action denied (requires authorization)")
                    continue
                
                # Execute the action
                print(f"  ‚ö° Executing: {ai_decision['next_action']}...")
                result = await self._execute_action(ai_decision)
                
                if "error" in result:
                    print(f"  ‚ùå Error: {result['error']}")
                else:
                    print(f"  ‚úÖ Completed successfully")
                
                # Brief pause between iterations
                await asyncio.sleep(2)
                print()
            
            # Generate final report
            report = self._generate_report()
            
            return report
            
        finally:
            await self.ai_provider.close()
    
    def _generate_report(self) -> Dict[str, Any]:
        """Generate final report"""
        elapsed = (datetime.now() - self.start_time).total_seconds() / 60
        
        # Group findings by severity
        by_severity = {"critical": [], "high": [], "medium": [], "low": [], "info": []}
        for finding in self.findings:
            by_severity.get(finding.severity.lower(), by_severity["info"]).append(finding)
        
        report = {
            "summary": {
                "target": self.config.target,
                "primary_goal": self.config.primary_goal.value,
                "start_time": self.start_time.isoformat(),
                "end_time": datetime.now().isoformat(),
                "duration_minutes": round(elapsed, 2),
                "iterations": self.iteration,
                "total_findings": len(self.findings),
                "total_actions": len(self.actions),
                "ai_provider": self.config.ai_provider,
                "ai_model": self.config.model
            },
            "findings_by_severity": {
                "critical": len(by_severity["critical"]),
                "high": len(by_severity["high"]),
                "medium": len(by_severity["medium"]),
                "low": len(by_severity["low"]),
                "info": len(by_severity["info"])
            },
            "detailed_findings": [asdict(f) for f in self.findings],
            "actions_taken": [asdict(a) for a in self.actions],
            "recommendations": self._generate_recommendations()
        }
        
        return report
    
    def _generate_recommendations(self) -> List[str]:
        """Generate high-level recommendations"""
        recommendations = []
        
        # Count by severity
        critical = sum(1 for f in self.findings if f.severity == "critical")
        high = sum(1 for f in self.findings if f.severity == "high")
        
        if critical > 0:
            recommendations.append(f"üö® URGENT: Address {critical} critical vulnerabilities immediately")
        
        if high > 0:
            recommendations.append(f"‚ö†Ô∏è  HIGH PRIORITY: Fix {high} high-severity issues")
        
        # Category-specific recommendations
        categories = set(f.category for f in self.findings)
        
        if "web_application" in categories:
            recommendations.append("üåê Review web application security controls (input validation, authentication)")
        
        if "ssl_tls" in categories:
            recommendations.append("üîí Update SSL/TLS configuration (remove weak ciphers, enable modern protocols)")
        
        if "dns_misconfiguration" in categories:
            recommendations.append("üì° Review DNS configuration for misconfigurations and takeover risks")
        
        if not recommendations:
            recommendations.append("‚úÖ No critical issues found. Continue regular security assessments.")
        
        return recommendations
