# This file contains the corrected implementation sections
# Copy these into ai_pentest.py to fix all errors

# FIX 1: Advanced scan return handling
async def _run_advanced_scan(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """Run advanced scan with service detection"""
    ports = params.get("ports", list(range(1, 1001)))
    scan_type = params.get("scan_type", "syn")  # syn, fin, xmas, null, ack
    result_list = await async_advanced_scan(
        self.config.target,
        ports,
        scan_type=scan_type,
        concurrency=100,
        timeout=2.0
    )
    
    # Process scan results
    open_ports = [r for r in result_list if r.get("state") in ["open", "filtered"]]
    if open_ports:
        for svc in open_ports:
            severity = "high" if any(k in str(svc).lower() for k in ["exploit", "vulnerable"]) else "medium"
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="advanced_scan",
                severity=severity,
                category="service_detection",
                description=f"Service detected: {svc.get('service', 'unknown')} on port {svc.get('port')}",
                details=svc,
                exploitation_potential=severity,
                recommended_action="Test service for known vulnerabilities"
            )
            self.findings.append(finding)
    
    return {"open_ports": len(open_ports), "details": result_list}

# FIX 2: Bruteforce with correct method names
async def _run_bruteforce(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """Run authentication bruteforce"""
    if self.config.risk_tolerance != RiskTolerance.HIGH:
        return {"error": "Bruteforce requires HIGH risk tolerance"}
    
    target_url = params.get("url", f"https://{self.config.target}")
    auth_type = params.get("auth_type", "basic")  # basic, form, json
    username = params.get("username", "admin")
    
    # Use common credentials only
    passwords = ["admin", "password", "123456", "root", "admin123"]
    
    bruteforcer = AuthBruteForcer(target_url, concurrency=5)
    
    # Test based on auth type
    try:
        if auth_type == "basic":
            results = await bruteforcer.brute_force_basic_auth(username, passwords)
        elif auth_type == "form":
            form_fields = params.get("form_fields", {"username": "username", "password": "password"})
            results = await bruteforcer.brute_force_form(username, passwords, form_fields=form_fields)
        else:  # json
            json_fields = params.get("json_fields", {"username": "username", "password": "password"})
            results = await bruteforcer.brute_force_json_api(username, passwords, json_fields=json_fields)
        
        # Check for successful authentication
        successful = [r for r in results if r.success]
        if successful:
            for success_result in successful:
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="bruteforce",
                    severity="critical",
                    category="authentication",
                    description=f"Weak credentials: {success_result.username}:{success_result.password}",
                    details={"username": success_result.username, "password": success_result.password, "status": success_result.status_code},
                    exploitation_potential="critical",
                    recommended_action="Enforce strong password policy and account lockout"
                )
                self.findings.append(finding)
        
        return {"total_attempts": len(results), "successful": len(successful), "details": [{"username": r.username, "success": r.success} for r in results]}
    except Exception as e:
        return {"error": str(e)}

# FIX 3: Nuclei with correct sync handling
async def _run_nuclei(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """Run Nuclei vulnerability scanner"""
    try:
        scanner = NucleiScanner()
        # Nuclei scan is sync, run in thread
        findings = await asyncio.to_thread(
            scanner.scan,
            self.config.target,
            tags=params.get("tags", ["cve", "vulnerability"]),
            severity=["critical", "high"]
        )
        
        if findings:
            for vuln in findings[:10]:  # Limit to top 10 findings
                finding = Finding(
                    timestamp=datetime.now().isoformat(),
                    tool="nuclei",
                    severity=vuln.get("severity", "medium").lower(),
                    category="vulnerability",
                    description=f"Nuclei: {vuln.get('template_id', 'Unknown')} - {vuln.get('name', '')}",
                    details=vuln,
                    exploitation_potential=vuln.get("severity", "medium").lower(),
                    recommended_action="Apply security patches"
                )
                self.findings.append(finding)
        
        return {"findings_count": len(findings), "details": findings[:10]}
    except FileNotFoundError:
        return {"error": "Nuclei not installed. Install from: https://github.com/projectdiscovery/nuclei"}
    except Exception as e:
        return {"error": f"Nuclei scan failed: {str(e)}"}

# FIX 4: Fuzzer with correct initialization
async def _run_fuzzer(self, params: Dict[str, Any]) -> Dict[str, Any]:
    """Run web fuzzer"""
    if self.config.risk_tolerance == RiskTolerance.LOW:
        return {"error": "Fuzzing requires MEDIUM or HIGH risk tolerance"}
    
    target_url = params.get("url", f"https://{self.config.target}")
    # Common fuzzing payloads
    wordlist = ["'", '"', "<script>", "><script>", "../", "..\\\\", "{{7*7}}", "${7*7}", "`id`", ";ls;"]
    fuzzer = AdvancedFuzzer(target_url, wordlist=wordlist, concurrency=10, timeout=10.0)
    
    try:
        # Fuzz a common parameter
        param_name = params.get("param", "id")
        vulnerabilities = await fuzzer.fuzz_parameters(param_name)
        
        for vuln in vulnerabilities[:15]:  # Limit to top 15
            finding = Finding(
                timestamp=datetime.now().isoformat(),
                tool="fuzzer",
                severity="high",
                category="web_vulnerability",
                description=f"Fuzzing anomaly: {vuln.url} with payload '{vuln.payload}'",
                details={
                    "url": vuln.url,
                    "status": vuln.status_code,
                    "length": vuln.content_length,
                    "payload": vuln.payload,
                    "response_time": vuln.response_time
                },
                exploitation_potential="high",
                recommended_action="Validate and sanitize all user inputs"
            )
            self.findings.append(finding)
        
        return {"vulnerabilities_found": len(vulnerabilities), "details": [{"url": v.url, "payload": v.payload} for v in vulnerabilities[:15]]}
    except Exception as e:
        return {"error": str(e)}
