// Exploit Framework for Scorpion Security Platform
// Provides ethical penetration testing capabilities
import axios from 'axios';

export class ExploitFramework {
  constructor() {
    this.exploits = new Map();
    this.payloads = new Map();
    this.initialized = false;
    this.owaspTests = [];
  }

  async initialize() {
    console.log('ðŸ”§ Initializing Exploit Framework...');
    await this.loadExploits();
    this.initialized = true;
    console.log('âœ… Exploit Framework initialized');
  }

  async loadExploits() {
    // Common vulnerability exploits for ethical testing
    const commonExploits = [
      {
        id: 'sql_injection',
        name: 'SQL Injection Test',
        severity: 'high',
        description: 'Tests for SQL injection vulnerabilities',
        payload: "' OR '1'='1"
      },
      {
        id: 'xss_reflected',
        name: 'Reflected XSS Test',
        severity: 'medium',
        description: 'Tests for reflected cross-site scripting',
        payload: '<script>alert("XSS")</script>'
      },
      {
        id: 'directory_traversal',
        name: 'Directory Traversal Test',
        severity: 'high',
        description: 'Tests for directory traversal vulnerabilities',
        payload: '../../../etc/passwd'
      },
      {
        id: 'command_injection',
        name: 'Command Injection Test',
        severity: 'critical',
        description: 'Tests for OS command injection',
        payload: '; ls -la'
      }
    ];

    commonExploits.forEach(exploit => {
      this.exploits.set(exploit.id, exploit);
    });

    // Minimal, non-destructive OWASP Top 10 probe definitions
    this.owaspTests = [
      {
        id: 'A03:2021-Injection-SQLi',
        name: 'OWASP A03 Injection (SQLi) probe',
        severity: 'high',
        type: 'sql_injection',
        params: ['id', 'q', 'search'],
        payload: "' OR '1'='1-- -",
      },
      {
        id: 'A03:2021-Injection-Command',
        name: 'OWASP A03 Injection (Command) probe',
        severity: 'critical',
        type: 'command_injection',
        params: ['cmd', 'ping', 'exec'],
        payload: '; ping -c 1 127.0.0.1',
      },
      {
        id: 'A03:2021-XSS-Reflected',
        name: 'OWASP A03 Injection (XSS Reflected) probe',
        severity: 'medium',
        type: 'xss_reflected',
        params: ['q', 'search', 's'],
        payload: '<ScorpionXSS>',
      },
      {
        id: 'A01:2021-Broken-Access-Control',
        name: 'OWASP A01 Broken Access Control (direct admin access)',
        severity: 'high',
        type: 'bac_direct',
        paths: ['/admin', '/admin/dashboard', '/dashboard'],
      },
      {
        id: 'A05:2021-Security-Misconfiguration',
        name: 'OWASP A05 Security Headers Check',
        severity: 'medium',
        type: 'sec_headers',
      },
      {
        id: 'A10:2021-SSRF',
        name: 'OWASP A10 Server-Side Request Forgery (SSRF) probe',
        severity: 'high',
        type: 'ssrf',
        params: ['url', 'dest', 'target', 'next'],
        payload: 'http://169.254.169.254/latest/meta-data/',
      },
      {
        id: 'A01:2021-Open-Redirect',
        name: 'OWASP A01 Open Redirect probe',
        severity: 'medium',
        type: 'open_redirect',
        params: ['redirect', 'next', 'url', 'to'],
        payload: 'https://example.com',
      },
      {
        id: 'A05:2021-Path-Traversal',
        name: 'OWASP A05 Path Traversal probe',
        severity: 'high',
        type: 'directory_traversal',
        params: ['file', 'path', 'page'],
        unixPayload: '../../../../etc/passwd',
        winPayload: '..\\..\\..\\..\\Windows\\win.ini',
      },
      {
        id: 'A07:2021-Auth-Failures',
        name: 'OWASP A07 Authentication Failures (weak endpoints)',
        severity: 'high',
        type: 'auth_fail',
        paths: ['/login', '/signin', '/api/login'],
      },
    ];
  }

  async testTarget(target, options = {}) {
    if (!this.initialized) {
      await this.initialize();
    }

    console.log(`ðŸŽ¯ Testing target: ${target}`);
    
    const results = {
      target: target,
      timestamp: new Date().toISOString(),
      vulnerabilities: [],
      exploitable: []
    };

    // Simulate ethical penetration testing
    for (const [id, exploit] of this.exploits) {
      if (Math.random() > 0.8) { // 20% chance of finding vulnerability
        results.vulnerabilities.push({
          exploit_id: id,
          name: exploit.name,
          severity: exploit.severity,
          description: exploit.description,
          exploitable: Math.random() > 0.6,
          remediation: this.getRemediation(id)
        });
      }
    }

    return results;
  }

  getRemediation(exploitId) {
    const remediations = {
      'sql_injection': 'Use parameterized queries and input validation',
      'xss_reflected': 'Implement output encoding and Content Security Policy',
      'directory_traversal': 'Validate and sanitize file paths',
      'command_injection': 'Use safe APIs and avoid shell execution'
    };

    return remediations[exploitId] || 'Apply security best practices';
  }

  listExploits() {
    return Array.from(this.exploits.values());
  }

  buildBaseUrls(target, port, service) {
    const bases = [];
    const host = target.replace(/\/$/, '');
    const ports = [];
    if (port) ports.push(String(port));
    const svc = (service || '').toLowerCase();
    const preferHttps = svc === 'https' || (!svc && Number(port) === 443);
    if (preferHttps) {
      bases.push(`https://${host}${port ? `:${port}` : ''}`);
      bases.push(`http://${host}${port ? `:${port}` : ''}`);
    } else {
      bases.push(`http://${host}${port ? `:${port}` : ''}`);
      bases.push(`https://${host}${port ? `:${port}` : ''}`);
    }
    return bases;
  }

  async safeGet(url, opts = {}) {
    try {
      const res = await axios.get(url, {
        maxRedirects: 5,
        timeout: 7000,
        validateStatus: () => true,
        headers: {
          'User-Agent': 'Scorpion-Security-CLI/1.0',
          ...(opts.headers || {}),
        },
      });
      return res;
    } catch (e) {
      return { error: e.message };
    }
  }

  selectTestsByPayload(payload) {
    const p = (payload || 'all').toLowerCase();
    if (p === 'all' || p === 'owasp-top10') return this.owaspTests;
    const map = {
      'sql-injection': ['sql_injection'],
      'xss': ['xss_reflected'],
      'ssrf': ['ssrf'],
      'open-redirect': ['open_redirect'],
      'path-traversal': ['directory_traversal'],
      'broken-access-control': ['bac_direct'],
      'security-misconfiguration': ['sec_headers'],
      'auth': ['auth_fail'],
    };
    const types = map[p] || [];
    return this.owaspTests.filter(t => types.includes(t.type));
  }

  async runXssProbe(baseUrl, test) {
    for (const param of test.params) {
      const u = new URL(baseUrl);
      u.searchParams.set(param, test.payload);
      const res = await this.safeGet(u.toString());
      if (res && res.data && typeof res.data === 'string' && res.data.includes(test.payload)) {
        return { success: true, evidence: `Payload reflected via ?${param}=` };
      }
    }
    return { success: false };
  }

  async runSqlProbe(baseUrl, test) {
    const errorHints = ['SQL', 'mysql', 'syntax error', 'warning', 'PDOException'];
    for (const param of test.params) {
      const u = new URL(baseUrl);
      u.searchParams.set(param, test.payload);
      const res = await this.safeGet(u.toString());
      if (res && res.data && typeof res.data === 'string') {
        const body = res.data.toString();
        if (errorHints.some(h => body.toLowerCase().includes(h.toLowerCase())) || (res.status >= 500 && res.status <= 599)) {
          return { success: true, evidence: `SQL error pattern via ?${param}=` };
        }
      }
    }
    return { success: false };
  }

  async runTraversalProbe(baseUrl, test) {
    const attempts = [test.unixPayload, test.winPayload];
    for (const param of test.params) {
      for (const payload of attempts) {
        const u = new URL(baseUrl);
        u.searchParams.set(param, payload);
        const res = await this.safeGet(u.toString());
        if (res && res.data && typeof res.data === 'string') {
          const body = res.data.toString();
          if (body.includes('root:x:') || body.includes('[fonts]')) {
            return { success: true, evidence: `Traversal via ?${param}=` };
          }
        }
      }
    }
    return { success: false };
  }

  async runOpenRedirectProbe(baseUrl, test) {
    for (const param of test.params) {
      const u = new URL(baseUrl);
      u.searchParams.set(param, test.payload);
      const res = await this.safeGet(u.toString(), { maxRedirects: 0 });
      const loc = res?.headers?.location || res?.request?.res?.headers?.location;
      if ((res.status >= 300 && res.status < 400) && loc && loc.startsWith('https://example.com')) {
        return { success: true, evidence: `Redirect controlled via ?${param}=` };
      }
    }
    return { success: false };
  }

  async runSecHeadersProbe(baseUrl) {
    const res = await this.safeGet(baseUrl);
    const headers = (res && res.headers) ? res.headers : {};
    const missing = [];
    const must = ['content-security-policy', 'x-content-type-options', 'x-frame-options', 'referrer-policy'];
    must.forEach(h => { if (!headers[h]) missing.push(h); });
    if (missing.length) {
      return { success: true, evidence: `Missing security headers: ${missing.join(', ')}` };
    }
    return { success: false };
  }

  async runBacProbe(baseUrl, test) {
    for (const p of test.paths) {
      const u = new URL(baseUrl);
      u.pathname = p;
      const res = await this.safeGet(u.toString());
      if (res && res.status === 200) {
        return { success: true, evidence: `Accessible sensitive path: ${p}` };
      }
    }
    return { success: false };
  }

  async runAuthProbe(baseUrl, test) {
    // Basic check: endpoints exist and may return 200 without auth
    for (const p of test.paths) {
      const u = new URL(baseUrl);
      u.pathname = p;
      const res = await this.safeGet(u.toString());
      if (res && res.status === 200) {
        return { success: true, evidence: `Authentication endpoint open: ${p}` };
      }
    }
    return { success: false };
  }

  async runSsrfProbe(baseUrl, test) {
    // Non-destructive heuristic check only; detection is inherently context-specific
    for (const param of test.params) {
      const u = new URL(baseUrl);
      u.searchParams.set(param, test.payload);
      const res = await this.safeGet(u.toString());
      if (res && (res.status >= 400 && res.status < 600)) {
        // If server attempts to fetch, different behavior may occur; we mark as inconclusive unless we see the URL reflected
        if (typeof res.data === 'string' && res.data.includes('169.254.169.254')) {
          return { success: true, evidence: `URL reflected via ?${param}= (potential SSRF)` };
        }
      }
    }
    return { success: false };
  }

  async executeExploits(target, options = {}) {
    if (!this.initialized) await this.initialize();

    const { port, service, payload = 'owasp-top10', mode = 'reconnaissance' } = options;
    const bases = this.buildBaseUrls(target, port, service);
    const tests = this.selectTestsByPayload(payload);

    const results = {
      target,
      mode,
      totalPayloads: tests.length * bases.length,
      successful: 0,
      failed: 0,
      exploits: [],
      timestamp: new Date().toISOString(),
    };

    for (const base of bases) {
      for (const test of tests) {
        let probe = { success: false };
        try {
          if (test.type === 'xss_reflected') probe = await this.runXssProbe(base, test);
          else if (test.type === 'sql_injection') probe = await this.runSqlProbe(base, test);
          else if (test.type === 'directory_traversal') probe = await this.runTraversalProbe(base, test);
          else if (test.type === 'open_redirect') probe = await this.runOpenRedirectProbe(base, test);
          else if (test.type === 'sec_headers') probe = await this.runSecHeadersProbe(base, test);
          else if (test.type === 'bac_direct') probe = await this.runBacProbe(base, test);
          else if (test.type === 'auth_fail') probe = await this.runAuthProbe(base, test);
          else if (test.type === 'ssrf') probe = await this.runSsrfProbe(base, test);
        } catch (e) {
          probe = { success: false, error: e.message };
        }

        const exploitRecord = {
          name: test.name,
          category: test.id,
          target: target,
          port: port || (base.startsWith('https') ? 443 : 80),
          method: 'GET',
          url: base,
          response: probe.success,
          evidence: probe.evidence || null,
          error: probe.error || null,
          shell: false,
        };
        if (probe.success) results.successful += 1; else results.failed += 1;
        results.exploits.push(exploitRecord);

        if (options.delay) {
          await new Promise(r => setTimeout(r, Number(options.delay)));
        }
      }
    }

    return results;
  }

  async generateExploitReport(results) {
    return {
      summary: `Found ${results.vulnerabilities.length} potential vulnerabilities`,
      critical: results.vulnerabilities.filter(v => v.severity === 'critical').length,
      high: results.vulnerabilities.filter(v => v.severity === 'high').length,
      medium: results.vulnerabilities.filter(v => v.severity === 'medium').length,
      exploitable: results.vulnerabilities.filter(v => v.exploitable).length,
      details: results.vulnerabilities
    };
  }

  async autoSelectPayloads(vulnerabilities) {
    const selectedPayloads = [];
    
    vulnerabilities.forEach(vuln => {
      const exploit = this.exploits.get(vuln.type || 'sql_injection');
      if (exploit) {
        selectedPayloads.push({
          vulnerability: vuln,
          payload: exploit.payload,
          technique: exploit.name,
          priority: this.getPriorityScore(vuln.severity)
        });
      }
    });

    return selectedPayloads.sort((a, b) => b.priority - a.priority);
  }

  getPriorityScore(severity) {
    const scores = {
      'critical': 100,
      'high': 75,
      'medium': 50,
      'low': 25
    };
    return scores[severity] || 0;
  }

  async executePayload(target, payload, options = {}) {
    // Ethical testing simulation only
    return {
      success: Math.random() > 0.7,
      response: 'Payload testing completed (simulation)',
      target: target,
      payload: payload,
      timestamp: new Date().toISOString()
    };
  }
}